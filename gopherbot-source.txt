# concatenation of gopherbot-main/ - all the files from gopherbot-main/
# have been included in this single file, each preceded by a
# descriptive preamble that includes the filename in the opening
# tag.
# This file is the concatenation of the entirety of the Gopherbot
# source code Git repository. The Go files make up the core engine.
# The files in conf/ define the default robot - the contents of this
# configuration can be overriden by configuration in individual
# robot repositories.
# The scripts under jobs, plugins, and tasks are default scripts for
# jobs, plugins and tasks. They can be overriden by an individual robot
# by having the same script in the robot's git repository. They
# are only active if referenced in "robot.yaml"; either the one
# from the default robot, or from an individual robot.
# Note that preamble descriptions have been omitted, and the purpose
# of each file should be derived from the path, filename, and
# content.
<preamble file: gopherbot-main/.circleci/config.yml>

</preamble>
<file_content file: gopherbot-main/.circleci/config.yml>
# Golang CircleCI 2.0 configuration file
#
# Check https://circleci.com/docs/2.0/language-go/ for more details
version: 2
jobs:
  build:
    docker:
      # specify the version
      - image: "circleci/golang:1.13.4"

    working_directory: ~/gopherbot
    steps:
      - checkout

      # specify any bash command here prefixed with `run: `

      # Get the github publishing tool
      # - run:
      #     name: Install release tool
      #     command: go get github.com/lnxjedi/github-release
      # Coverage tool
      - run:
          name: Install coverage tool
          command: go get github.com/mattn/goveralls
      # Dependencies for integration tests
      - run:
          name: Install dependencies for integration tests
          command: sudo apt-get update && sudo apt-get install -y ruby python

      # Test
      - run:
          name: Run integration tests
          command: |
            go test -v --tags 'test integration' -cover -race -coverprofile coverage.out -coverpkg ./... ./bot
          # cat bot/test.log # if testing fails, uncomment and add '|| :' above

      # Publish coverage
      - run:
          name: Publish coverage results
          command: goveralls -coverprofile=coverage.out -service=circle-ci -repotoken=$COVERALLS_TOKEN

      # Build
      # - run:
      #     name: Build platform-specific zip archives
      #     command: ./mkdist.sh

      # Publish
      # - deploy:
      #     name: Publish archives to Github
      #     command: ./publish.sh
</file_content file: gopherbot-main/.circleci/config.yml>
<preamble file: gopherbot-main/.github/workflows/build-container-base.yml>

</preamble>
<file_content file: gopherbot-main/.github/workflows/build-container-base.yml>
name: build-base

on:
  schedule:
    - cron: "14 7 * * 0"
  workflow_dispatch:
    inputs:
      build_anyway:
        type: boolean
        description: Allow the workflow to run when repo owner != lnxjedi

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/gopherbot-base

jobs:
  build-and-push-container-base:
    if: ( github.repository_owner == 'lnxjedi' ) || github.event.inputs.build_anyway
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Log in to the Container registry
      uses: docker/login-action@f75d088332b07a08afadf6ac53c74509b9453f12
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@314ddf6d4a82333bf1bc7630399df41bf68eba09
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

    - name: Build and push Docker image
      uses: docker/build-push-action@175d02bffea74695e96b351069ac938b338802f9
      with:
        context: .
        file: resources/containers/containerfile.base
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        labels: ${{ steps.meta.outputs.labels }}
</file_content file: gopherbot-main/.github/workflows/build-container-base.yml>
<preamble file: gopherbot-main/.github/workflows/build-daily-dev.yml>

</preamble>
<file_content file: gopherbot-main/.github/workflows/build-daily-dev.yml>
name: build daily dev container

on:
  schedule:
  # Build dev container daily
  - cron: "42 7 * * *"
  workflow_dispatch:
    inputs:
      build_anyway:
        type: boolean
        description: Allow the workflow to run when repo owner != lnxjedi

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/gopherbot-dev

jobs:
  build-dev:
    if: ( github.repository_owner == 'lnxjedi' ) || github.event.inputs.build_anyway
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Create repo tmp dir
      run: |
        mkdir -p resources/containers/tmp

    - name: Checkout repository for container
      uses: actions/checkout@v3
      with:
        path: resources/containers/tmp/gopherbot
        fetch-depth: 0

    - name: Checkout doc repository for container
      uses: actions/checkout@v3
      with:
        repository: lnxjedi/gopherbot-doc
        path: resources/containers/tmp/gopherbot-doc
        fetch-depth: 0

    - name: Fix up gopherbot repository URL
      run: |
        cd resources/containers/tmp/gopherbot
        git remote set-url origin git@github.com:${{ github.repository_owner }}/gopherbot.git

    - name: Fix up gopherbot-doc repository URL
      run: |
        cd resources/containers/tmp/gopherbot-doc
        git remote set-url origin git@github.com:${{ github.repository_owner }}/gopherbot-doc.git
      
    - name: Log in to the Container registry
      uses: docker/login-action@f75d088332b07a08afadf6ac53c74509b9453f12
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@314ddf6d4a82333bf1bc7630399df41bf68eba09
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

    - name: Build and push Docker image
      uses: docker/build-push-action@175d02bffea74695e96b351069ac938b338802f9
      with:
        context: resources/containers/
        file: resources/containers/containerfile.dev
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        labels: ${{ steps.meta.outputs.labels }}
</file_content file: gopherbot-main/.github/workflows/build-daily-dev.yml>
<preamble file: gopherbot-main/.github/workflows/build-weekly-latest.yml>

</preamble>
<file_content file: gopherbot-main/.github/workflows/build-weekly-latest.yml>
name: build weekly prod container

on:
  schedule:
    - cron: "14 14 * * 0"
  workflow_dispatch:
    inputs:
      build_anyway:
        type: boolean
        description: Allow the workflow to run when repo owner != lnxjedi

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/gopherbot

jobs:
  build-prod:
    if: ( github.repository_owner == 'lnxjedi' ) || github.event.inputs.build_anyway
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Log in to the Container registry
      uses: docker/login-action@f75d088332b07a08afadf6ac53c74509b9453f12
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@314ddf6d4a82333bf1bc7630399df41bf68eba09
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

    - name: Build and push Docker image
      uses: docker/build-push-action@175d02bffea74695e96b351069ac938b338802f9
      with:
        context: resources/containers/
        file: resources/containers/containerfile.min
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        labels: ${{ steps.meta.outputs.labels }}
</file_content file: gopherbot-main/.github/workflows/build-weekly-latest.yml>
<preamble file: gopherbot-main/.github/workflows/build.yml>

</preamble>
<file_content file: gopherbot-main/.github/workflows/build.yml>
name: build-release

on:
  push:
    tags:
    - v*
  pull_request:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - uses: actions/setup-go@v1
        with:
          go-version: '1.19' # The Go version to download (if necessary) and use.
      - name: Test
        run: make test
      - name: Build
        run: make dist
      - name: Release
        if: startsWith(github.ref, 'refs/tags/')
        # softprops/action-gh-release v0.1.12
        uses: softprops/action-gh-release@2d72d869af3bf23602f9593a1e3fd739b80ac1eb
        with:
          files: gopherbot-linux-amd64.tar.gz
          body: |
            See the [CHANGELOG](https://github.com/lnxjedi/gopherbot/blob/main/CHANGELOG.md)
</file_content file: gopherbot-main/.github/workflows/build.yml>
<preamble file: gopherbot-main/.gitignore>

</preamble>
<file_content file: gopherbot-main/.gitignore>
coverage.*
gopherbot
gopherbot.exe
gopherbot*zip
gopherbot*tar.gz
*.pyc
# Ignore symlinks useful for development
plugins/gopherbot_v1.py
jobs/gopherbot_v1.py
tasks/gopherbot_v1.py
plugins/gopherbot_v2.py
jobs/gopherbot_v2.py
tasks/gopherbot_v2.py
.env
*.so
# For dev env
gopherbot-doc
robot.log
.vscode
*fail.log
tmp/
binary-encrypted-key*
</file_content file: gopherbot-main/.gitignore>
<preamble file: gopherbot-main/.gitpod.yml>

</preamble>
<file_content file: gopherbot-main/.gitpod.yml>
---
image:
    file: .gitpod/Dockerfile
    context: .gitpod
checkoutLocation: gopherbot
workspaceLocation: "."
tasks:
- before: make -C gopherbot
- init: cp -a ./gopherbot/.gitpod/*.theia-workspace /workspace
- init: ./gopherbot/.gitpod/gotools.sh
- command: ./gopherbot/.gitpod/setup.sh
  openIn: main
ports:
- port: 8080
  onOpen: ignore
</file_content file: gopherbot-main/.gitpod.yml>
<preamble file: gopherbot-main/.gitpod/Dockerfile>

</preamble>
<file_content file: gopherbot-main/.gitpod/Dockerfile>
FROM golang:1.13.8

RUN apt-get update && \
  apt-get -y upgrade && \
  apt-get install -y \
    curl \
    git \
    jq \
    less \
    openssh-client \
    python3 \
    ruby \
    zip \
    unzip && \
  apt-get clean && \
  rm -rf /var/lib/apt/lists/* && \
  echo "export PATH=$PATH:/usr/local/go/bin:/workspace/go/bin" > /etc/profile.d/golang.sh

ENV GOPATH=/workspace/golang
</file_content file: gopherbot-main/.gitpod/Dockerfile>
<preamble file: gopherbot-main/.gitpod/clu.theia-workspace>

</preamble>
<file_content file: gopherbot-main/.gitpod/clu.theia-workspace>
{
   "folders": [
      {
         "path": "file:///workspace/gopherbot"
      },
      {
         "path": "file:///workspace/clu"
      }
   ],
   "settings": {}
}
</file_content file: gopherbot-main/.gitpod/clu.theia-workspace>
<preamble file: gopherbot-main/.gitpod/gitpod.theia-workspace>

</preamble>
<file_content file: gopherbot-main/.gitpod/gitpod.theia-workspace>
{
   "folders": [
      {
         "path": "file:///workspace/gopherbot"
      }
   ],
   "settings": {}
}
</file_content file: gopherbot-main/.gitpod/gitpod.theia-workspace>
<preamble file: gopherbot-main/.gitpod/gotools.sh>

</preamble>
<file_content file: gopherbot-main/.gitpod/gotools.sh>
#!/bin/bash
/usr/local/go/bin/go get -u -v \
    github.com/mdempsky/gocode \
    github.com/uudashr/gopkgs/cmd/gopkgs \
    github.com/ramya-rao-a/go-outline \
    github.com/acroca/go-symbols \
    golang.org/x/tools/cmd/guru \
    golang.org/x/tools/cmd/gorename \
    github.com/fatih/gomodifytags \
    github.com/haya14busa/goplay/cmd/goplay \
    github.com/josharian/impl \
    github.com/tylerb/gotype-live \
    github.com/rogpeppe/godef \
    github.com/zmb3/gogetdoc \
    golang.org/x/tools/cmd/goimports \
    golang.org/x/tools/cmd/stringer \
    github.com/sqs/goreturns \
    winterdrache.de/goformat/goformat \
    golang.org/x/lint/golint \
    github.com/cweill/gotests/... \
    github.com/alecthomas/gometalinter \
    honnef.co/go/tools/... \
    github.com/golangci/golangci-lint/cmd/golangci-lint \
    github.com/mgechev/revive \
    github.com/sourcegraph/go-langserver \
    golang.org/x/tools/gopls \
    github.com/go-delve/delve/cmd/dlv \
    github.com/davidrjenni/reftools/cmd/fillstruct \
    github.com/godoctor/godoctor
/usr/local/go/bin/go get -u -v -d github.com/stamblerre/gocode
/usr/local/go/bin/go build -o $GOPATH/bin/gocode-gomod github.com/stamblerre/gocode
</file_content file: gopherbot-main/.gitpod/gotools.sh>
<preamble file: gopherbot-main/.gitpod/setup.sh>

</preamble>
<file_content file: gopherbot-main/.gitpod/setup.sh>
#!/bin/bash -e

# setup.sh - run demo bot or give info for devel

clear

REMOTE=$(cd gopherbot; git remote get-url origin)
REMOTE_PREFIX=${REMOTE%/gopherbot.git}
REMOTE_ORG=${REMOTE_PREFIX##*/}

if [ -n "$1" -o "$REMOTE_ORG" == "lnxjedi" ] # demo
then
    cat <<EOF
############################################################################
Welcome to the Gopherbot Demo. This will run Gopherbot
in terminal connector mode, where you can use the 
autosetup plugin to configure a new robot and store it
in a git repository.
############################################################################

EOF
    exec ./gopherbot/gopherbot
else
cat <<EOF

############################################################################
Fetch your development robot with:
$ ./gopherbot/fetch-robot.sh <botname>

EOF
fi
</file_content file: gopherbot-main/.gitpod/setup.sh>
<preamble file: gopherbot-main/.gopherci/pipeline.sh>

</preamble>
<file_content file: gopherbot-main/.gopherci/pipeline.sh>
#!/bin/bash

# pipeline.sh - trusted pipeline script for gopherci for Gopherbot

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ -n "$NOTIFY_USER" ]
then
    FailTask notify $NOTIFY_USER "Gopherbot build failed"
fi

FailTask email-log parsley@linuxjedi.org

CTAG="latest"

if [[ $GOPHERCI_BRANCH == release-* ]]
then
    if [ "$GOPHER_PIPELINE_TYPE" != "plugCommand" ]
    then
        Say "Skipping build of $GOPHER_REPOSITORY, ref '$GOPHERCI_BRANCH' (requires manual build)"
        exit 0
    fi
    CTAG="$GOPHERCI_BRANCH"
    SetParameter BUILDREF "$GOPHERCI_BRANCH"
fi

if [[ $GOPHERCI_BRANCH == v*.* ]]
then
    if [ "$GOPHER_PIPELINE_TYPE" != "plugCommand" ]
    then
        Say "Skipping build of $GOPHER_REPOSITORY, ref '$GOPHERCI_BRANCH' (requires manual build)"
        exit 0
    fi
    CTAG="$GOPHERCI_BRANCH"
    SetParameter BUILDREF "$GOPHERCI_BRANCH"
fi

# SetParameter ~= "export" for the pipeline.
SetParameter CTAG "$CTAG"

# Run tests
AddTask exec go test -v --tags 'test integration netgo osusergo static_build' -mod vendor -cover -race -coverprofile coverage.out -coverpkg ./... ./test

# Do a full build
AddTask exec make

# See who got this message and act accordingly
BOT=$(GetBotAttribute name)
if [ "$BOT" != "data" ]
then
    # if it's not Data, stop the pipeline here
    if [ -n "$NOTIFY_USER" ]
    then
        AddTask notify $NOTIFY_USER "Builds and tests succeeded for Gopherbot"
    else
        Say "NOTIFY_USER not set"
    fi
    exit 0
fi

# Set for building containers in containers
SetParameter BUILDAH_ISOLATION chroot

# Log in to container registries
AddTask buildah-login quay.io parsley42 QUAY
AddTask buildah-login registry.in.linuxjedi.org linux LINUXJEDI

# Build the containers, tag for developer registry
# Note that the make target pulls the FROM images first
AddTask exec make containers

# Push containers out
AddTask exec buildah push quay.io/lnxjedi/gopherbot:$CTAG
AddTask exec buildah push quay.io/lnxjedi/gopherbot-theia:$CTAG
AddTask exec buildah push quay.io/lnxjedi/gopherbot-dev:$CTAG
# As good a place as any for now? Need to remove later in favor of weekly job.
AddTask exec buildah rmi -p

# Notify of success
if [ -n "$NOTIFY_USER" ]
then
    AddTask notify $NOTIFY_USER "Successfully built and pushed gopherbot:latest"
fi
</file_content file: gopherbot-main/.gopherci/pipeline.sh>
<preamble file: gopherbot-main/AUTHORS.txt>

</preamble>
<file_content file: gopherbot-main/AUTHORS.txt>
AUTHORS
=======

David L. Parsley - <parsley@linuxjedi.org> / <dlp7y@virginia.edu>
</file_content file: gopherbot-main/AUTHORS.txt>
<preamble file: gopherbot-main/CHANGELOG.md>

</preamble>
<file_content file: gopherbot-main/CHANGELOG.md>
# v2.11.1 - Improved Slack "raw" Message Splitting
On occasion the AI plugin could generate very long Slack messages containing one or more code blocks. The old message splitting algorithm just blindly split up the message and sent chunks, breaking on newlines when possible. The new algorithm now keeps track of code blocks, and closes and re-opens them between messages.

# v2.11.0 - Hidden Commands and Support for Slack Slash Commands
When Gopherbot's Slack connector migrated from RTM to socketmode events, I added bare minimum support for "slash commands" - if you set up your robot with e.g. "/clu" for a slash command, you could type "/clu ping" and it would dutifully respond "@parsley PONG" in the channel - but nobody would have seen the original ping command, since slash commands are hidden. Version 2.11.0 adds a more useful functionality for slash commands called "hidden commands", meaning the user can message the robot and receive a reply that is hidden from other users. The interfaces are defined in a generic way so that future connectors could also support this functionality in a connector-specific way, but for now I will only document how it's implemented in Slack.

## AllowedHiddenCommands - potentially breaking change
Where before every plugin command would respond to e.g. "/clu do something" the same as "clu, do something", now each plugin must define a list of commands that are allowed to be hidden with an `AllowedHiddenCommands:` array in the plugin yaml configuration. Since Gopherbot allows an adminstrator to pin certain commands to certain channels, and visibility of commands is one layer of security, this feature returns some control back to the adminstrator.

## New GOPHER_HIDDEN_COMMAND Environment Variable
When a plugin runs from a hidden command, the engine will set `GOPHER_HIDDEN_COMMAND=true`; otherwise it's unset.

## Slack Implementation with Ephemeral Messages
The nicest feature of this new functionality is how it's implemented in Slack. Simply, when a command is issued as a slash command, all replies are sent as an "ephemeral message" to the user:
* Slack tags these messages as "Only visible to you"
* They are not kept in team history
* They do not persist between sessions / reloads
That is all to say, Slack hidden messages behave much like many other Slack integrations you've used, and don't clutter up channels with output that likely isn't useful to others.

## Updates to built-in help
Absolutely the most useful application of this new feature is the update to the built-in help system:
* Built-in help commands are listed as `AllowedHiddenCommands` by default, so in any given channel a user can type e.g. `/clu help` and receive contextual help for the current channel in the same pane, without spamming everybody else in the channel, or creating a thread.
* Expansion of helplines now accepts a prefix before "(bot)", so you can now add a helptext line of the form "/(bot) do something - do anything at all", and it will render as e.g. "`/Clu do something` - do anything at all".
* Protocol connectors now define a `DefaultHelp()` method that can return a non-zero array of help lines that override the engine defaults when the help command is issued without a keyword. Thus, a Slack robot will add e.g. "`/Clu help <keyword>` - get help for the provided \<keyword\>".

## (Development Notes) Additional Changes to the Core
To support this functionality, the message sending methods were updated. Before, whenever a connector had an incoming message, it was packaged up in to a `*robot.ConnectorMessage`, with a `MessageObject` field containing a protocol-specific `interface{}` corresponding to an object received by the protocol (e.g. `*slack.Event`), and a similar `Client interface{}` corresponding to a client object for the protocol (e.g. `*slack.Client`). Now this same object is passed back as an argument in the message sending functions, allowing the connector to make context-aware decisions on how to handle message sends. In the case of Slack, it's used to determine that an ephemeral message should be sent to the user. At the same time, the `worker` struct was cleaned up, removing several fields that were merely copied from the `ConnectorMessage`.

# v2.10.2 - Helptext Formatting Update
Now that robots can tell the difference between being addressed using it's name or it's alias, the help system has been updated:
* The old "(bot), do something" format can be replaced with "(alias) do something", so e.g. you'll get "Floyd, do something" in the first case, or ";do something" in the second case; this lets the robot's administrator provide help in a format the users are most likely to use
* Connectors now have a `FormatHelp` method that takes and returns a string, and allows the protocol to further modify the help line to be more visually appealing for the specific protocol; in Slack, for instance, the command portion of the help line is enclosed in single-backticks, so you get e.g. "`;build <package>` - start a new build of \<package\>"

# v2.10.1 - ChannelOnly matching
`CommandMatchers` and `MessageMatchers` can now set a boolean flag, `ChannelOnly`, to only match messages in a main channel or DM (not a thread).

# v2.10.0 - Command Mode, thread Subscribe API, short-term memory backing store
* Once again for the AI plugin, it's useful to differentiate between robot commands using the robot's single-character alias vs the robot's regular name. The single-character alias is mostly understood by users as a "command prefix" for the robot, and used with chatops commands for e.g. deploying software. Using the robot's name, however, could indicate the user intends the message to be delivered to the AI. Starting in this version, external plugins will see a new `GOPHER_CMDMODE` environment variable, which will be "alias", "name", or "direct", and can be used to modify behavior.
* This seems like an obvious API in retrospect - a plugin can now Subscribe to (and Unsubscribe from) the thread of the message that started it. This allows plugins to deal with conversations in a fairly natural fashion - starting a conversation thread and subscribing to it, and keeping state in short-term memory (which for threads is quite long).
* Thread-short-term memories and thread subscriptions both time out after one week; given that robots occasionally need to be redeployed, these memories are now backed by the robot's brain, to prevent amnesia after a rebuild. Short-term memories still expire, making them easier to use in most cases than the long-term memory API.

# v2.9.2 - Pipeline / Namespace Bugfix
It bears repeating here (not actually sure it's documented elsewhere) - both Jobs and Plugins can create pipelines, but simple tasks only inherit the namespace in a Job pipeline, where simple tasks are intended to have access to Job-specific memories and secrets. Plugin-namespaced memories and secrets should be restricted to the plugin only, largely because plugins also serve as authorizers (establishing group membership) and elevators (which normally require some form of 2fa).

# v2.9.1 - Slack Updates, Bugfixes and Security Enhancement
For the first time in years I'm running a robot that does NOT have `IgnoreUnlistedUsers: true` - and for the record, if you're using Gopherbot for team chat DevOps, I strongly recommend you make the effort. In any event, moving my personal robot Floyd to my local community Slack team has revealed some issues in the Slack connector with the regex that matches a username mention. In addition to widening that regex appropriately, I've updated the Slack library for a bugfix in the socketmode connector, and improved the security in user loading, adding a guardrail to prevent Slack-provided usernames from conflicting with users listed in the UserRoster.

# v2.9.0 - Ephemeral Memories Update
This is a large-ish change in the API and operation of ephemeral memories, once again motivated by the AI plugin and partly enabled by threaded conversation support:
* The old notion of "short term memories" is now more generically "ephemeral memories" - memories stored in RAM that are forgotten after a time
* Ephemeral memories for a channel are shorter-lived, about 7 minutes, reflecting that channel topics and contexts tend to change relatively quickly
* Ephemeral memories for a thread are longer-lived, almost two days, reflecting that threads tend to stay on a single topic and may last days
* Remember, RememberThread and Recall now take an optional third argument, shared; when a memory is shared, it is the same for all users in the channel/thread - but NOTE, there is no record locking for shared (or non-shared, for that matter) memories!
   * To keep multiple plugin runs from stomping on each other, you can use the Exclusive API
   * The Exclusive API method, formerly exclusive to Jobs and job pipelines, now works with Plugins, too

# v2.8.2 - Allow plugins to handle "robot?"
Very minor enhancement; if your robot's name was floyd, and the user typed "floyd?", the only way to handle it was to use a message matcher that hard-coded the robot's name. Now you can define a command with the regex '^\?$' to catch this case and handle it.  Added for - you guessed it - the AI plugin.

# v2.8.0, 2.8.1 - POTENTIALLY BREAKING ambient message matching update, direct catch-all update
In most cases, if someone directs a message to the robot (issues a "command") in a channel, the message should go to the CatchAll if no command matches. Up to now, the default behavior was to match against `MessageMatchers`, even in the case of a command. Starting with v2.8.0, commands will no longer match against message matchers unless `AmbientMatchCommand` is set `true`. For most configurations this shouldn't be an issue, but this could break some configurations. Note that direct messages to the robot are always commands, and will need `AmbientMatchCommand` set to match against a plugin's `MessageMatchers`; for the normal use case of `MessageMatchers` (e.g. mentioning Chuck Norris), this probably isn't what you want.

If you want a plugin to override the help system matching direct messages that don't match a command, you can create an alternate configuration for the plugin with `CatchAll: true` and `DirectOnly: true`, which will mark it as a "specific" catch-all.

# v2.7.4 - Longer Memories
Short-term memories really only came in to serious use with the OpenAI plugin, where 7 minutes just wasn't enough for expectations. Now Gopherbot robots have a 14-hour short-term memory.

# v2.7.3 - Improved ruby/python3 dependency support
To make it sane to use a `Gemfile`, we now set `GEM_HOME=${HOME}/.local`, which causes bundler to install ruby gems in the same location as python3. To install ruby and python dependencies with the included `install-libs` job, create `Gemfile` and/or `requirements.txt` to the root of your robot's repository, and add this `ScheduledJob` to your `robot.yaml`:
```yaml
- Name: install-libs
  Schedule: "@init"
```

# v2.7.2 - Enhanced Catch-All Plugin Matching
Since the earliest versions, **Gopherbot** has had a `CatchAll` setting for plugins, allowing special plugins to be run when the robot is being spoken to (via direct message, or when mentioned by name) but no command matched. The only default plugin so configured is the built-in `help` plugin, which gives the familiar "No command matched ..." responses.

Previously the behavior of the `CatchAll` setting for a plugin wasn't very useful; if you set it to `true` for a plugin, and didn't disable it for the built-in `help` plugin, multiple plugins would match and result in an error log message with neither being run. Starting with v2.7.2, if you set `CatchAll: true` and your plugin is either marked `DirectOnly`, or the current channel is in the list of channels for the plugin, it will match as a *specific* catch-all. So long as only one specific catch-all matches, your plugin will be called, and only fall-back to the built-in `help` plugin if no specific catch-all matches. In detail:
* If a single *specific* catch-all matches, it will be called.
* If more than 1 *specific* catch-all matches, an error will be logged and nothing will be called.
* If no *specific* catch-all matched and only a single fallback catch-all matched, it will be called.
* If multiple fallback catch-alls match, an error will be logged and nothing will be called.

The only other small change is that previously the catch-all was called with the space-reduced version of the message, and going forward it will be called with the full message, which may include e.g. newlines.

This new behavior allows for:
* Channel-specific help messages
* Channel-specific and/or DM default plugins; the impetus for this enhancement was to allow direct messages to a robot to be routed to the AI plugin if no other command matched

# v2.7.1 - More regex updates, new global ignore command
* In another potential but unlikely breaking change, command matching now sets the `s` flag by default, which IMHO gives the expected result for e.g. `(?i:echo (.*))` - for a robot command, `.*` would match everything to the end of the message.
* Additionally, the message space collapsing now includes all whitespace, including newlines. Thus, for somewhat standard commands with simple string arguments, the command will still match even if the user breaks up a long command with a newline.
* Since I've been deploying the OpenAI chat plugin in an #ai channel, where EVERY message matches the plugin, I've added a simple global `i(gnore) <anything>` command that allows you to speak to other people in a channel without triggering a command or error.

# v2.7.0 - Support for OpenAI Chat Plugin, ambient message matching fixes

With the massive ChatGPT craze, and a website that was frequently unavailable, I just *had* to write a AI plugin for Gopherbot. Unfortunately, (or fortunately?) using this plugin revealed a whole host of niggly and corner-case bugs that have mostly been fixed in v2.6.4.1-5. There was one final fix, however, that could possibly break existing plugins...

## Change to `MessageMatchers` matching
Ambient `MessageMatchers` were previously matching against the original message with the robot name or alias stripped away, so:
* if your robot's alias was, for instance `;`
* and the user typed the command `;some garbage`
* and your plugin had a `MessageMatcher` of e.g. `^([^;].*)`
* ... the matcher would be checked against `some garbage`, and match even when it shouldn't

This has now been fixed, but since `MessageMatchers` now match differently (and the version string was getting kind of nutty), I went ahead and bumped all the way to v2.7.0.

## Multi-line match and space fixes
In the early early days of Gopherbot, users would frequently copy and paste in commands, and many times there would be multiple spaces between words - `something  like   this`. This wouldn't match the regex `/something like this/`, and meant regexes would need to be littered with `/s+`, which was crazy ugly. In a stroke of cleverness, I sanitized input by replacing all instances of multiple spaces with a single space, thus fixing that issue but good. Until, that is, I started caring about preserving those spaces when sending messages to plugins (think sending formatted Python code blocks to ChatGPT). To preserve spaces AND preserve space-collapsed matching, the engine first tries matching against the full message text, and failing that the space-collapsed version. If either matches, that text is passed to the plugin.

Additionally, the **terminal** connector was updated with a `GenerateNewlines` boolean option. When this option is set, you can type a command like: `;Complete this sequence:\n5,4,3,2`, and a message with a newline will be sent to the engine. Note, however, that `(.*)` won't always match the whole thing as you might expect - you can add the `s` flag to your regexp definition (e.g. `(?is:<something>)`) or use `([\s\S]*)` to match *everything*, including the newlines (CHANGED, see v2.7.1 above).

## The OpenAI Chat Plugin
If you'd like to try the `ai.rb` plugin, which uses the OpenAI *completions* api, you'll have to check out [**Floyd**](https://github.com/parsley42/floyd-gopherbot) (my oldest robot).

# v2.6.4(.1) - Add RememberThread, RememberContextThread; Message IDs, env vars
* To support development of a new OpenAI Chat plugin, these functions were needed to allow a command in a channel to create a short-term memory for a new thread created by the robot.
* Added a `Threaded` method for all libraries (except BASH, where you can just set `GOPHER_THREADED_MESSAGE`); `bot.Threaded()` will return a bot object that always speaks and acts in the message thread.
* Added the `GOPHER_MESSAGE_ID` and `GOPHER_START_MESSAGE_ID` environment variables with opaque message ids; mainly only useful for generating Slack links to a message in a thread, wheeee
* Added `GOPHER_CHANNEL_ID`, `GOPHER_USER_ID`, `GOPHER_START_CHANNEL_ID` env vars (.1)

# v2.6.3 - IDE, Development and Packaging Updates
* The dev container now defines GOPHER_IDE=true, which activates IDE mode:
  * This will always cause `gopherbot` to change directory to `$HOME` on startup, to prevent a common UX issue where admins start the robot in, say, the `custom/` directory; this behavior can only be overridden by explicity unsetting the env var in the shell: `$ unset GOPHER_IDE`
  * When `GOPHER_CUSTOM_REPOSITORY` is set in the initial container environment, `gopherbot` will set `GOPHER_PROTOCOL=terminal` and `GOPHER_BRAIN=mem` - sensible defaults for the IDE / development environment; this can be more easily overridden by passing the `-o` flag to `gopherbot` if you want to run your robot in production mode in the development environment: `$ gopherbot -o`
* The dev and min containers now include the `ruby-dev` and `python-dev` packages, allowing gems/packages that need to be compiled to be installed
* The ruby `debug` gem and python `rpdb` packages are installed in the dev container, allowing developers to set breakpoints in their robot scripts and attach a command-line debugger to the running script:
  * For Ruby, you can set a breakpoint by inserting `require debug/open` in the code, then running `$ rdbg -A` to attach when you see it hit the breakpoint in the output log
  * Python should offer similar functionality using `import rpdb` and `rpdb.set_trace()` to set the breakpoint in your code, then using `telnet` to attach
  * Keep in mind that each time a Ruby or Python extension is called, a new interpreter is spun up; thus the normal workflow is just inserting a breakpoint in the code and e.g. telling your robot to "do that again" - e.g. `> bot, trigger my buggy code`
* I've introduced experimental support for `GOPHER_ENVIRONMENT`, which can be used to have a production and development set of encrypted credentials, to allow developers to work with the robot without having full access to production credentials. If you do nothing at all, your script extensions will simply see two new environment variables:
  * `GOPHER_ENVIRONMENT`, which defaults to "production"
  * `GOPHER_BRAIN`, which is set to the name of the brain being used

To try out working with a separate environment:
  * Start an IDE with no robot configured (a pristine `bot.env`)
  * Open a terminal window in `/home/bot` and generate a new encryption key: `$ export GOPHER_ENCRYPTION_KEY=$(openssl rand -base64 24); echo $GOPHER_ENCRYPTION_KEY`
  * Start up the default robot, and as soon as you get the terminal connector prompt press `<ctrl-d>`
  * Copy the contents of `custom/binary-encrypted-key` to your production robot as `custom/binary-encrypted-key.<env>`, e.g. `custom/binary-encrypted-key.dev`, and push the new file
  * Copy your robot's profile to a new version with e.g. `GOPHER_ENVIRONMENT=dev`, and `GOPHER_ENCRYPTION_KEY=<value from above>`
  * When you start your robot from the new profile, it will use the new `GOPHER_ENCRYPTION_KEY` to decrypt e.g. `binary-encrypted-key.dev`, which will then be used for decrypting any secrets found in your robot's configuration files
  * It's up to you to add any needed `if` and `.Include` logic in your configuration files (testing the `GOPHER_ENVIRONMENT` environment variable) to make sure your robot can start with the alternate environment

# v2.6.2 - Boogs
* Fixed an old bug where the robot might not answer to being @mentioned in Slack. To be sure @mentions work, your robot needs to list itself in the Slack user map, with the same name as in `robot.yaml`.
* Fixed a lingering thread bug in the bash library
* Updated robot.skel and autosetup/addadmin plugins to automatically configure the bot correctly for recognizing a @mention; to update your robot, use the robot's built-in `info` command to get the ID, then add a stanza to your the UserRoster of your `slack.yaml`:
```yaml
  - UserName: bishop
    UserID: U0123456789
    BotUser: true
```
* Batch of improvements to the `cbot.sh` script for local dockerized development

# v2.6.1 - Robots can now talk to themselves
* When Gopherbot was first created, it didn't make much sense for Gopherbot robots to process messages that originated from themselves. Now that messages carry a "ThreadID" ("GOPHER_THREAD_ID"), a clever roboticist can take advantage of the robot's ability to hear itself to e.g. associate state with a thread. To enable this, set `HearSelf: true` in your Slack ProcotolConfig.

# v2.6.0 - New IDE and Threaded Conversations Support
* The documentation is just starting to catch up with the new **Gopherbot IDE** - a giant (>2G) container with everything you need to do development either on your robot, or Gopherbot itself.
* Gopherbot robots can now hear an opaque "ThreadID" (env var: "GOPHER_THREAD_ID") and "ThreadedMessage" (env var: "GOPHER_THREADED_MESSAGE", "true" when the message was issued in a thread). "Say" and "Reply" will post to the thread if the robot was spoken to there. Additionally, the new "SayThread", "ReplyThread" and "PromptThreadForReply" methods will create a new thread from a message in the channel, allowing you to keep noisy responses out of the main channel; the "help" command does this now.

# v2.5.2 - Socket mode stability and command standardization
* After a problem with a robot becoming unresponsive, an [issue](https://github.com/slack-go/slack/issues/1093) with the Slack Go library was found that could delay reconnecting in the event of a timeout on the websocket. This release incorporates a [fix](https://github.com/slack-go/slack/pull/1094).
*  To make job-related commands easier to remember, `<verb>-<noun>` synonyms were added for job related commands, e.g. `list-jobs`, `pause-job`, `resume-job`, etc.

# v2.5.1 - Bugfix Slack Plugin
This release just fixes a crash in the "slack id @user" plugin. It adds a type switch to differentiate the message objects returned by Socket Mode vs. RTM.

# v2.5.0 - Add socket mode support
This has been hanging over my head for a long while, so very happy to announce that starting with Gopherbot v2.5.0, robots can be configured with an app/bot token pair to connect via socket mode. Note that eventually Slack is expected to remove support for the old RTM protocol; as it is, creating new Gopherbot robots means ignoring some scary messages about using old/legacy/"classic" app support.

## Upgrading Existing Robots
1. You'll need to obtain a new set of credentials; the steps are fully documented in the [online manual](http://localhost:8888/botsetup/slacksock.html).
2. Use `gopherbot encrypt "..."` to create encrypted versions of these tokens (optionally, only the portion after the `xapp-` / `xoxb-`, although AES is supposed to be very resistant to partially-known plaintext attacks).
3. Edit your `conf/slack.yaml` and add lines for `AppToken` and `BotToken` under the `SlackToken` line; use the `decrypt` function to decrypt the encrypted values you created.

Now you can start your robot with it's new credentials. If all goes well, you can remove the `SlackToken`.

> NOTE: As far as Slack is concerned, this is a new app/user - so if you have a DM open with the old app, you should go ahead and close it.

> NOTE: The new version will still accept the old `SlackToken` to make legacy RTM connections.

# v2.4.9 - Run init jobs before other external scripts
This update allows plugins to take advantage of ruby gems and/or python modules installed from an init job. Prior to this update, the robot would need to be manually restarted, or plugins would have to be specially edited to require/import later in the script (ugh).

# v2.4.8 - Fix Slack escaping
The Slack "Raw" format was incorrectly escaping angle brackets ("<>"), disabling e.g. nice hyperlinks with text. This release corrects this issue, and also restores escaping of '*', '_', ':', '@', '#' and '`' for the "Variable" format - allowing these characters to "appear" unadulterated in message. I quote "appear" because there are invisible characters inserted - so copy/paste will get these. If the text is truly meant to be copied and pasted, use the "Fixed" format instead.

# v2.4.7 - Improve developer workflow
This release adds a new admin `change-branch <branch>` command to support more normal development workflows. Significant updates can be made to a robot on a development branch and tested / fixed before merging. In the event something breaks badly, `change-branch main` can quickly restore the robot to a working condition.

# v2.4.6 - Improve custom lib support
Bugfix release - fixes an issue with initial loading of plugins that require/import a library from `custom/lib`; this path wasn't included during plugin initial config loading, causing errors that resulted in plugins being disabled.

# v2.4.5 - Let the robot see angle brackets
This version always translates e.g. `&lt;` to `<`, since slack sends the former instead of the latter when the user in fact typed the latter. This allows the robot to 'see' angle brackets now, but unfortunately prevents the robot from seeing the string `&lt;`. Brackets seem more useful. (Same goes for `>`, naturally)

# v2.4.4 - File history fix, Channel Logging
(Possibly) **BREAKING CHANGE**: The `LoadableModules` configuration stanza is removed in this version. All releases since 2.1.0 have been fully static builds, with loadable modules disabled. Starting with this version, having `LoadableModules` defined will be a fatal error.

This update contains a fairly major fix - at some point the default file history provider was disabled, causing robots to fall back to memory-based history, which is of limited use. I didn't bother to bisect since the fix was pretty obvious and the culprit was definitely me (David).

The other big-ish change is the addition of channel logging. Using the `log channel (name)` command, administrators can log the raw strings from a channel to a file. This should help in a variety of situations where the bot administrator needs to see "what the robot sees" in a channel - for matching users, writing regular expressions, etc. Use `help debug` for command syntax.

# v2.4.3 - DynamoDB Brain support, more HOME updates
This update primary deals with correct operation for robots with non-file brains. It's noteworthy that DynamoDB is the best brain.
* During bootstrapping, the robot was always trying to restore a file-backed (git) brain; now the restore job handles non-file brains gracefully
* During configuration loading, `$HOME` was not being set, causing certain plugins to always be disabled when gems weren't found

# v2.4.2 - Improved IDE UX
This release makes a number of changes to the user experience for the Gopherbot IDE. Notably, it now copies the user's `$HOME/.gitconfig` to the container, so all user git settings apply.

# v2.4.1 - @init jobs
> **NOTE: Potentially breaking change**

This release adds a special '@init' value for scheduled jobs, allowing certain jobs to be run during start-up and reload. The use case for this was to allow decrypting an encrypted `.kube/config` file, but this could also be used for installing python packages and ruby gems.

The **potentially breaking change** is that `$HOME` is now fixed to `$GOPHER_HOME`, the main working directory for the robot. It doesn't make a lot of sense for this to be anything different, or to require this to be set elsewhere (e.g. in the `Dockerfile`).

# v2.4.0 - Gopherbot IDE
This is the first release of a mostly-working Gopherbot IDE, based on [Theia](https://theia-ide.org/). In short:
* Use the `gb-dev-profile` script to generate an IDE profile from a robot's `.env` file - this packages an ssh key and other **git** goodness into a new env file
* Use `gb-start-dev <profile>` to start a local docker container with the profile
* Once the robot starts, tell it to `start-ide` (or `start-theia`), then connect to `http://localhost:3000`

# v2.3.0 - ParameterSets
This release adds `ParameterSets`. Since the `NameSpace` of a task also determines access to long-term memories, tasks can only have a single namespace. ParameterSets are identical in form to NameSpaces, but a given job/task/plugin can list multiple ParameterSets. This allows more flexible sharing of secrets between jobs - especially for secrets like GITHUB_TOKENs, that don't really map well to a namespace. For examples of `ParameterSets` in action, see [Clu](https://github.com/parsley42/clu-gopherbot).

# v2.2.0
* Updated `go.mod` and import paths for (hopefully) 'proper' go module support; since **Gopherbot** is far more an application than a library, this should only matter for indexes like [pkg.go.dev](https://pkg.go.dev)

# v2.1.5 - TOTP Update, Improved help
* Stronger TOTP implementation; generate user codes with the CLI and add encrypted secrets to `conf/plugins/builtin-totp.yaml`
* Make standard "robot, help" contextual (less noisy); "robot, help-all" gives the formerly verbose output
* Export `PYTHONPATH` and `RUBYLIB`, removed ugly env-var references from python & ruby plugins
* Simple tasks now inherit their memory namespace from the pipeline they're added to

# v2.1.4 - Ephemeral Memories
* Allow for ephemeral memories with the git brain; any memories with leading underscores will be ignored by the '.gitignore', allowing developers to prevent frequent git commits for fast changing memories. Also made the .gitignore algorithm more robust.

# v2.1.3
* More container build updates - make all containers more useful for dev env

# v2.1.2
* Update container builds, using GitHub actions for releases and containers

# v2.1.1
* Compile in the dynamodb brain, famously used by Floyd
* Update aws and other deps

# v2.1.0 - Remove Go Modules
Changes since v2.0.2:

The major update for 2.1.0+ is the temporary and possibly permanent removal of modular builds. Support for loadable Go modules was *cool*, but it meant that I couldn't build a single distribution archive installable on all recent Linux distributions due to modular builds using the gcc toolchain linker. Starting with 2.1.0, **Gopherbot** will once again create installable build artifacts.

The other major change is a greater focus on **Slack** as the primary protocol. While the **terminal** connector will continue to be the best way to develop Gopherbot jobs and plugins, the primary build artifacts will be largely Slack-specific.

Other updates/fixes:
* Several fixes to the `autosetup` installer for additional robustness.
</file_content file: gopherbot-main/CHANGELOG.md>
<preamble file: gopherbot-main/LICENSE>

</preamble>
<file_content file: gopherbot-main/LICENSE>
The MIT License (MIT)

Copyright (c) 2016 The Rector and Visitors of the University of Virginia

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file_content file: gopherbot-main/LICENSE>
<preamble file: gopherbot-main/Makefile>

</preamble>
<file_content file: gopherbot-main/Makefile>
# Makefile - just builds the binary, for dev mainly

.PHONY: clean test generate testbot static dist containers debug

commit := -X main.Commit=$(shell git rev-parse --short HEAD)
version := $(shell ./get-version.sh)

TAR_ARCHIVE = gopherbot-linux-amd64.tar.gz
ZIP_ARCHIVE = gopherbot-linux-amd64.zip

GOOS ?= linux
CGO ?= 0
CTAG ?= latest

ifdef TEST
TESTARGS = -run ${TEST}
endif

static: gopherbot

gopherbot: main*.go bot/* brains/*/* connectors/*/* goplugins/*/* history/*/*
	CGO_ENABLED=${CGO} GOOS=${GOOS} GOARCH=amd64 go build -mod readonly -ldflags "-s -w $(commit) $(version)" -tags "netgo osusergo static_build" -o gopherbot main.go main_static.go

debug:
	CGO_ENABLED=${CGO} GOOS=${GOOS} GOARCH=amd64 go build -mod readonly -ldflags "$(commit) $(version)" -tags "netgo osusergo static_build" -o gopherbot

clean:
	rm -f gopherbot $(TAR_ARCHIVE) $(ZIP_ARCHIVE)

$(TAR_ARCHIVE): static
	./mkdist.sh

dist: $(TAR_ARCHIVE)

# Run test suite without coverage (see .gopherci/pipeline.sh)
test:
	go test ${TESTARGS} -v --tags 'test integration netgo osusergo static_build' -mod readonly -race ./test

# Generate Stringer methods
generate:
	go generate -v --tags 'test integration netgo osusergo static_build' -mod readonly ./bot/
	go generate -v --tags 'test integration netgo osusergo static_build' -mod readonly ./robot/

# Terminal robot that emits events gathered, for developing integration tests
testbot:
	CGO_ENABLED=0 GOOS=${GOOS} GOARCH=amd64 go build -mod readonly -tags 'netgo osusergo static_build test' -o gopherbot
</file_content file: gopherbot-main/Makefile>
<preamble file: gopherbot-main/README.md>

</preamble>
<file_content file: gopherbot-main/README.md>
# Gopherbot DevOps Chatbot

Slack[^connectors] DevOps / ChatOps general purpose IT robot framework for Linux, supporting extensions in Bash, Python, Ruby, and Go[^go].

[^connectors]: Gopherbot a modular interface for writing other protocol connectors in Go; currently only Slack and the Terminal connector are supported
[^go]: Go extensions are the hardest to write, requiring custom forks/builds; Gopherbot is heavily optimized for extension with scripting

Slogans under consideration:
* **The Co-worker that Never Sleeps**
* **The DevOps Swiss-Army Chainsaw**

## What does Gopherbot *do*?
**Gopherbot** runs as a process or container in your infrastructure and connects to your team chat. From there it can respond to CLI-like commands written in Bash, Ruby or Python, and perform any number of functions to provision resources, run reports and scheduled jobs, deploy software or interact with CI/CD - just about any functionality a DevOps engineer might want to provide in team chat. You can find a lot more information in the [introduction](https://lnxjedi.github.io/gopherbot/Introduction.html) of the online manual.

## Major Features
* Self-deploying and updating with **GitOps**-style management
* Threaded conversation support and thread-awareness
* Powerful pipeline-oriented engine for creating and combining reusable components in multiple scripting languages
* Flexible support for encrypted secrets
* Wide variety of security features including built-in Google Authenticator TOTP
* Full-featured **IDE** and terminal connector for developing extensions
* Highly configurable with Go-templated YAML

## Software Overview
**Gopherbot** uses a model similar to [Ansible](https://ansible.com), distributing a core robot with an array of built-in reusable components. Individual robots are configured and stored in a **git** repository that is cloned when you bootstrap your robot in your infrastructure; several example robot repositories are given below.

Running a **Gopherbot** robot essentially means running the core robot (on a VM or in a container) with a handful of environment variables that tell the core robot how to clone and run *your* individual robot.

## Documentation
The latest documentation can always be found at the GitHub-hosted [online manual](https://lnxjedi.github.io/gopherbot); the documentation source is in a [separate repository](https://github.com/lnxjedi/gopherbot-doc). Documentation automatically generated from the Go sources can be found at [pkg.go.dev](https://pkg.go.dev/github.com/lnxjedi/gopherbot/v2).

The manual is still very incomplete; however, sometimes the best documentation is example code. To that end, the most powerful and complete robot I have is [Mr. Data](https://github.com/parsley42/data-gopherbot) (now retired) - the robot that ran my home Kubernetes cluster when I still had time for such things. [Clu](https://github.com/parsley42/clu-gopherbot) is the development robot used for development and writing documentation. Though **Clu** doesn't do any useful work, he has examples of most facets of **Gopherbot** functionality. [Floyd](https://github.com/parsley42/floyd-gopherbot) (a utility robot I share with my wife) is the oldest and longest-running robot instance - occasionally he does useful work, but mostly he just makes dinner meal suggestions.

## Release Status
Version 2 has been stable for me for over a year, and has finally been released. I've accepted that a fully up-to-date manual will lag significantly, but that is currently where the most work is being done.

With the recent (2021) addition of `ParameterSets`, a container-based **IDE** and threaded conversation support (2022), there are no major updates in functionality currently planned.

## Previewing
If you have [Docker](https://www.docker.com/) available, you can kick the tires on the default robot running the **terminal** connector:
```
$ docker run -it --rm ghcr.io/lnxjedi/gopherbot
...
Terminal connector running; Type '|c?' to list channels, '|u?' to list users
...
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration was
detected, you're connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try
'gopherbot --help'; otherwise feel free to play around with the default robot - you
can start by typing 'help'. If you'd like to start configuring a new robot, type:
';setup slack'.
c:general/u:alice -> help
...
```

For a more thorough preview of Gopherbot in the **IDE**, see the [preview](https://lnxjedi.github.io/gopherbot/botdev/IDE.html#previewing-gopherbot) section in the online manual.

## Downloading
You can download the latest release build from the [release page](https://github.com/lnxjedi/gopherbot/releases/latest). Up-to-date container builds can be found in the [GitHub Container Registry](hhttps://github.com/orgs/lnxjedi/packages?repo_name=gopherbot).

### Gopherbot Container Variants
**Gopherbot** CI/CD pipelines create two container variants:
* [gopherbot](https://github.com/lnxjedi/gopherbot/pkgs/container/gopherbot) - `ghcr.io/lnxjedi/gopherbot`
  * `gopherbot` is a fairly minimal gopherbot container for running a production containerized robot
* [gopherbot-dev](https://github.com/lnxjedi/gopherbot/pkgs/container/gopherbot-dev) - `ghcr.io/lnxjedi/gopherbot-dev`
  * `gopherbot-dev` uses [OpenVSCode Server](https://github.com/gitpod-io/openvscode-server) for the entrypoint, and is intended for use in setting up and developing extensions for your robots[^devcontainer]

[^devcontainer]: Note that the development container always contains the most recent code in `/opt/gopherbot` - you may want to e.g. `cd /opt/gopherbot; git checkout v2.6.2.1; make`

## Building from Source
Building from source is as straight-forward as `make dist` with the `Makefile`, as long as the build system has all the requirements.

**Requirements:**
* A recent (1.18+) version of Go
* Standard build utilities; make, tar, gzip

**Steps:**
1. Clone this repository
1. Optionally check out a release version - `git checkout v2.6.2.1`
1. `make dist` in the repository root to create an installable archive, or just `make` to build the binaries
1. Follow the [manual installation instructions](https://lnxjedi.github.io/gopherbot/install/ManualInstall.html#installing-the-archive) for installing an archive on your system

---

This example transcript is a little outdated, and doesn't showcase the new job functionality introduced in version 2 - but **Gopherbot** still knows how to tell jokes.

![](https://raw.githubusercontent.com/wiki/lnxjedi/gopherbot/botdemo.gif)

## Deprecated and Unsupported Platforms
The Windows and Darwin (MacOS) ports have both been removed. The best solution for these platforms is to take advantage of the excellent Linux container support to run your robot in a container, perhaps with [Docker Desktop](https://www.docker.com/products/docker-desktop). [WSL](https://docs.microsoft.com/en-us/windows/wsl/install) is also a good solution for Windows.

## Sample Command Plugin with the Ruby API
```ruby
#!/usr/bin/ruby
require 'net/http'
require 'json'

require 'gopherbot_v1'
bot = Robot.new()

defaultConfig = <<'DEFCONFIG'
Help:
- Keywords: [ "weather" ]
  Helptext: [ "(bot), weather in <city(,country) or zip code> - fetch the weather from OpenWeatherMap" ]
CommandMatchers:
- Command: weather
  Regex: '(?i:weather (?:in|for) (.+))'
DEFCONFIG

# NOTE: the required environment variables need to be supplied as
# `Parameters` for the `weather` plugin in custom/conf/robot.yaml.
# The API key should be encrypted.

command = ARGV.shift()

case command
when "configure"
    puts defaultConfig
    exit
when "weather"
    location = ARGV.shift()
    location += ",#{ENV["DEFAULT_COUNTRY"]}" unless location.include?(',')
    uri = URI("http://api.openweathermap.org/data/2.5/weather?q=#{location}&units=#{ENV["TEMP_UNITS"]}&APPID=#{ENV["OWM_APIKEY"]}")
    d = JSON::parse(Net::HTTP.get(uri))
    if d["message"]
        bot.Say("Sorry: \"#{d["message"]}\", maybe try the zip code?")
    else
        w = d["weather"][0]
        t = d["main"]
        bot.Say("The weather in #{d["name"]} is currently \"#{w["description"]}\" and #{t["temp"]} degrees, with a forecast low of #{t["temp_min"]} and high of #{t["temp_max"]}")
    end
end
```

### Contributing
PR's welcome. For development, testing, and collaboration, feel free to shoot me an email for an invite to [the LinuxJedi Slack team](https://linuxjedi.slack.com).
</file_content file: gopherbot-main/README.md>
<preamble file: gopherbot-main/bot/aescrypt.go>

</preamble>
<file_content file: gopherbot-main/bot/aescrypt.go>
package bot

/*
Copyright (c) 2012, AstaXie and The Contributors All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

- Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

- Neither the name of the AstaXie nor the names of its contributors may be used
  to endorse or promote products derived from this software without specific
  prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"io"
)

func encrypt(plaintext []byte, key []byte) ([]byte, error) {
	c, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	return gcm.Seal(nonce, nonce, plaintext, nil), nil
}

func decrypt(ciphertext []byte, key []byte) ([]byte, error) {
	c, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	return gcm.Open(nil, nonce, ciphertext, nil)
}
</file_content file: gopherbot-main/bot/aescrypt.go>
<preamble file: gopherbot-main/bot/allow_hidden.go>

</preamble>
<file_content file: gopherbot-main/bot/allow_hidden.go>
package bot

import "github.com/lnxjedi/gopherbot/robot"

// Check whether a given command is allowed to run as a hidden command. Connectors set HiddenMessage
// to true if the command isn't visible in the team chat. For security/visibility, commands need to be
// explicitly allowed to run "hidden". This occurs, for instance, with a slack slash command.
func (r Robot) checkHiddenCommands(w *worker, t interface{}, command string) (retval robot.TaskRetVal) {
	if !w.Incoming.HiddenMessage {
		return robot.Success
	}
	_, plugin, _ := getTask(t)
	if plugin == nil {
		return robot.Success
	}
	if len(plugin.AllowedHiddenCommands) == 0 {
		return robot.Fail
	}
	for _, i := range plugin.AllowedHiddenCommands {
		if command == i {
			r.Log(robot.Audit, "Hidden command '%s' from plugin '%s' issued by user '%s' in channel '%s'", command, plugin.name, r.User, r.Channel)
			return robot.Success
		}
	}
	return robot.Fail
}
</file_content file: gopherbot-main/bot/allow_hidden.go>
<preamble file: gopherbot-main/bot/authorize.go>

</preamble>
<file_content file: gopherbot-main/bot/authorize.go>
package bot

import "github.com/lnxjedi/gopherbot/robot"

const technicalAuthError = "Sorry, authorization failed due to a problem with the authorization plugin"
const configAuthError = "Sorry, authorization failed due to a configuration error"

// Check for a configured Authorizer and check authorization
func (r Robot) checkAuthorization(w *worker, t interface{}, command string, args ...string) (retval robot.TaskRetVal) {
	task, plugin, _ := getTask(t)
	isPlugin := plugin != nil
	if isPlugin {
		if !(plugin.AuthorizeAllCommands || len(plugin.AuthorizedCommands) > 0) {
			// This plugin requires no authorization
			if task.Authorizer != "" {
				Log(robot.Audit, "Plugin '%s' configured an authorizer, but has no commands requiring authorization", task.name)
				r.Say(configAuthError)
				return robot.ConfigurationError
			}
			return robot.Success
		} else if !plugin.AuthorizeAllCommands {
			authRequired := false
			for _, i := range plugin.AuthorizedCommands {
				if command == i {
					authRequired = true
					break
				}
			}
			if !authRequired {
				return robot.Success
			}
		}
	} else {
		// Jobs don't have commands; only check authorization if an Authorizer
		// is explicitly set.
		if len(task.Authorizer) == 0 {
			return robot.Success
		}
	}
	defaultAuthorizer := r.cfg.defaultAuthorizer
	if isPlugin && task.Authorizer == "" && defaultAuthorizer == "" {
		Log(robot.Audit, "Plugin '%s' requires authorization for command '%s', but no authorizer configured", task.name, command)
		r.Say(configAuthError)
		emit(AuthNoRunMisconfigured)
		return robot.ConfigurationError
	}
	authorizer := defaultAuthorizer
	if task.Authorizer != "" {
		authorizer = task.Authorizer
	}
	authTask := r.tasks.getTaskByName(authorizer)
	if authTask == nil {
		return robot.ConfigurationError
	}
	_, authPlug, _ := getTask(authTask)
	if authPlug != nil {
		args = append([]string{task.name, task.AuthRequire, command}, args...)
		_, authRet := w.callTask(authPlug, "authorize", args...)
		w.currentTask = r.currentTask
		if authRet == robot.Success {
			Log(robot.Audit, "Authorization succeeded by authorizer '%s' for user '%s' calling command '%s' for task '%s' in channel '%s'; AuthRequire: '%s'", authPlug.name, r.User, command, task.name, r.Channel, task.AuthRequire)
			emit(AuthRanSuccess)
			return robot.Success
		}
		if authRet == robot.Fail {
			Log(robot.Audit, "Authorization FAILED by authorizer '%s' for user '%s' calling command '%s' for task '%s' in channel '%s'; AuthRequire: '%s'", authPlug.name, r.User, command, task.name, r.Channel, task.AuthRequire)
			r.Say("Sorry, you're not authorized for that command")
			emit(AuthRanFail)
			return robot.Fail
		}
		if authRet == robot.MechanismFail {
			Log(robot.Audit, "Auth plugin '%s' mechanism failure while authenticating user '%s' calling command '%s' for task '%s' in channel '%s'; AuthRequire: '%s'", authPlug.name, r.User, command, task.name, r.Channel, task.AuthRequire)
			r.Say(technicalAuthError)
			emit(AuthRanMechanismFailed)
			return robot.MechanismFail
		}
		if authRet == robot.Normal {
			Log(robot.Audit, "Auth plugin '%s' returned 'Normal' (%d) instead of 'Success' (%d), failing auth in '%s' calling command '%s' for task '%s' in channel '%s'; AuthRequire: '%s'", authPlug.name, robot.Normal, robot.Success, r.User, command, task.name, r.Channel, task.AuthRequire)
			r.Say(technicalAuthError)
			emit(AuthRanFailNormal)
			return robot.MechanismFail
		}
		Log(robot.Audit, "Auth plugin '%s' exit code %s, failing auth while authenticating user '%s' calling command '%s' for task '%s' in channel '%s'; AuthRequire: '%s'", authPlug.name, authRet, r.User, command, task.name, r.Channel, task.AuthRequire)
		r.Say(technicalAuthError)
		emit(AuthRanFailOther)
		return robot.MechanismFail
	}
	Log(robot.Audit, "Auth plugin '%s' not found while authenticating user '%s' calling command '%s' for task '%s' in channel '%s'; AuthRequire: '%s'", task.Authorizer, r.User, command, task.name, r.Channel, task.AuthRequire)
	r.Say(technicalAuthError)
	emit(AuthNoRunNotFound)
	return robot.ConfigurationError
}
</file_content file: gopherbot-main/bot/authorize.go>
<preamble file: gopherbot-main/bot/available.go>

</preamble>
<file_content file: gopherbot-main/bot/available.go>
package bot

import (
	"path/filepath"
)

// pluginAvailable checks the user and channel against the task's
// configuration to determine if the task should be available. Used by
// both handleMessage and the help builtin. verboseOnly is set when availability
// is being checked for ambient messages or auth/elevation plugins, to indicate
// debugging verboseness. The `specific` bool is set whenever a plugin lists the
// channel explicitly, or for direct messages when DirectOnly is true; this is
// used by the help plugin to differentiate "<robot>, help" from "<robot> help-all".
func (w *worker) pluginAvailable(task *Task, helpSystem, verboseOnly bool) (available, specific bool) {
	nvmsg := "task is NOT visible to user " + w.User + " in channel "
	vmsg := "task is visible to user " + w.User + " in channel "
	if w.Incoming.DirectMessage {
		nvmsg += "(direct message)"
		vmsg += "(direct message)"
	} else {
		nvmsg += w.Channel
		vmsg += w.Channel
	}
	if task.Disabled {
		return false, false
	}
	if !w.Incoming.DirectMessage && task.DirectOnly && !helpSystem {
		return false, false
	}
	if w.Incoming.DirectMessage && !task.AllowDirect && !helpSystem {
		return false, false
	}
	if task.RequireAdmin {
		isAdmin := false
		admins := w.cfg.adminUsers
		for _, adminUser := range admins {
			if w.User == adminUser {
				isAdmin = true
				break
			}
		}
		if !isAdmin {
			return false, false
		}
	}
	if len(task.Users) > 0 {
		userOk := false
		for _, allowedUser := range task.Users {
			match, err := filepath.Match(allowedUser, w.User)
			if match && err == nil {
				userOk = true
			}
		}
		if !userOk {
			return false, false
		}
	}
	if w.Incoming.DirectMessage && (task.AllowDirect || task.DirectOnly) {
		if task.DirectOnly {
			return true, true
		}
		return true, helpSystem
	}
	if len(task.Channels) > 0 {
		for _, pchannel := range task.Channels {
			if pchannel == w.Channel {
				return true, true
			}
		}
	} else {
		if task.AllChannels {
			return true, helpSystem
		}
	}
	if helpSystem {
		return true, true
	}
	return false, false
}
</file_content file: gopherbot-main/bot/available.go>
<preamble file: gopherbot-main/bot/base64_io.go>

</preamble>
<file_content file: gopherbot-main/bot/base64_io.go>
package bot

import (
	"bufio"
	"encoding/base64"
	"io"
	"os"

	"github.com/emersion/go-textwrapper"
)

var base64header = "#GOPHERBOT-BASE64-DATA\n"

// base64_file.go - read and write #GOPHERBOT-BASE64-DATA files

// WriteBase64File writes a byte slice to a #GOPHERBOT-BASE64-DATA
// file
func WriteBase64File(filename string, b *[]byte) error {
	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	return WriteBase64(f, b)
}

// WriteBase64 writes out a #GOPHERBOT-BASE64-DATA file
func WriteBase64(out io.Writer, b *[]byte) error {
	out.Write([]byte(base64header))
	w := textwrapper.New(out, "\n", 77)
	encoder := base64.NewEncoder(base64.StdEncoding, w)
	encoder.Write(*b)
	encoder.Close()
	w.Write([]byte("\n"))
	return nil
}

// ReadBinaryFile reads a binary file, detecting and decoding base64
func ReadBinaryFile(filename string) (*[]byte, error) {
	in, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	return ReadBinary(in)
}

// ReadBinary reads a binary reader, detecting and decoding base64
func ReadBinary(in io.Reader) (*[]byte, error) {
	br := bufio.NewReader(in)
	header, err := br.Peek(len(base64header))
	if err == nil {
		if string(header) == base64header {
			br.Discard(len(base64header))
			decoder := base64.NewDecoder(base64.StdEncoding, br)
			bytes, err := io.ReadAll(decoder)
			if err != nil {
				return nil, err
			}
			return &bytes, nil
		}
	}
	bytes, err := io.ReadAll(br)
	if err == nil {
		return &bytes, nil
	}
	return nil, err
}
</file_content file: gopherbot-main/bot/base64_io.go>
<preamble file: gopherbot-main/bot/bot_process.go>

</preamble>
<file_content file: gopherbot-main/bot/bot_process.go>
// Package bot provides the internal machinery for most of Gopherbot.
package bot

/* bot.go defines core data structures and public methods for startup.
   handler.go has the methods for callbacks from the connector, */

import (
	crand "crypto/rand"
	"encoding/base64"
	"fmt"
	"log"
	"math/rand"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

// VersionInfo holds information about the version, duh. (stupid linter)
type VersionInfo struct {
	Version, Commit string
}

// global values for GOPHER_HOME, GOPHER_CONFIGDIR and GOPHER_INSTALLDIR
var homePath, configPath, configFull, installPath string

var botVersion VersionInfo

// Seed the pseudo-random number generator, for plugin IDs, RandomString, etc.
var random = rand.New(rand.NewSource(time.Now().UnixNano()))

var connectors = make(map[string]func(robot.Handler, *log.Logger) robot.Connector)

// RegisterConnector should be called in an init function to register a type
// of connector. Currently only Slack is implemented.
func RegisterConnector(name string, connstarter func(robot.Handler, *log.Logger) robot.Connector) {
	if stopRegistrations {
		return
	}
	if connectors[name] != nil {
		log.Fatal("Attempted registration of duplicate connector:", name)
	}
	connectors[name] = connstarter
}

// Interfaces to external stuff, items should be set while single-threaded and never change
var interfaces struct {
	robot.Connector                       // Connector interface, implemented by each specific protocol
	brain           robot.SimpleBrain     // Interface for robot to Store and Retrieve data
	history         robot.HistoryProvider // Provider for storing and retrieving job / plugin histories
}

var done = make(chan bool)              // shutdown channel, true to restart
var stopConnector = make(chan struct{}) // stop channel for stopping the connector

// internal state tracking
var state struct {
	shuttingDown     bool // to prevent new plugins from starting
	restart          bool // indicate stop and restart vs. stop only, for bootstrapping
	pipelinesRunning int  // a count of how many plugins are currently running
	sync.WaitGroup        // for keeping track of running plugins
	sync.RWMutex          // for safe updating of bot data structures
}

// regexes the bot uses to determine if it's being spoken to
var regexes struct {
	preRegex  *regexp.Regexp // regex for matching prefixed commands, e.g. "Gort, drop your weapon"
	postRegex *regexp.Regexp // regex for matching, e.g. "open the pod bay doors, hal"
	bareRegex *regexp.Regexp // regex for matching the robot's bare name, if you forgot it in the previous command
	sync.RWMutex
}

// configuration struct holds all the internal data relevant to the Bot. Most of it is digested
// and populated by loadConfig.
type configuration struct {
	adminUsers           []string            // List of users with access to administrative commands
	alias                rune                // single-char alias for addressing the bot
	botinfo              UserInfo            // robot's name, ID, email, etc.
	adminContact         string              // who to contact for problems with the bot
	mailConf             botMailer           // configuration to use when sending email
	ignoreUsers          []string            // list of users to never listen to, like other bots
	joinChannels         []string            // list of channels to join
	defaultAllowDirect   bool                // whether plugins are available in DM by default
	ignoreUnlistedUsers  bool                // ignore users not listed in the UserRoster
	defaultMessageFormat robot.MessageFormat // Raw unless set to Variable or Fixed
	plugChannels         []string            // list of channels where plugins are available by default
	protocol             string              // Name of the protocol, e.g. "slack"
	brainProvider        string              // Type of Brain provider to use
	encryptionKey        string              // Key for encrypting data (unlocks "real" key in brain)
	historyProvider      string              // Name of the history provider to use
	workSpace            string              // Read/Write directory where the robot does work
	defaultElevator      string              // Plugin name for performing elevation
	defaultAuthorizer    string              // Plugin name for performing authorization
	externalPlugins      []TaskSettings      // List of external plugins to load
	externalJobs         []TaskSettings      // List of external jobs to load
	externalTasks        []TaskSettings      // List of external tasks to load
	goPlugins            []TaskSettings      // Settings for goPlugins: Name(match), Description, NameSpace, Parameters, Disabled
	goJobs               []TaskSettings      // Settings for goJobs: Name(match), Description, NameSpace, Parameters, Disabled
	goTasks              []TaskSettings      // Settings for goTasks: Name(match), Description, NameSpace, Parameters, Disabled
	nsList               []TaskSettings      // loaded NameSpaces for shared parameters
	psList               []TaskSettings      // loaded ParameterSets for shared parameter sets
	ScheduledJobs        []ScheduledTask     // List of scheduled tasks
	port                 string              // Configured localhost port to listen on, or 0 for first open
	timeZone             *time.Location      // for forcing the TimeZone, Unix only
	defaultJobChannel    string              // where job statuses will post if not otherwise specified
}

// The current configuration and task list
var currentCfg = struct {
	*configuration
	*taskList
	sync.RWMutex
}{
	configuration: &configuration{},
	taskList: &taskList{
		t:             []interface{}{struct{}{}}, // initialize 0 to "nothing", for namespaces only
		nameMap:       make(map[string]int),
		idMap:         make(map[string]int),
		nameSpaces:    make(map[string]ParameterSet),
		parameterSets: make(map[string]ParameterSet),
	},
	RWMutex: sync.RWMutex{},
}

var listening bool    // for tests where initBot runs multiple times
var listenPort string // actual listening port

// initBot sets up the global robot; when cli is false it also loads configuration.
// cli indicates that a CLI command is being processed, as opposed to actually running
// a robot.
func initBot(cpath, epath string) {
	// Initialize current config with an empty struct (to be loaded)
	currentCfg.configuration = &configuration{}

	var err error
	homePath, err = os.Getwd()
	if err != nil {
		Log(robot.Warn, "Unable to get cwd")
	}
	h := handler{}
	if err := h.GetDirectory(cpath); err != nil {
		Log(robot.Fatal, "Unable to get/create config path: %s", cpath)
	}
	configPath = cpath
	if filepath.IsAbs(cpath) {
		configFull = cpath
	} else {
		configFull = filepath.Join(homePath, cpath)
	}
	installPath = epath

	state.shuttingDown = false

	if cliOp {
		setLogLevel(robot.Warn)
	}

	encryptionInitialized := initCrypt()
	if encryptionInitialized {
		os.Setenv("GOPHER_ENCRYPTION_INITIALIZED", "initialized")
	}

	// The pre-connect load is for initial configuration that doesn't
	// run external scripts. External plugin configuration isn't loaded and plugins
	// aren't initialized.
	if err := loadConfig(true); err != nil {
		Log(robot.Fatal, "Loading initial configuration: %v", err)
	}

	if cliOp {
		if fileLog {
			setLogLevel(robot.Debug)
		} else {
			setLogLevel(robot.Warn)
		}
	}

	// All pluggables registered, ok to stop registrations
	stopRegistrations = true

	if len(currentCfg.brainProvider) > 0 {
		if bprovider, ok := brains[currentCfg.brainProvider]; !ok {
			Log(robot.Fatal, "No provider registered for brain: \"%s\"", currentCfg.brainProvider)
		} else {
			brain := bprovider(handle)
			interfaces.brain = brain
			Log(robot.Info, "Initialized brain provider '%s'", currentCfg.brainProvider)
		}
	} else {
		bprovider := brains["mem"]
		interfaces.brain = bprovider(handle)
		Log(robot.Error, "No brain configured, falling back to default 'mem' brain - no memories will persist")
	}
	if !encryptionInitialized && len(currentCfg.encryptionKey) > 0 {
		if initializeEncryptionFromBrain(currentCfg.encryptionKey) {
			Log(robot.Info, "Successfully initialized encryption from configured key")
			encryptionInitialized = true
		} else {
			Log(robot.Error, "Failed to initialize brain encryption with configured EncryptionKey")
		}
	}
	if encryptBrain && !encryptionInitialized {
		Log(robot.Warn, "Brain encryption specified but not initialized; use 'initialize brain <key>' to initialize the encrypted brain interactively")
	}

	// cli commands don't need an http listener
	if cliOp {
		return
	}

	if !listening {
		listening = true
		listener, err := net.Listen("tcp4", fmt.Sprintf("127.0.0.1:%s", currentCfg.port))
		if err != nil {
			Log(robot.Fatal, "Listening on tcp4 port 127.0.0.1:%s: %v", currentCfg.port, err)
		}
		listenPort = listener.Addr().String()
		go func() {
			raiseThreadPriv("http handler")
			apiServer := http.NewServeMux()
			apiServer.Handle("/json", handle)
			Log(robot.Info, "Listening for external plugin connections on http://%s", listenPort)
			Log(robot.Fatal, "Error serving '/json': %s", http.Serve(listener, apiServer))
		}()
	}
}

// set connector sets the connector, which should already be initialized
func setConnector(c robot.Connector) {
	interfaces.Connector = c
}

var keyEnv = "GOPHER_ENCRYPTION_KEY"

func initCrypt() bool {
	// Initialize encryption (new style for v2)
	keyFileName := encryptedKeyFile
	deployEnvironment := os.Getenv("GOPHER_ENVIRONMENT")
	if deployEnvironment != "production" {
		Log(robot.Info, "Initializing encryption for the '%s' environment", deployEnvironment)
		keyFileName += "." + deployEnvironment
	}
	keyFile := filepath.Join(configPath, keyFileName)
	encryptionInitialized := false
	if ek, ok := os.LookupEnv(keyEnv); ok {
		ik := []byte(ek)[0:32]
		if bkf, err := os.ReadFile(keyFile); err == nil {
			if bke, err := base64.StdEncoding.DecodeString(string(bkf)); err == nil {
				if key, err := decrypt(bke, ik); err == nil {
					cryptKey.Lock()
					cryptKey.key = key
					cryptKey.initialized = true
					cryptKey.Unlock()
					encryptionInitialized = true
					Log(robot.Info, "Successfully decrypted binary encryption key '%s'", keyFile)
				} else {
					Log(robot.Error, "Decrypting binary encryption key '%s' from environment key '%s': %v", keyFile, keyEnv, err)
				}
			} else {
				Log(robot.Error, "Base64 decoding '%s': %v", keyFile, err)
			}
		} else {
			Log(robot.Warn, "Binary encryption key not loaded from '%s': %v", keyFile, err)
			if len(currentCfg.encryptionKey) == 0 {
				// No encryptionKey in config, create new-style key
				bk := make([]byte, 32)
				_, err := crand.Read(bk)
				if err != nil {
					Log(robot.Error, "Generating new random encryption key: %v", err)
					return false
				}
				bek, err := encrypt(bk, ik)
				if err != nil {
					Log(robot.Error, "Encrypting new random key: %v", err)
					return false
				}
				beks := base64.StdEncoding.EncodeToString(bek)
				raiseThreadPriv("writing generated encrypted key")
				err = os.WriteFile(keyFile, []byte(beks), 0444)
				if err != nil {
					Log(robot.Error, "Writing out generated key: %v", err)
					return false
				}
				Log(robot.Info, "Successfully wrote new binary encryption key to '%s'", keyFile)
				cryptKey.Lock()
				cryptKey.key = bk
				cryptKey.initialized = true
				cryptKey.Unlock()
				encryptionInitialized = true
				return true
			}
		}
	} else {
		Log(robot.Warn, "GOPHER_ENCRYPTION_KEY not set in environment")
	}
	return encryptionInitialized
}

// run starts all the loops and returns a channel that closes when the robot
// shuts down. It should return after the connector loop has started and
// plugins are initialized.
func run() {
	// Start the brain loop
	go runBrain()

	// Restore subscriptions and ephemeral memories
	restoreSubscriptions()
	restoreEphemeralMemories()

	var cl []string
	cl = append(cl, currentCfg.joinChannels...)
	cl = append(cl, currentCfg.plugChannels...)
	cl = append(cl, currentCfg.defaultJobChannel)
	jc := make(map[string]bool)
	for _, channel := range cl {
		if _, ok := jc[channel]; !ok {
			jc[channel] = true
			interfaces.JoinChannel(channel)
		}
	}

	// signal handler
	sigBreak := make(chan struct{})
	go sigHandle(sigBreak)

	// connector loop
	go func(conn robot.Connector, sigBreak chan<- struct{}) {
		raiseThreadPriv("connector loop")
		conn.Run(stopConnector)
		close(sigBreak)
		state.RLock()
		restart := state.restart
		state.RUnlock()
		if restart {
			Log(robot.Info, "Restarting...")
		}
		done <- restart
	}(interfaces.Connector, sigBreak)

	// The first run through is for configuring and running init
	// jobs (which can't send messages), the second run through
	// (post-connect) initializes plugins and may send messages.
	if err := loadConfig(false); err != nil {
		Log(robot.Fatal, "Loading full/post-connect configuration: %v", err)
	}
	Log(robot.Info, "Robot is initialized and running")
}

// stop is called whenever the robot needs to shut down gracefully. All callers
// should lock the bot and check the value of botCfg.shuttingDown; see
// builtins.go.
func stop() {
	state.RLock()
	pr := state.pipelinesRunning
	state.RUnlock()
	Log(robot.Info, "Stop called with %d pipelines running", pr)
	state.Wait()
	brainQuit()
	stopConnector <- struct{}{}
}
</file_content file: gopherbot-main/bot/bot_process.go>
<preamble file: gopherbot-main/bot/bot_regexes.go>

</preamble>
<file_content file: gopherbot-main/bot/bot_regexes.go>
package bot

import (
	"regexp"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

const escapeAliases = `*+^$?\[]{}`
const aliases = `&!;:-%#@~<>`

func updateRegexes() {
	currentCfg.RLock()
	name := currentCfg.botinfo.UserName
	protoMention := currentCfg.botinfo.protoMention
	alias := currentCfg.alias
	currentCfg.RUnlock()
	preRegex, postRegex, bareRegex, errpre, errpost, errbare := updateRegexesWrapped(name, protoMention, alias)
	if errpre != nil {
		Log(robot.Error, "Compiling pre regex: %s", errpre)
	}
	if preRegex != nil {
		Log(robot.Debug, "Setting pre regex to: %s", preRegex)
	}
	if errpost != nil {
		Log(robot.Error, "Compiling post regex: %s", errpost)
	}
	if postRegex != nil {
		Log(robot.Debug, "Setting post regex to: %s", postRegex)
	}
	if errbare != nil {
		Log(robot.Error, "Compiling bare regex: %s", errbare)
	}
	if bareRegex != nil {
		Log(robot.Debug, "Setting bare regex to: %s", bareRegex)
	}
	regexes.Lock()
	regexes.preRegex = preRegex
	regexes.postRegex = postRegex
	regexes.bareRegex = bareRegex
	regexes.Unlock()
}

// TODO: write unit test. The regexes produced shouldn't be checked, but rather
// whether given strings do or don't match them. Note: this code is partially
// tested in TestBotName
func updateRegexesWrapped(name, mention string, alias rune) (preRe, postRe, bareRe *regexp.Regexp, errpre, errpost, errbare error) {
	preRe = nil
	postRe = nil
	if alias == 0 && len(name) == 0 {
		Log(robot.Error, "Robot has no name or alias, and will only respond to direct messages")
		return
	}
	names := []string{}
	barenames := []string{}
	if alias != 0 {
		if strings.ContainsRune(string(escapeAliases), alias) {
			names = append(names, `\`+string(alias))
			barenames = append(barenames, `\`+string(alias))
		} else {
			names = append(names, string(alias))
			barenames = append(barenames, string(alias))
		}
	}
	if len(name) > 0 {
		if len(mention) > 0 {
			names = append(names, `(?i:`+name+`)[:, ]`)
			barenames = append(barenames, `(?i:`+name+`\??)`)
		} else {
			names = append(names, `(?i:@?`+name+`[:, ])`)
			barenames = append(barenames, `(?i:@?`+name+`\??)`)
		}
	}
	if len(mention) > 0 {
		names = append(names, `(?:@`+mention+`[:, ])`)
		barenames = append(barenames, `(?:@`+mention+`\??)`)
	}
	preString := `^(?s)(?i:(` + strings.Join(names, "|") + `)\s*)(.*)$`
	preRe, errpre = regexp.Compile(preString)
	// NOTE: the preString regex matches a bare alias, but not a bare name
	if len(name) > 0 {
		postString := `^([^,@]+),\s+(?i:@?` + name + `)([.?!])?$`
		postRe, errpost = regexp.Compile(postString)
		bareString := `^@?(?i:` + strings.Join(barenames, "|") + `)$`
		bareRe, errbare = regexp.Compile(bareString)
	}
	return
}
</file_content file: gopherbot-main/bot/bot_regexes.go>
<preamble file: gopherbot-main/bot/brain.go>

</preamble>
<file_content file: gopherbot-main/bot/brain.go>
package bot

import (
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

// Map of registered brains
var brains = make(map[string]func(robot.Handler) robot.SimpleBrain)

// Set on start-up
var encryptBrain bool

// For aes brain encryption
var cryptKey = struct {
	key                       []byte
	initializing, initialized bool
	sync.RWMutex
}{}

// Definitions of bot keys and prefixes

// The "real" key to en-/de-crypt memories;
// the user-supplied key unlocks this, allowing
// the user to re-key if they change how the key
// is supplied.
const botEncryptionKey = "bot:encryptionKey"
const encryptedKeyFile = "binary-encrypted-key"

// People generally expect the robot to remember things longer.
const channelMemoryDuration = 14 * time.Minute  // In the main channel, conversation context/topics tend to change often
const threadMemoryDuration = 7 * time.Hour * 24 // In a thread, the conversation context/topic tends to last days

type memState int

const (
	newMemory memState = iota
	seen
	available
)

type memstatus struct {
	state   memState
	token   string // whoever has this token owns the lock for this memory
	waiters []checkOutRequest
}

var brainChanEvents = make(chan interface{})

type checkOutRequest struct {
	key   string
	rw    bool
	reply chan checkOutReply
}

type checkOutReply struct {
	token  string
	bytes  *[]byte
	exists bool
	RetVal robot.RetVal
}

type checkInRequest struct {
	key   string
	token string
}

type updateRequest struct {
	key   string
	token string
	datum *[]byte
	reply chan robot.RetVal
}

type pauseRequest struct {
	resume chan struct{}
	wid    int
}

type quitRequest struct {
	reply chan struct{}
}

// how often does the robot cycle through memories and update state?
// a value of time.Second means a lock will last between 1 and 2 seconds
const memCycle = time.Second

func replyToWaiter(m *memstatus) {
	creq := m.waiters[0]
	m.waiters = m.waiters[1:]
	lt, d, e, r := getDatum(creq.key, true)
	m.state = newMemory
	m.token = lt
	creq.reply <- checkOutReply{lt, d, e, r}
}

// brain locking for backups
// the brain shouldn't be big, and this pauses all activity for
// a maximum of lockMax seconds
const lockMax = 28

var brainLocks = struct {
	locks map[int]chan struct{}
	sync.Mutex
}{
	make(map[int]chan struct{}),
	sync.Mutex{},
}

// runBrain is the select loop that serializes access to brain
// functions and insures consistency.
func runBrain() {
	raiseThreadPriv("runBrain loop")
	// map key to status
	memories := make(map[string]*memstatus)
	brainTicker := time.NewTicker(memCycle)
loop:
	for {
		select {
		case evt := <-brainChanEvents:
			switch evt.(type) {
			case pauseRequest:
				pb := evt.(pauseRequest)
				Log(robot.Debug, "Brain pause requested by worker %d", pb.wid)
				select {
				case <-pb.resume:
					continue
				case <-time.After(lockMax * time.Second):
					Log(robot.Warn, "Brain pause timed out after %d seconds for worker %d", lockMax, pb.wid)
					brainLocks.Lock()
					delete(brainLocks.locks, pb.wid)
					brainLocks.Unlock()
					continue
				}
			case checkOutRequest:
				creq := evt.(checkOutRequest)
				memStat, exists := memories[creq.key]
				if !exists {
					lt, d, e, r := getDatum(creq.key, creq.rw)
					if r != robot.Ok {
						creq.reply <- checkOutReply{lt, d, e, r}
						continue
					}
					if creq.rw {
						m := &memstatus{
							newMemory,
							lt,
							make([]checkOutRequest, 0, 2),
						}
						memories[creq.key] = m
					}
					creq.reply <- checkOutReply{lt, d, e, r}
					continue
				}
				if !creq.rw {
					lt, d, e, r := getDatum(creq.key, creq.rw)
					creq.reply <- checkOutReply{lt, d, e, r}
					continue
				} // read-write request below
				// if state is available, there are no waiters
				if memStat.state == available {
					lt, d, e, r := getDatum(creq.key, creq.rw)
					memStat.state = newMemory
					memStat.token = lt // this memory has a new owner now
					memories[creq.key] = memStat
					creq.reply <- checkOutReply{lt, d, e, r}
				} else {
					memStat.waiters = append(memStat.waiters, creq)
					memories[creq.key] = memStat
				}
			case checkInRequest:
				ci := evt.(checkInRequest)
				m, ok := memories[ci.key]
				if !ok {
					continue
				}
				// memory expired and somebody else owns it
				if ci.token != m.token {
					continue
				}
				if len(m.waiters) > 0 {
					replyToWaiter(m)
					continue
				}
				delete(memories, ci.key)
			case updateRequest:
				ur := evt.(updateRequest)
				m, ok := memories[ur.key]
				if !ok {
					ur.reply <- robot.DatumNotFound
					continue
				}
				if ur.token != m.token {
					ur.reply <- robot.DatumLockExpired
					continue
				}
				ur.reply <- storeDatum(ur.key, ur.datum)
				if len(m.waiters) > 0 {
					replyToWaiter(m)
					continue
				}
				delete(memories, ur.key)
			case quitRequest:
				qr := evt.(quitRequest)
				qr.reply <- struct{}{}
				break loop
			}
		case <-brainTicker.C:
			now := time.Now()
			// Expire thread subscriptions - see thread_subscriptions.go
			isDirty := expireSubscriptions(now)
			if isDirty {
				go saveSubscriptions()
			}
			ephemeralMemories.Lock()
			for context, memory := range ephemeralMemories.m {
				// Expire bot direct message memories the same as threads
				if len(context.thread) > 0 || len(context.channel) == 0 {
					if now.Sub(memory.Timestamp) > threadMemoryDuration {
						delete(ephemeralMemories.m, context)
						ephemeralMemories.dirty = true
					}
				} else {
					if now.Sub(memory.Timestamp) > channelMemoryDuration {
						delete(ephemeralMemories.m, context)
						ephemeralMemories.dirty = true
					}
				}
			}
			isDirty = ephemeralMemories.dirty
			ephemeralMemories.Unlock()
			if isDirty {
				go saveEphemeralMemories()
			}
			for _, m := range memories {
				switch m.state {
				case newMemory:
					m.state = seen
				case seen:
					if len(m.waiters) > 0 {
						replyToWaiter(m)
						continue
					}
					m.state = available
				}
			}
		}
	}
}

func brainQuit() {
	reply := make(chan struct{})
	brainChanEvents <- quitRequest{reply}
	Log(robot.Debug, "Brain exiting on quit")
	<-reply
}

const keyRegex = `[\w:]+` // keys can ony be word chars + separator (:)
var keyRe = regexp.MustCompile(keyRegex)

// checkout returns the []byte from the brain, with a lock token granting
// ownership for a limited time
func checkout(d string, rw bool) (string, *[]byte, bool, robot.RetVal) {
	if !keyRe.MatchString(d) {
		Log(robot.Error, "Invalid memory key, ':' disallowed: %s", d)
		return "", nil, false, robot.InvalidDatumKey
	}
	reply := make(chan checkOutReply)
	brainChanEvents <- checkOutRequest{d, rw, reply}
	rep := <-reply
	Log(robot.Trace, "Brain datum checkout for %s, rw: %t - token: %s, exists: %t, ret: %d",
		d, rw, rep.token, rep.exists, rep.RetVal)
	return rep.token, rep.bytes, rep.exists, rep.RetVal
}

// update sends updated []byte to the brain while holding the lock, or discards
// the data and returns an error.
func update(d, lt string, datum *[]byte) (ret robot.RetVal) {
	if lt == "" {
		return robot.Ok
	}
	reply := make(chan robot.RetVal)
	Log(robot.Trace, "Updating datum %s, token: %s", d, lt)
	brainChanEvents <- updateRequest{d, lt, datum, reply}
	return <-reply
}

// checkinDatum is the internal version of CheckinDatum that uses the key as-is
func checkinDatum(key, locktoken string) {
	if locktoken == "" {
		return
	}
	Log(robot.Trace, "Checking in datum %s, token: %s", key, locktoken)
	brainChanEvents <- checkInRequest{key, locktoken}
}

// pauseBrain pauses the brain for backups, passing a resume channel
func pauseBrain(wid int, resume chan struct{}) {
	brainChanEvents <- pauseRequest{resume, wid}
}

// checkoutDatum is the robot internal version of CheckoutDatum that uses
// the provided key as-is.
func checkoutDatum(key string, datum interface{}, rw bool) (locktoken string, exists bool, ret robot.RetVal) {
	var dbytes *[]byte
	locktoken, dbytes, exists, ret = checkout(key, rw)
	if exists { // exists = true implies no error
		err := json.Unmarshal(*dbytes, datum)
		if err != nil {
			Log(robot.Error, "Unmarshalling datum %s: %v", key, err)
			exists = false
			ret = robot.DataFormatError
		}
	}
	return
}

// updateDatum is the internal version of UpdateDatum that uses the key as-is
func updateDatum(key, locktoken string, datum interface{}) (ret robot.RetVal) {
	dbytes, err := json.Marshal(datum)
	if err != nil {
		Log(robot.Error, "Marshalling datum %s: %v", key, err)
		return robot.DataFormatError
	}
	return update(key, locktoken, &dbytes)
}

func (w *worker) getNameSpace(t interface{}) string {
	task, plugin, _ := getTask(t)
	// A configured NameSpace always takes precedence
	if len(task.NameSpace) > 0 {
		return task.NameSpace
	}
	// Plugins never inherit the pipeline namespace,
	// because they implement authorizers and elevators.
	if plugin != nil {
		return task.name
	}
	w.Lock()
	defer w.Unlock()
	// Inherit namespace from the pipeline
	if len(w.nameSpace) > 0 {
		return w.nameSpace
	}
	return task.name
}

// CheckoutDatum gets a datum from the robot's brain and unmarshals it into
// a struct. If rw is set, the datum is checked out read-write and a non-empty
// lock token is returned that expires after lockTimeout (250ms). The bool
// return indicates whether the datum exists. Datum must be a pointer to a
// var.
func (r Robot) CheckoutDatum(key string, datum interface{}, rw bool) (locktoken string, exists bool, ret robot.RetVal) {
	if strings.ContainsRune(key, ':') {
		ret = robot.InvalidDatumKey
		Log(robot.Error, "Invalid memory key, ':' disallowed: %s", key)
		return
	}
	w := getLockedWorker(r.tid)
	w.Unlock()
	ns := w.getNameSpace(r.currentTask)
	if len(r.nsExtension) > 0 {
		key = ns + ":" + r.nsExtension + ":" + key
	} else {
		key = ns + ":" + key
	}
	return checkoutDatum(key, datum, rw)
}

// CheckinDatum unlocks a datum without updating it, it always succeeds
func (r Robot) CheckinDatum(key, locktoken string) {
	if locktoken == "" {
		return
	}
	if strings.ContainsRune(key, ':') {
		return
	}
	w := getLockedWorker(r.tid)
	w.Unlock()
	ns := w.getNameSpace(r.currentTask)
	if len(r.nsExtension) > 0 {
		key = ns + ":" + r.nsExtension + ":" + key
	} else {
		key = ns + ":" + key
	}
	checkinDatum(key, locktoken)
}

// UpdateDatum tries to update a piece of data in the robot's brain, providing
// a struct to marshall and a (hopefully good) lock token. If err != nil, the
// update failed.
func (r Robot) UpdateDatum(key, locktoken string, datum interface{}) (ret robot.RetVal) {
	if strings.ContainsRune(key, ':') {
		Log(robot.Error, "Invalid memory key, ':' disallowed: %s", key)
		return robot.InvalidDatumKey
	}
	w := getLockedWorker(r.tid)
	w.Unlock()
	ns := w.getNameSpace(r.currentTask)
	if len(r.nsExtension) > 0 {
		key = ns + ":" + r.nsExtension + ":" + key
	} else {
		key = ns + ":" + key
	}
	return updateDatum(key, locktoken, datum)
}

// Remember adds a ephemeral memory (with no backing store) to the robot's
// brain. This is used internally for resolving the meaning of "it", but can
// be used by plugins to remember other contextual facts. Since memories are
// indexed by user and channel, but not plugin, these facts can be referenced
// between plugins. This functionality is considered EXPERIMENTAL.
func (r Robot) Remember(key, value string, shared bool) {
	timestamp := time.Now()
	memory := ephemeralMemory{value, timestamp}
	context := r.makeMemoryContext(key, false, shared)
	Log(robot.Trace, "Storing ephemeral memory \"%s\" -> \"%s\"", key, value)
	ephemeralMemories.Lock()
	if len(value) > 0 {
		r.Log(robot.Debug, "Storing ephemeral memory for '%s'", key)
		ephemeralMemories.m[context] = memory
	} else {
		r.Log(robot.Debug, "Deleting ephemeral memory '%s'", key)
		delete(ephemeralMemories.m, context)
	}
	if len(context.thread) > 0 {
		ephemeralMemories.dirty = true
	}
	ephemeralMemories.Unlock()
}

// RememberThread is identical to Remember, except that it forces the memory
// to associate with the thread.
func (r Robot) RememberThread(key, value string, shared bool) {
	timestamp := time.Now()
	memory := ephemeralMemory{value, timestamp}
	context := r.makeMemoryContext(key, true, shared)
	Log(robot.Trace, "Storing ephemeral memory \"%s\" -> \"%s\"", key, value)
	ephemeralMemories.Lock()
	if len(value) > 0 {
		r.Log(robot.Debug, "Storing ephemeral memory for '%s'", key)
		ephemeralMemories.m[context] = memory
	} else {
		r.Log(robot.Debug, "Deleting ephemeral memory '%s'", key)
		delete(ephemeralMemories.m, context)
	}
	ephemeralMemories.dirty = true
	ephemeralMemories.Unlock()
}

// RememberContext is a convenience function that stores a context reference in
// short term memories. e.g. RememberContext("server", "web1.my.dom") means that
// next time the user uses "it" in the context of a "server", the robot will
// substitute "web1.my.dom".
func (r Robot) RememberContext(context, value string) {
	r.Remember("context:"+context, value, false)
}

// RememberContextThread is identical to RememberContext, except that the memory
// is forced to associate with the thread.
func (r Robot) RememberContextThread(context, value string) {
	r.RememberThread("context:"+context, value, false)
}

// Recall recalls a short term memory, or the empty string if it doesn't exist.
// Note that there are no RecallThread methods - Recall is always in the current
// context.
func (r Robot) Recall(key string, shared bool) string {
	context := r.makeMemoryContext(key, false, shared)
	ephemeralMemories.Lock()
	memory, ok := ephemeralMemories.m[context]
	ephemeralMemories.Unlock()
	Log(robot.Trace, "Recalling ephemeral memory \"%s\" -> \"%s\"", key, memory.Memory)
	if !ok {
		return ""
	}
	return memory.Memory
}

// RegisterSimpleBrain allows brain implementations to register a function with a named
// brain type that returns an SimpleBrain interface.
// This can only be called from a brain provider's init() function(s). Pass in a Logger
// so the brain can log it's own error messages if needed.
func RegisterSimpleBrain(name string, provider func(robot.Handler) robot.SimpleBrain) {
	if stopRegistrations {
		return
	}
	if brains[name] != nil {
		log.Fatal("Attempted registration of duplicate brain provider name:", name)
	}
	brains[name] = provider
}

// When EncryptBrain is true, the brain needs to be initialized.
// NOTE: All locking is done with the cryptKey mutex, bypassing
// the brain loop.
func initializeEncryptionFromBrain(key string) bool {
	kbytes := []byte(key)
	if len(kbytes) < 32 {
		Log(robot.Error, "Failed to initialize brain, provided encryption key < 32 bytes")
		return false
	}
	kbytes = kbytes[0:32]
	cryptKey.Lock()
	if cryptKey.initialized || cryptKey.initializing {
		i := cryptKey.initializing
		cryptKey.Unlock()
		return i
	}
	cryptKey.key = kbytes
	cryptKey.initializing = true
	var err error
	cryptKey.Unlock()
	// retrieve the 'real' key
	_, rk, exists, ret := getDatum(botEncryptionKey, true)
	if ret != robot.Ok {
		cryptKey.Lock()
		cryptKey.initializing = false
		cryptKey.Unlock()
		Log(robot.Error, "Retrieving botEncryptionKey from brain: %s", ret)
		return false
	}
	if exists {
		cryptKey.Lock()
		cryptKey.key = *rk
		cryptKey.initialized = true
		cryptKey.initializing = false
		cryptKey.Unlock()
		return true
	}
	sb := make([]byte, 32)
	_, err = rand.Read(sb)
	if err != nil {
		Log(robot.Error, "Generating new random encryption key: %v", err)
		cryptKey.initializing = false
		return false
	}
	h := handler{}
	if err := h.GetDirectory(configPath); err == nil {
		var bek []byte
		var err error
		if bek, err = encrypt(sb, kbytes); err != nil {
			Log(robot.Fatal, "Encrypting new random key")
		}
		var bekbuff bytes.Buffer
		encoder := base64.NewEncoder(base64.StdEncoding, &bekbuff)
		encoder.Write(bek)
		bekbuff.Write([]byte("\n"))
		if err := os.WriteFile(filepath.Join(configPath, encryptedKeyFile), bekbuff.Bytes(), os.FileMode(0600)); err != nil {
			Log(robot.Fatal, "Writing new random key: %v", err)
		}
	} else {
		Log(robot.Fatal, "Getting custom directory: %v", err)
	}
	cryptKey.Lock()
	cryptKey.key = sb
	cryptKey.initialized = true
	cryptKey.initializing = false
	cryptKey.Unlock()
	return true
}

// getDatum retrieves a blob of bytes from the brain provider and optionally
// decrypts it
func getDatum(dkey string, rw bool) (token string, databytes *[]byte, exists bool, ret robot.RetVal) {
	var decrypted []byte

	if !keyRe.MatchString(dkey) {
		Log(robot.Error, "Invalid memory key, ':' disallowed: %s", dkey)
		return "", nil, false, robot.InvalidDatumKey
	}
	brain := interfaces.brain
	if brain == nil {
		Log(robot.Error, "Brain function called with no brain configured")
		return "", nil, false, robot.BrainFailed
	}
	if rw { // checked out read/write, generate a lock token
		ltb := make([]byte, 8)
		rand.Read(ltb)
		token = fmt.Sprintf("%x", ltb)
	} else {
		token = ""
	}
	var err error
	var db *[]byte
	db, exists, err = brain.Retrieve(dkey)
	if err != nil {
		return "", nil, false, robot.BrainFailed
	}
	if !exists {
		return token, nil, false, robot.Ok
	}
	if encryptBrain {
		cryptKey.RLock()
		initialized := cryptKey.initialized
		initializing := cryptKey.initializing
		key := cryptKey.key
		cryptKey.RUnlock()
		if initializing {
			if dkey != botEncryptionKey {
				Log(robot.Warn, "Retrieve called with uninitialized brain for '%s'", dkey)
				return "", nil, false, robot.BrainFailed
			}
			decrypted, err = decrypt(*db, key)
			if err != nil {
				Log(robot.Error, "Failed to decrypt the encryption key, bad key provided?: %v", err)
				return "", nil, false, robot.BrainFailed
			}
			db = &decrypted
			return token, db, true, robot.Ok
		}
		if initialized {
			decrypted, err = decrypt(*db, key)
			if err != nil {
				// This should only ever happen with the CLI, but could corrupt
				// the binary key.
				if dkey != botEncryptionKey {
					Log(robot.Warn, "Decryption failed for '%s', assuming unencrypted and converting to encrypted", dkey)
					// Calling storeDatum writes to storage without invalidating the lock token
					storeDatum(dkey, db)
				}
			} else {
				db = &decrypted
			}
			return token, db, true, robot.Ok
		}
		Log(robot.Warn, "Retrieve called on uninitialized brain for '%s'", dkey)
		return "", nil, false, robot.BrainFailed
	}
	return token, db, true, robot.Ok
}

// storeDatum takes a blob of bytes and optionally encrypts it before sending it
// to the brain provider
func storeDatum(dkey string, datum *[]byte) robot.RetVal {
	brain := interfaces.brain
	if brain == nil {
		Log(robot.Error, "Brain function called with no brain configured")
		return robot.BrainFailed
	}
	if encryptBrain {
		cryptKey.RLock()
		initialized := cryptKey.initialized
		initializing := cryptKey.initializing
		key := cryptKey.key
		cryptKey.RUnlock()
		if !initialized {
			// When re-keying, we store the 'real' key while uninitialized with a new key
			if !(initializing && dkey == botEncryptionKey) {
				Log(robot.Error, "StoreDatum called for '%s' with encryptBrain true, but encryption not initialized", key)
				return robot.BrainFailed
			}
		}
		encrypted, err := encrypt(*datum, key)
		if err != nil {
			Log(robot.Error, "Failed encrypting '%s': %v", dkey, err)
			return robot.BrainFailed
		}
		datum = &encrypted
	}
	err := brain.Store(dkey, datum)
	if err != nil {
		Log(robot.Error, "Storing datum %s: %v", dkey, err)
		return robot.BrainFailed
	}
	return robot.Ok
}
</file_content file: gopherbot-main/bot/brain.go>
<preamble file: gopherbot-main/bot/builtin_totp.go>

</preamble>
<file_content file: gopherbot-main/bot/builtin_totp.go>
package bot

import (
	"fmt"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/pquerna/otp/totp"
)

var timeoutLock sync.RWMutex
var lastElevate = make(map[string]time.Time)

type timeoutType int

const (
	idle timeoutType = iota
	absolute
)

type totp_user struct {
	User, Secret string
}

type totp_config struct {
	TimeoutSeconds int
	tf64           float64
	TimeoutType    string
	tt             timeoutType
	Users          []totp_user
}

var totpCfg = &totp_config{}
var totpUsers = make(map[string]string)

func init() {
	RegisterPlugin("builtin-totp", robot.PluginHandler{Handler: totp_elevate, Config: totpCfg})
}

func checkOTP(r robot.Robot, code string) (bool, robot.TaskRetVal) {
	m := r.GetMessage()
	secret, exists := totpUsers[m.User]
	if !exists {
		return false, robot.MechanismFail
	}
	m.Channel = ""
	lastValid := r.Recall("lastTOTP", false)
	if lastValid == code {
		r.Log(robot.Warn, "User %s attempted to re-use a TOTP code", m.User)
		return false, robot.Fail
	}
	valid := totp.Validate(code, secret)
	if valid {
		r.Remember("lastTOTP", code, false)
	}
	return valid, robot.Success
}

func getcode(gr robot.Robot, immediate bool) (retval robot.TaskRetVal) {
	m := gr.GetMessage()
	r := gr.(Robot)
	botFull := r.cfg.botinfo.FullName
	var prompt string
	if immediate {
		prompt = fmt.Sprintf("This command requires immediate elevation, please provide a TOTP code for '%s':", botFull)
	} else {
		prompt = fmt.Sprintf("This command requires elevation, please provide a TOTP code for '%s':", botFull)
	}
	rep, ret := r.PromptForReply("OTP", prompt)
	if ret != robot.Ok {
		rep, ret = r.Direct().PromptForReply("OTP", "Try again? I need a 6-digit launch code")
	}
	if ret == robot.Ok {
		ok, ret := checkOTP(r, rep)
		if ret != robot.Success {
			r.Say("There were technical issues validating your code, ask an administrator to check the log")
			return robot.MechanismFail
		}
		if ok {
			return robot.Success
		}
		r.Say("Invalid code")
		return robot.Fail
	}
	r.Log(robot.Error, "User \"%s\" failed to respond to TOTP token prompt", m.User)
	return robot.Fail
}

func totp_elevate(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	m := r.GetMessage()
	switch command {
	case "init":
		r.GetTaskConfig(&totpCfg)
		for _, user := range totpCfg.Users {
			totpUsers[user.User] = user.Secret
		}
	case "check":
		valid, ret := checkOTP(r, args[0])
		if ret != robot.Success {
			r.Say("Dang! I had a system problem verifying your code")
			return
		}
		if valid {
			r.Say("Looks good - you're ready to wreak havoc!")
		} else {
			r.Say("Sorry, that's not a valid code")
		}
	case "elevate":
		immediate := false
		switch args[0] {
		case "true", "True", "t", "T", "Yes", "yes", "Y":
			immediate = true
		}
		if totpCfg.TimeoutType == "absolute" {
			totpCfg.tt = absolute
		}
		totpCfg.tf64 = float64(totpCfg.TimeoutSeconds)
		now := time.Now().UTC()
		ask := false
		if immediate {
			retval = getcode(r, immediate)
		} else {
			timeoutLock.RLock()
			le, ok := lastElevate[m.User]
			timeoutLock.RUnlock()
			if ok {
				diff := now.Sub(le)
				if diff.Seconds() > totpCfg.tf64 {
					ask = true
				} else {
					retval = robot.Success
				}
			} else {
				ask = true
			}
			if ask {
				retval = getcode(r, immediate)
			}
		}
		if retval == robot.Success && totpCfg.tt == idle {
			timeoutLock.Lock()
			lastElevate[m.User] = now
			timeoutLock.Unlock()
		} else if retval == robot.Success && ask && totpCfg.tt == absolute {
			timeoutLock.Lock()
			lastElevate[m.User] = now
			timeoutLock.Unlock()
		}
		return
	}
	return
}
</file_content file: gopherbot-main/bot/builtin_totp.go>
<preamble file: gopherbot-main/bot/builtins.go>

</preamble>
<file_content file: gopherbot-main/bot/builtins.go>
package bot

import (
	"fmt"
	"log"
	"os"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/ghodss/yaml"
	"github.com/lnxjedi/gopherbot/robot"
	"golang.org/x/sys/unix"
)

// Cut off for listing channels after help text
const tooManyChannels = 4

func init() {
	RegisterPlugin("builtin-fallback", robot.PluginHandler{Handler: fallback})
	RegisterPlugin("builtin-dmadmin", robot.PluginHandler{Handler: dmadmin})
	RegisterPlugin("builtin-help", robot.PluginHandler{Handler: help})
	RegisterPlugin("builtin-admin", robot.PluginHandler{Handler: admin})
	RegisterPlugin("builtin-logging", robot.PluginHandler{Handler: logging})
}

func defaultHelp() []string {
	return []string{
		"(alias) help <keyword> - get help for the provided <keyword>",
		"(alias) help-all - help for all commands available in this channel, including global commands",
	}
}

/* builtin plugins, like help */

func fallback(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	if command == "init" {
		return // ignore init
	}
	botAlias := r.GetBotAttribute("alias").String()
	if command == "catchall" {
		channelName := r.GetMessage().Channel
		if len(channelName) > 0 {
			r.SayThread("No command matched in channel '%s'; try '%shelp'", channelName, botAlias)
		} else {
			r.Say("Command not found; try your command in a channel, or use '%shelp'", botAlias)
		}
	}
	return
}

var botRegex = regexp.MustCompile(`^([^(]*)\(bot\)(,?) *`)
var aliasRegex = regexp.MustCompile(`^\(alias\) *`)

func (r Robot) formatHelpLine(input string) (ret string) {
	botName := r.cfg.botinfo.UserName
	botAlias := string(r.cfg.alias)
	if len(botName) == 0 && len(botAlias) == 0 {
		ret = input
	} else {
		if botRegex.MatchString(input) {
			if len(botName) > 0 {
				ret = botRegex.ReplaceAllString(input, "${1}"+botName+"${2} ")
				r.Log(robot.Debug, "Sending '%s' to FormatHelp", ret)
			} else {
				ret = botRegex.ReplaceAllString(input, botAlias)
			}
		} else if aliasRegex.MatchString(input) {
			if len(botAlias) > 0 {
				ret = aliasRegex.ReplaceAllString(input, botAlias)
			} else {
				ret = aliasRegex.ReplaceAllString(input, botName+", ")
			}
		}
	}
	return interfaces.FormatHelp(ret)
}

func help(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	if command == "init" {
		return // ignore init
	}
	if command == "info" {
		admins := strings.Join(r.cfg.adminUsers, ", ")
		aliasCh := r.cfg.alias
		name := r.cfg.botinfo.UserName
		if len(name) == 0 {
			name = "(unknown)"
		}
		ID := r.cfg.botinfo.UserID
		if len(ID) == 0 {
			ID = "(unknown)"
		}
		var alias string
		if aliasCh == 0 {
			alias = "(not set)"
		} else {
			alias = string(aliasCh)
		}
		channelID, _ := handle.ExtractID(r.ProtocolChannel)
		msg := make([]string, 0, 7)
		msg = append(msg, "Here's some information about me and my running environment:")
		msg = append(msg, fmt.Sprintf("The hostname for the server I'm running on is: %s", hostName))
		msg = append(msg, fmt.Sprintf("My name is '%s', alias '%s', and my %s internal ID is '%s'", name, alias, r.Protocol, ID))
		msg = append(msg, fmt.Sprintf("This is channel '%s', %s internal ID: %s", r.Channel, r.Protocol, channelID))
		if r.CheckAdmin() {
			msg = append(msg, fmt.Sprintf("The gopherbot install directory is: %s", installPath))
			msg = append(msg, fmt.Sprintf("My home directory ($GOPHER_HOME) is: %s", homePath))
			if custom, ok := os.LookupEnv("GOPHER_CUSTOM_REPOSITORY"); ok {
				msg = append(msg, fmt.Sprintf("My git repository is: %s", custom))
			}
		}
		msg = append(msg, fmt.Sprintf("My software version is: Gopherbot %s, commit: %s", botVersion.Version, botVersion.Commit))
		msg = append(msg, fmt.Sprintf("The administrators for this robot are: %s", admins))
		adminContact := r.GetBotAttribute("contact")
		if len(adminContact.Attribute) > 0 {
			msg = append(msg, fmt.Sprintf("The administrative contact for this robot is: %s", adminContact))
		}
		r.MessageFormat(robot.Variable).SayThread(strings.Join(msg, "\n"))
	}
	if command == "help" || command == "help-all" {
		tasks := r.tasks
		var term, helpOutput string
		hasKeyword := false
		lineSeparator := "\n\n"

		if len(args) == 1 && len(args[0]) > 0 {
			hasKeyword = true
			term = args[0]
			Log(robot.Trace, "Help requested for term '%s'", term)
		}

		// Nothing we need will ever change for a worker.
		w := getLockedWorker(r.tid)
		w.Unlock()
		helpLines := make([]string, 0, 14)
		if command == "help" {
			if !hasKeyword {
				defaultHelpLines := interfaces.DefaultHelp()
				if len(defaultHelpLines) == 0 {
					defaultHelpLines = defaultHelp()
				}
				for _, line := range defaultHelpLines {
					helpLines = append(helpLines, r.formatHelpLine(line))
				}
			}
		}
		want_specific := command == "help" || hasKeyword
		for _, t := range tasks.t[1:] {
			task, plugin, _ := getTask(t)
			if plugin == nil {
				continue
			}
			// If a keyword was supplied, give help for all matching commands with channels;
			// without a keyword, show help for all commands available in the channel.
			available, specific := w.pluginAvailable(task, hasKeyword, true)
			if !available {
				continue
			}
			if want_specific && !specific {
				continue
			}
			Log(robot.Trace, "Checking help for plugin %s (term: %s)", task.name, term)
			if !hasKeyword { // if you ask for help without a term, you just get help for whatever commands are available to you
				for _, phelp := range plugin.Help {
					for _, helptext := range phelp.Helptext {
						if len(phelp.Keywords) > 0 && phelp.Keywords[0] == "*" {
							// * signifies help that should be prepended
							prepend := make([]string, 1, len(helpLines)+1)
							prepend[0] = r.formatHelpLine(helptext)
							helpLines = append(prepend, helpLines...)
						} else {
							helpLines = append(helpLines, r.formatHelpLine(helptext))
						}
					}
				}
			} else { // when there's a search term, give all help for that term, but add (channels: xxx) at the end
				for _, phelp := range plugin.Help {
					for _, keyword := range phelp.Keywords {
						if term == keyword {
							chantext := ""
							if task.DirectOnly {
								// Look: the right paren gets added below
								chantext = " (direct message only"
							} else {
								if len(task.Channels) > tooManyChannels {
									chantext += " (channels: (many) "
								} else {
									for _, pchan := range task.Channels {
										if len(chantext) == 0 {
											chantext += " (channels: " + pchan
										} else {
											chantext += ", " + pchan
										}
									}
								}
							}
							if len(chantext) != 0 {
								chantext += ")"
							}
							for _, helptext := range phelp.Helptext {
								helpLines = append(helpLines, r.formatHelpLine(helptext)+chantext)
							}
						}
					}
				}
			}
		}
		if len(helpLines) == 0 {
			// Unless builtins are disabled or reconfigured, 'ping' is available in all channels
			if r.Incoming.ThreadedMessage {
				r.Reply("Sorry, I didn't find any commands matching your keyword")
			} else {
				r.SayThread("Sorry, I didn't find any commands matching your keyword")
			}
		} else {
			if hasKeyword {
				helpOutput = "Command(s) matching keyword: " + term + "\n" + strings.Join(helpLines, lineSeparator)
			} else {
				helpOutput = "Command(s) available in this channel:\n" + strings.Join(helpLines, lineSeparator)
			}
			if r.Incoming.ThreadedMessage {
				r.Reply(helpOutput)
			} else {
				r.SayThread(helpOutput)
			}
		}
	}
	return
}

func dmadmin(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	if command == "init" {
		return // ignore init
	}
	switch command {
	case "dumprobot":
		if r.Protocol != robot.Terminal && r.Protocol != robot.Test {
			r.Say("This command is only valid with the 'terminal' connector")
			return
		}
		confLock.RLock()
		c, _ := yaml.Marshal(config)
		confLock.RUnlock()
		r.Fixed().Say("Here's how I've been configured, irrespective of interactive changes:\n%s", c)
	case "dumpplugdefault":
		if plug, ok := pluginHandlers[args[0]]; ok {
			r.Fixed().Say("Here's the default configuration for \"%s\":\n%s", args[0], plug.DefaultConfig)
		} else { // look for an external plugin
			found := false
			for _, t := range r.tasks.t[1:] {
				task, plugin, _ := getTask(t)
				if args[0] == task.name {
					if plugin == nil {
						r.Say("No default configuration available for task type 'job'")
						return
					}
					if plugin.taskType == taskExternal {
						found = true
						if cfg, err := getExtDefCfg(plugin.Task); err == nil {
							r.Fixed().Say("Here's the default configuration for \"%s\":\n%s", args[0], *cfg)
						} else {
							r.Say("I had a problem looking that up - somebody should check my logs")
						}
					}
				}
			}
			if !found {
				r.Say("Didn't find a plugin named " + args[0])
			}
		}
	case "dumpplugin":
		if r.Protocol != robot.Terminal && r.Protocol != robot.Test {
			r.Say("This command is only valid with the 'terminal' connector")
			return
		}
		found := false
		for _, t := range r.tasks.t[1:] {
			task, plugin, _ := getTask(t)
			if args[0] == task.name {
				if plugin == nil {
					r.Say("Task '%s' is a job, not a plugin", task.name)
					return
				}
				found = true
				c, _ := yaml.Marshal(plugin)
				r.Fixed().Say("%s", c)
			}
		}
		if !found {
			r.Say("Didn't find a plugin named " + args[0])
		}
	case "listplugins":
		joiner := ", "
		message := "Here are the plugins I have configured:\n%s"
		wantDisabled := false
		if len(args[0]) > 0 {
			wantDisabled = true
			joiner = "\n"
			message = "Here's a list of all disabled plugins:\n%s"
		}
		plist := make([]string, 0, len(r.tasks.t))
		for _, t := range r.tasks.t[1:] {
			task, plugin, _ := getTask(t)
			if plugin == nil {
				continue
			}
			ptext := task.name
			if wantDisabled {
				if task.Disabled {
					ptext += "; reason: " + task.reason
					plist = append(plist, ptext)
				}
			} else {
				if task.Disabled {
					ptext += " (disabled)"
				}
				plist = append(plist, ptext)
			}
		}
		if len(plist) > 0 {
			r.Say(message, strings.Join(plist, joiner))
		} else { // note because of builtin plugins, plist is ALWAYS > 0 if disabled wasn't specified
			r.Say("There are no disabled plugins")
		}
	}
	return
}

var byebye = []string{
	"Sayonara!",
	"Adios",
	"Hasta la vista!",
	"Later gator!",
}

var rightback = []string{
	"Back in a flash!",
	"Be right back!",
	"You won't even have time to miss me...",
}

func logging(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	switch command {
	case "init":
		return
	case "level":
		setLogLevel(logStrToLevel(args[0]))
		r.Say("I've adjusted the log level to %s", args[0])
		Log(robot.Info, "User %s changed logging level to %s", r.User, args[0])
	case "show":
		page := 0
		if len(args) == 1 {
			page, _ = strconv.Atoi(args[0])
		}
		lines, wrap := logPage(page)
		if wrap {
			r.Say("(warning: value too large for pages, wrapped past beginning of log)")
		}
		r.Fixed().Say(strings.Join(lines, ""))
	case "showlevel":
		l := getLogLevel()
		r.Say("My current logging level is: %s", logLevelToStr(l))
	case "setlines":
		l, _ := strconv.Atoi(args[0])
		set := setLogPageLines(l)
		r.Say("Lines per page of log output set to: %d", set)
	}
	return
}

type psList struct {
	pslines []string
	wids    []int
}

func (p *psList) Len() int {
	return len(p.pslines)
}

func (p *psList) Swap(i, j int) {
	p.pslines[i], p.pslines[j] = p.pslines[j], p.pslines[i]
	p.wids[i], p.wids[j] = p.wids[j], p.wids[i]
}

func (p *psList) Less(i, j int) bool {
	return p.wids[i] < p.wids[j]
}

func admin(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	if command == "init" {
		return // ignore init
	}
	r := m.(Robot)
	switch command {
	case "reload":
		err := loadConfig(false)
		if err != nil {
			r.Reply("Error encountered during reload:")
			r.Fixed().Say("%v", err)
			Log(robot.Error, "Reloading configuration, requested by %s: %v", r.User, err)
			return
		}
		r.Reply("Configuration reloaded successfully")
		r.Log(robot.Info, "Configuration successfully reloaded by a request from: %s", r.User)
	case "abort":
		buf := make([]byte, 32768)
		runtime.Stack(buf, true)
		log.Printf("%s", buf)
		time.Sleep(2 * time.Second)
		panic("Abort command issued")
	case "ps":
		// wid pwid pid Go|Ext plugin|task|job
		psl := &psList{
			pslines: []string{
				"WID    PWID  PID   G/E TYPE   PIPENAME         TASK             PLUG-COMMAND ARGS",
			},
			wids: []int{-1},
		}
		activePipelines.Lock()
		if len(activePipelines.i) == 1 {
			activePipelines.Unlock()
			r.Say("No pipelines running")
			return
		}
		for widx, worker := range activePipelines.i {
			pipename := worker.pipeName
			worker.Lock()
			wid := strconv.Itoa(widx)
			pwid := ""
			if worker._parent != nil {
				pwid = strconv.Itoa(worker._parent.id)
			}
			pid := ""
			if worker.osCmd != nil {
				pid = strconv.Itoa(worker.osCmd.Process.Pid)
				wid = wid + "*"
			}
			class := worker.taskClass
			ttype := worker.taskType
			tname := worker.taskName
			command := worker.plugCommand
			args := strings.Join(worker.taskArgs, " ")
			worker.Unlock()
			if pipename == "builtin-admin" && command == "ps" {
				continue
			}
			psline := fmt.Sprintf("%6.6s %5.5s %5.5s %-3.3s %-6.6s %-16.16s %-16.16s %-12.12s %s", wid, pwid, pid, class, ttype, pipename, tname, command, args)
			psl.pslines = append(psl.pslines, psline)
			psl.wids = append(psl.wids, widx)
		}
		activePipelines.Unlock()
		sort.Sort(psl)
		r.Fixed().Say(strings.Join(psl.pslines, "\n"))
	case "kill":
		wid := args[0]
		widx, err := strconv.ParseInt(wid, 10, 0)
		if err != nil {
			r.Say("Couldn't convert '%s' to an int", wid)
			return
		}
		activePipelines.Lock()
		worker, ok := activePipelines.i[int(widx)]
		activePipelines.Unlock()
		if !ok {
			r.Say("Pipeline %s not found", wid)
			return
		}
		var pid int
		worker.Lock()
		if worker.osCmd != nil {
			pid = worker.osCmd.Process.Pid
		}
		worker.Unlock()
		if pid == 0 {
			r.Say("No active process found for pipeline")
			return
		}
		raiseThreadPriv(fmt.Sprintf("killing process %d", pid))
		unix.Kill(-pid, unix.SIGKILL)
		r.Say("Killed pid %d", pid)
	case "pause":
		name := args[0]
		notfound := "I don't have a job configured with that name"
		t := r.tasks.getTaskByName(name)
		if t == nil {
			r.Say(notfound)
			return
		}
		_, _, job := getTask(t)
		if job == nil {
			r.Say(notfound)
			return
		}
		pausedJobs.Lock()
		defer pausedJobs.Unlock()
		_, ok := pausedJobs.jobs[name]
		if ok {
			r.Say("That job has already been paused")
			return
		}
		m := r.GetMessage()
		pausedJobs.jobs[name] = m.User
		r.Say("Ok, I'll stop running '%s' as a scheduled task", name)
		return
	case "resume":
		name := args[0]
		t := r.tasks.getTaskByName(name)
		_, _, job := getTask(t)
		if job == nil {
			r.Say("I don't have a job configured with that name")
		}
		pausedJobs.Lock()
		defer pausedJobs.Unlock()
		_, ok := pausedJobs.jobs[name]
		if !ok {
			r.Say("That job isn't paused")
			return
		}
		delete(pausedJobs.jobs, name)
		r.Say("Ok, I'll resume running '%s' as a scheduled task", name)
		return
	case "pauselist":
		pausedJobs.Lock()
		defer pausedJobs.Unlock()
		if len(pausedJobs.jobs) == 0 {
			r.Say("There are no paused jobs")
			return
		}
		jl := make([]string, 0, len(pausedJobs.jobs))
		for job := range pausedJobs.jobs {
			jl = append(jl, job)
		}
		sort.Strings(jl)
		r.Say("These jobs are paused: %s", strings.Join(jl, ", "))
	case "chanlog":
		lchan := r.Channel
		if len(args) > 0 && len(args[0]) > 0 {
			lchan = args[0]
		}
		if len(lchan) == 0 {
			lchan = "dm"
		}
		fname := lchan + "-channel.log"
		cfile, err := os.Create(fname)
		if err != nil {
			r.Say("Sorry, there was a problem creating the log file")
			Log(robot.Error, "Creating '%s': %v", fname, err)
			return
		}
		clog := log.New(cfile, "", log.LstdFlags)
		chanLoggers.Lock()
		chanLoggers.channels[lchan] = clog
		chanLoggers.Unlock()
		r.Say("Ok, I'll start logging all messages in channel '%s' to '%s'", lchan, fname)
	case "stopchanlog":
		chanLoggers.Lock()
		chanLoggers.channels = make(map[string]*log.Logger)
		chanLoggers.Unlock()
		r.Say("Ok, I've stopped all channel logs")
	case "quit", "restart":
		state.Lock()
		if state.shuttingDown {
			state.Unlock()
			Log(robot.Warn, "Received administrator `quit` while shutdown in progress")
			return
		}
		state.shuttingDown = true
		restart := command == "restart"
		if restart {
			state.restart = true
		}
		proto := r.cfg.protocol
		// NOTE: THIS plugin is definitely running, but will end soon!
		if state.pipelinesRunning > 1 {
			runningCount := state.pipelinesRunning - 1
			state.Unlock()
			if proto != "test" {
				r.Say("There are still %d pipelines running; I'll %s when they all complete, or you can issue an \"abort\" command", runningCount, command)
			}
		} else {
			state.Unlock()
			if proto != "test" {
				if restart {
					r.Reply(r.RandomString(rightback))
				} else {
					r.Reply(r.RandomString(byebye))
				}
				// How long does it _actually_ take for the message to go out?
				time.Sleep(time.Second)
			}
		}
		Log(robot.Info, "Exiting on administrator 'quit|restart' command")
		go stop()
	}
	return
}
</file_content file: gopherbot-main/bot/builtins.go>
<preamble file: gopherbot-main/bot/calltask.go>

</preamble>
<file_content file: gopherbot-main/bot/calltask.go>
package bot

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"sync"

	"github.com/lnxjedi/gopherbot/robot"
	"golang.org/x/sys/unix"
)

// Set for the terminal connector
var localTerm bool

// Set for the null connector
var nullConn bool

type getCfgReturn struct {
	buffptr *[]byte
	err     error
}

func getExtDefCfg(task *Task) (*[]byte, error) {
	cc := make(chan getCfgReturn)
	go getExtDefCfgThread(cc, task)
	ret := <-cc
	return ret.buffptr, ret.err
}

func getExtDefCfgThread(cchan chan<- getCfgReturn, task *Task) {
	var taskPath string
	var err error
	var relpath bool
	if taskPath, err = getTaskPath(task, "."); err != nil {
		cchan <- getCfgReturn{nil, err}
		return
	}
	var cfg []byte
	var cmd *exec.Cmd

	// drop privileges when running external task; this thread will terminate
	// when this goroutine finishes; see runtime.LockOSThread()
	dropThreadPriv(fmt.Sprintf("task %s default configuration", task.name))

	Log(robot.Debug, "Calling '%s' with arg: configure", taskPath)
	cmd = exec.Command(taskPath, "configure")
	if relpath {
		cmd.Dir = configPath
	}
	env := []string{
		fmt.Sprintf("GOPHER_INSTALLDIR=%s", installPath),
		fmt.Sprintf("RUBYLIB=%s/lib:%s/custom/lib", installPath, homePath),
		fmt.Sprintf("GEM_HOME=%s/.local", homePath),
		fmt.Sprintf("PYTHONPATH=%s/lib:%s/custom/lib", installPath, homePath),
		fmt.Sprintf("GOPHER_CONFIGDIR=%s", configFull),
		fmt.Sprintf("HOME=%s", homePath),
	}
	for _, p := range envPassThrough {
		if value, ok := os.LookupEnv(p); ok {
			env = append(env, fmt.Sprintf("%s=%s", p, value))
		}
	}
	cmd.Env = env
	cfg, err = cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			err = fmt.Errorf("Problem retrieving default configuration for external plugin '%s', skipping: '%v', output: %s", taskPath, err, exitErr.Stderr)
		} else {
			err = fmt.Errorf("Problem retrieving default configuration for external plugin '%s', skipping: '%v'", taskPath, err)
		}
		cchan <- getCfgReturn{nil, err}
		return
	}
	cchan <- getCfgReturn{&cfg, nil}
	return
}

type taskReturn struct {
	errString string
	retval    robot.TaskRetVal
}

// Maps populated by callTaskThread, so external tasks can get their Robot
// from the eid (GOPHER_CALLER_ID), and Go tasks can get a handle to the
// *worker from an incrementing tid (task id).
var taskLookup = struct {
	e map[string]Robot
	i map[int]*worker
	sync.RWMutex
}{
	make(map[string]Robot),
	make(map[int]*worker),
	sync.RWMutex{},
}

// register a worker for a tid so Go tasks can look up the *worker
func (w *worker) registerWorker(tid int) {
	taskLookup.Lock()
	taskLookup.i[tid] = w
	taskLookup.Unlock()
}

// deregister the worker when done
func deregisterWorker(tid int) {
	taskLookup.Lock()
	delete(taskLookup.i, tid)
	taskLookup.Unlock()
}

// function for active Go Robots to look up the *worker, always locked
// before returning. Note that we always pass a Robot.tid instead of making
// this a method on the Robot, since copying the whole robot for a single
// int is senseless.
func getLockedWorker(idx int) *worker {
	if idx == 0 { // illegal value
		_, file, line, _ := runtime.Caller(1)
		Log(robot.Error, "Illegal call to getLockedWorker with tid = 0 in '%s', line %d", file, line)
		return nil
	}
	taskLookup.RLock()
	w, ok := taskLookup.i[idx]
	taskLookup.RUnlock()
	if !ok {
		_, file, line, _ := runtime.Caller(2)
		Log(robot.Error, "Illegal call to getLockedWorker for inactive worker in '%s', line %d", file, line)
		return nil
	}
	w.Lock()
	return w
}

// callTask does the work of running a job, task or plugin with a command and
// arguments. Note that callTask(Thread) has to concern itself with locking of
// the worker because it can be called within a task by the Elevate() method.
func (w *worker) callTask(t interface{}, command string, args ...string) (errString string, retval robot.TaskRetVal) {
	rc := make(chan taskReturn)
	go w.callTaskThread(rc, t, command, args...)
	ret := <-rc
	return ret.errString, ret.retval
}

func (w *worker) callTaskThread(rchan chan<- taskReturn, t interface{}, command string, args ...string) {
	var errString string
	var retval robot.TaskRetVal
	task, plugin, job := getTask(t)
	isPlugin := plugin != nil
	isJob := job != nil
	w.Lock()
	w.currentTask = t
	logger := w.logger
	workdir := w.workingDirectory
	eid := w.eid
	privileged := w.privileged
	w.Unlock()
	r := w.makeRobot()
	// This should only happen in the rare case that a configured authorizer or elevator is disabled
	if task.Disabled {
		msg := fmt.Sprintf("callTask failed on disabled task %s; reason: %s", task.name, task.reason)
		Log(robot.Error, msg)
		rchan <- taskReturn{msg, robot.ConfigurationError}
		return
	}
	var taskinfo string
	if isPlugin {
		taskinfo = task.name + " " + command
	} else {
		taskinfo = task.name
	}
	if len(args) > 0 {
		taskinfo += " " + strings.Join(args, " ")
	}
	var desc string
	if len(task.Description) > 0 {
		desc = fmt.Sprintf("Starting task '%s': %s", task.name, task.Description)
	} else {
		desc = fmt.Sprintf("Starting task '%s'", task.name)
	}
	w.section(taskinfo, desc)

	if !(task.name == "builtin-admin" && command == "abort") {
		if w.Incoming.DirectMessage {
			defer checkPanic(w, fmt.Sprintf("Plugin: %s, command: %s, arguments: (omitted)", task.name, command))
		} else {
			defer checkPanic(w, fmt.Sprintf("Plugin: %s, command: %s, arguments: %v", task.name, command, args))
		}
	}
	if w.Incoming.DirectMessage {
		Log(robot.Debug, "Dispatching command '%s' to task '%s' with arguments '(omitted for DM)'", command, task.name)
	} else {
		Log(robot.Debug, "Dispatching command '%s' to task '%s' with arguments '%#v'", command, task.name, args)
	}

	// Set up the per-task environment, getEnvironment takes lock & releases
	envhash := w.getEnvironment(t)
	r.environment = envhash

	w.registerWorker(r.tid)
	if isPlugin && plugin.taskType == taskGo {
		if command != "init" {
			emit(GoPluginRan)
		}
		Log(robot.Debug, "Calling go plugin: '%s' with args: %q", task.name, args)
		ret := pluginHandlers[task.name].Handler(r, command, args...)
		deregisterWorker(r.tid)
		rchan <- taskReturn{"", ret}
		return
	} else if task.taskType == taskGo {
		Log(robot.Debug, "Calling go task '%s' (type %s) with args: %q", task.name, task.taskType, args)
		var ret robot.TaskRetVal
		if isJob {
			ret = jobHandlers[task.name].Handler(r, args...)
		} else {
			ret = taskHandlers[task.name].Handler(r, args...)
		}
		deregisterWorker(r.tid)
		rchan <- taskReturn{"", ret}
		return
	}

	// Task lookup; add lookup for http.go
	taskLookup.Lock()
	taskLookup.e[eid] = r
	taskLookup.Unlock()
	defer func() {
		taskLookup.Lock()
		delete(taskLookup.e, eid)
		taskLookup.Unlock()
		deregisterWorker(r.tid)
	}()

	var taskPath string // full path to the executable
	var err error
	if task.Homed {
		taskPath, err = getTaskPath(task, ".")
	} else {
		taskPath, err = getTaskPath(task, workdir)
	}
	if err != nil {
		emit(ExternalTaskBadPath)
		rchan <- taskReturn{fmt.Sprintf("Getting path for %s: %v", task.name, err), robot.MechanismFail}
		return
	}
	var externalArgs []string
	// jobs and tasks don't take a 'command' (it's just 'run', a dummy value)
	if isPlugin {
		externalArgs = append(externalArgs, command)
	}
	externalArgs = append(externalArgs, args...)
	Log(robot.Debug, "Calling '%s' with args: %q", taskPath, externalArgs)
	cmd := exec.Command(taskPath, externalArgs...)

	// Homed tasks ALWAYS run in cwd, Homed pipelines may have modified the
	// working directory with SetWorkingDirectory.
	if task.Homed {
		cmd.Dir = "."
	} else {
		cmd.Dir = workdir
	}
	if task.Privileged || task.Homed {
		if task.Privileged && len(homePath) > 0 {
			// May already be provided for a privileged pipeline
			envhash["GOPHER_HOME"] = homePath
		}
		// Always set for homed and privileged tasks
		envhash["GOPHER_WORKSPACE"] = r.cfg.workSpace
		envhash["GOPHER_CONFIGDIR"] = configFull
	}
	env := make([]string, 0, len(envhash))
	keys := make([]string, 0, len(envhash))
	for k, v := range envhash {
		if len(k) == 0 {
			Log(robot.Error, "Empty Name value while populating environment for '%s', skipping", task.name)
			continue
		}
		env = append(env, fmt.Sprintf("%s=%s", k, v))
		keys = append(keys, k)
	}
	cmd.Env = env
	Log(robot.Debug, "Running '%s' in '%s' with environment vars: '%s'", taskPath, cmd.Dir, strings.Join(keys, "', '"))
	var stderr, stdout io.ReadCloser
	// hold on to stderr in case we need to log an error
	stderr, err = cmd.StderrPipe()
	if err != nil {
		Log(robot.Error, "Creating stderr pipe for external command '%s': %v", taskPath, err)
		errString = fmt.Sprintf("Pipeline failed in external task '%s', writing fail log in GOPHER_HOME", task.name)
		rchan <- taskReturn{errString, robot.MechanismFail}
		return
	}
	// Null connector can read from stdin
	if nullConn {
		cmd.Stdin = os.Stdin
	}
	stdout, err = cmd.StdoutPipe()
	if err != nil {
		Log(robot.Error, "Creating stdout pipe for external command '%s': %v", taskPath, err)
		errString = fmt.Sprintf("Pipeline failed in external task '%s', writing fail log in GOPHER_HOME", task.name)
		rchan <- taskReturn{errString, robot.MechanismFail}
		return
	}

	if privileged {
		if isPlugin && !plugin.Privileged {
			dropThreadPriv(fmt.Sprintf("task %s / %s", task.name, command))
		} else {
			raiseThreadPrivExternal(fmt.Sprintf("task %s / %s", task.name, command))
		}
	} else {
		dropThreadPriv(fmt.Sprintf("task %s / %s", task.name, command))
	}

	// Create separate process group to enable killing the process group
	cmd.SysProcAttr = &unix.SysProcAttr{Setpgid: true}
	if err = cmd.Start(); err != nil {
		Log(robot.Error, "Starting command '%s': %v", taskPath, err)
		errString = fmt.Sprintf("Pipeline failed in external task '%s', writing fail log in GOPHER_HOME", task.name)
		rchan <- taskReturn{errString, robot.MechanismFail}
		return
	}
	w.Lock()
	w.osCmd = cmd
	w.Unlock()
	defer func() {
		w.Lock()
		w.osCmd = nil
		w.Unlock()
	}()
	if command != "init" {
		emit(ExternalTaskRan)
	}
	closed := make(chan struct{})
	var solog, selog *log.Logger
	if localTerm {
		solog = log.New(terminalWriter, "OUT: ", 0)
		selog = log.New(terminalWriter, "ERR: ", 0)
	}
	if nullConn {
		solog = log.New(os.Stdout, "", 0)
		selog = log.New(os.Stderr, "ERR: ", 0)
	}
	go func() {
		logging := logger != nil
		scanner := bufio.NewScanner(stdout)
		for scanner.Scan() {
			line := scanner.Text()
			if logging {
				logger.Log("OUT " + line)
			}
			if localTerm || nullConn {
				solog.Println(line)
			}
		}
		closed <- struct{}{}
	}()
	go func() {
		logging := logger != nil
		scanner := bufio.NewScanner(stderr)
		for scanner.Scan() {
			line := scanner.Text()
			if logging {
				logger.Log("ERR " + line)
			}
			if localTerm || nullConn {
				selog.Println(line)
			}
		}
		closed <- struct{}{}
	}()
	halfClosed := false
closeLoop:
	for {
		select {
		case <-closed:
			if halfClosed {
				break closeLoop
			}
			halfClosed = true
		}
	}
	if err = cmd.Wait(); err != nil {
		retval = robot.Fail
		success := false
		if exitstatus, ok := err.(*exec.ExitError); ok {
			if status, ok := exitstatus.Sys().(unix.WaitStatus); ok {
				retval = robot.TaskRetVal(status.ExitStatus())
				if retval == robot.Success {
					success = true
				}
			}
		}
		if !success {
			Log(robot.Error, "Waiting on external command '%s': %v", taskPath, err)
			errString = fmt.Sprintf("Pipeline failed in external task '%s', writing fail log in GOPHER_HOME", task.name)
			emit(ExternalTaskErrExit)
		}
	}
	rchan <- taskReturn{errString, retval}
}
</file_content file: gopherbot-main/bot/calltask.go>
<preamble file: gopherbot-main/bot/cli_commands.go>

</preamble>
<file_content file: gopherbot-main/bot/cli_commands.go>
package bot

import (
	"bytes"
	"encoding/base64"
	"flag"
	"fmt"
	"image/png"
	"io"
	"os"
	"path/filepath"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/pquerna/otp/totp"
)

func processCLI(usage string) {
	cliArgs := flag.Args()
	command := cliArgs[0]

	var fileName string
	var encodeBinary bool
	var encodeBase64 bool

	encFlags := flag.NewFlagSet("encrypt", flag.ExitOnError)
	encFlags.StringVar(&fileName, "file", "", "file to encrypt (or - for stdin)")
	encFlags.StringVar(&fileName, "f", "", "")
	encFlags.BoolVar(&encodeBinary, "binary", false, "binary dump (defauts to base64 encoded)")
	encFlags.BoolVar(&encodeBinary, "b", false, "")
	encFlags.Usage = func() {
		fmt.Println("Usage: gopherbot encrypt [options] [string to encrypt]\n\nOptions:")
		encFlags.PrintDefaults()
	}

	decFlags := flag.NewFlagSet("decrypt", flag.ExitOnError)
	decFlags.StringVar(&fileName, "file", "", "file to decrypt (or - for stdin)")
	decFlags.StringVar(&fileName, "f", "", "")
	decFlags.BoolVar(&encodeBinary, "binary", false, "")
	decFlags.BoolVar(&encodeBinary, "b", false, "")
	decFlags.Usage = func() {
		fmt.Println("Usage: gopherbot decrypt [options] [string to decrypt]\n\nOptions:")
		decFlags.PrintDefaults()
	}

	totpFlags := flag.NewFlagSet("gentotp", flag.ExitOnError)
	totpFlags.Usage = func() {
		fmt.Println("Usage: gopherbot gentotp <username>\n")
	}

	fetchFlags := flag.NewFlagSet("fetch", flag.ExitOnError)
	fetchFlags.BoolVar(&encodeBase64, "base64", false, "encode memory as base64")
	fetchFlags.BoolVar(&encodeBase64, "b", false, "")
	fetchFlags.Usage = func() {
		fmt.Println("Usage: gopherbot fetch [options] <memory to fetch>\n\nOptions:")
		fetchFlags.PrintDefaults()
	}

	switch command {
	case "encrypt":
		encFlags.Parse(cliArgs[1:])
		if len(fileName) == 0 && len(encFlags.Args()) != 1 {
			encFlags.Usage()
			return
		}
		cliEncrypt(encFlags.Arg(0), fileName, encodeBinary)
	case "decrypt":
		decFlags.Parse(cliArgs[1:])
		if len(fileName) == 0 && len(decFlags.Args()) != 1 {
			decFlags.Usage()
			return
		}
		cliDecrypt(decFlags.Arg(0), fileName)
	case "gentotp":
		totpFlags.Parse(cliArgs[1:])
		if len(totpFlags.Args()) == 0 || len(totpFlags.Arg(0)) == 0 {
			totpFlags.Usage()
			return
		}
		cliTOTPgen(totpFlags.Arg(0))
	case "fetch":
		fetchFlags.Parse(cliArgs[1:])
		if len(fetchFlags.Args()) == 0 || len(fetchFlags.Arg(0)) == 0 {
			fetchFlags.Usage()
			return
		}
		cliFetch(fetchFlags.Arg(0), encodeBase64)
	case "init":
		if len(cliArgs) < 2 {
			fmt.Println("Usage: gopherbot init <protocol>")
			return
		}
		if _, err := os.Stat("answerfile.txt"); err == nil {
			fmt.Println("Not over-writing existing 'answerfile.txt'")
			return
		}
		ansFile := filepath.Join(installPath, "resources", "answerfiles", cliArgs[1]+".txt")
		if _, err := os.Stat(ansFile); err != nil {
			fmt.Printf("Protocol answerfile template not found: %s\n", ansFile)
			return
		}
		var ansBytes []byte
		var err error
		if ansBytes, err = os.ReadFile(ansFile); err != nil {
			fmt.Printf("Reading '%s': %v", ansFile, err)
			return
		}
		if err = os.WriteFile("answerfile.txt", ansBytes, 0600); err != nil {
			fmt.Printf("Writing 'answerfile.txt': %v", err)
			return
		}
		if _, err := os.Stat("gopherbot"); err == nil {
			fmt.Println("Edit 'answerfile.txt' and re-run gopherbot with no arguments to generate your robot.")
		} else {
			exeFile := filepath.Join(installPath, "gopherbot")
			err := os.Symlink(exeFile, "gopherbot")
			if err != nil {
				fmt.Println("Unable to create symlink for 'gopherbot'")
				fmt.Println("Edit 'answerfile.txt' and re-run gopherbot with no arguments to generate your robot.")
			} else {
				fmt.Println("Edit 'answerfile.txt' and run './gopherbot' with no arguments to generate your robot.")
			}
		}
	case "store":
		if len(cliArgs) < 2 {
			fmt.Println("Usage: gopherbot store <key> [filename]")
			return
		}
		file := "-"
		if len(cliArgs) == 3 {
			file = cliArgs[2]
		}
		cliStore(cliArgs[1], file)
	case "list":
		cliList()
	case "delete":
		if len(cliArgs) != 2 {
			fmt.Println("Usage: gopherbot delete <key>")
			return
		}
		cliDelete(cliArgs[1])
	case "version":
		fmt.Printf("Version %s, commit: %s\n", botVersion.Version, botVersion.Commit)
	default:
		fmt.Printf("Invalid command/option(s): %s, %q\n", cliArgs[0], cliArgs[1:])
		fmt.Println(usage)
		flag.PrintDefaults()
	}
}

func cliTOTPgen(user string) {
	if !cryptKey.initialized {
		fmt.Println("Encryption not initialized")
		os.Exit(1)
	}
	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      currentCfg.botinfo.FullName,
		AccountName: user,
	})
	if err != nil {
		fmt.Printf("Error generating TOTP: %v\n", err)
		os.Exit(1)
	}
	secStr := key.Secret()
	fmt.Printf("Secret for %s: %s\n", user, secStr)
	ct, err := encrypt([]byte(secStr), cryptKey.key)
	if err != nil {
		fmt.Printf("Error encrypting: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Encrypted secret for config: \"%s\": \"{{ decrypt \"%s\" }}\"\n", user, base64.StdEncoding.EncodeToString(ct))
	var buf bytes.Buffer
	img, imgerr := key.Image(400, 400)
	if imgerr != nil {
		fmt.Printf("Error generating image: %v\n", imgerr)
		os.Exit(1)
	}
	png.Encode(&buf, img)
	ferr := os.WriteFile(fmt.Sprintf("%s.png", user), buf.Bytes(), 0644)
	if ferr != nil {
		fmt.Printf("Error writing '%s.png': %v\n", user, imgerr)
		os.Exit(1)
	}
	fmt.Printf("Wrote '%s.png'\n", user)
}

func cliEncrypt(item, file string, binary bool) {
	if !cryptKey.initialized {
		fmt.Println("Encryption not initialized")
		os.Exit(1)
	}
	if len(file) > 0 {
		var fc []byte
		var err error
		if file == "-" {
			fc, err = io.ReadAll(os.Stdin)
		} else {
			fc, err = os.ReadFile(file)
		}
		if err != nil {
			fmt.Printf("Error reading file: %v\n", err)
			os.Exit(1)
		}
		ct, err := encrypt(fc, cryptKey.key)
		if err != nil {
			fmt.Printf("Error encrypting: %v\n", err)
			os.Exit(1)
		}
		if binary {
			os.Stdout.Write(ct)
		} else {
			WriteBase64(os.Stdout, &ct)
		}
		return
	}
	if len(item) > 0 {
		ct, err := encrypt([]byte(item), cryptKey.key)
		if err != nil {
			fmt.Printf("Error encrypting: %v\n", err)
			os.Exit(1)
		}
		if binary {
			os.Stdout.Write(ct)
		} else {
			fmt.Println(base64.StdEncoding.EncodeToString(ct))
		}
		return
	}
	os.Stderr.Write([]byte("Ingoring zero-length item\n"))
	os.Exit(1)
}

func cliDecrypt(item, file string) {
	if !cryptKey.initialized {
		fmt.Println("Encryption not initialized")
		os.Exit(1)
	}
	if len(file) > 0 {
		var ct *[]byte
		var err error
		if file == "-" {
			ct, err = ReadBinary(os.Stdin)
		} else {
			ct, err = ReadBinaryFile(file)
		}
		if err != nil {
			fmt.Printf("Error reading file: %v\n", err)
			os.Exit(1)
		}
		pt, err := decrypt(*ct, cryptKey.key)
		if err != nil {
			fmt.Printf("Error decrypting: %v\n", err)
		}
		os.Stdout.Write(pt)
		return
	}
	if len(item) > 0 {
		eb, err := base64.StdEncoding.DecodeString(item)
		if err != nil {
			fmt.Printf("Decoding base64: %v\n", err)
			os.Exit(1)
		}
		value, err := decrypt(eb, cryptKey.key)
		if err != nil {
			fmt.Printf("Error decrypting: %v\n", err)
			os.Exit(1)
		}
		fmt.Println(string(value))
		return
	}
	os.Stderr.Write([]byte("Ingoring zero-length item\n"))
	os.Exit(1)
}

func cliFetch(item string, b64 bool) {
	_, datum, exists, ret := getDatum(item, false)
	if ret != robot.Ok {
		fmt.Printf("Retrieving datum: %v\n", ret)
		os.Exit(1)
	}
	if !exists {
		fmt.Println("Item not found")
		os.Exit(1)
	}
	if b64 {
		encoder := base64.NewEncoder(base64.StdEncoding, os.Stdout)
		encoder.Write(*datum)
		os.Stdout.Write([]byte("\n"))
		return
	}
	os.Stdout.Write(*datum)
	os.Stdout.Write([]byte("\n"))
}

func cliStore(key, file string) {
	var fc []byte
	var err error
	if file == "-" {
		fc, err = io.ReadAll(os.Stdin)
	} else {
		fc, err = os.ReadFile(file)
	}
	if err != nil {
		fmt.Printf("Error reading file: %v\n", err)
		os.Exit(1)
	}
	tok, _, _, ret := checkout(key, true)
	if ret != robot.Ok {
		fmt.Printf("Getting token: %s\n", ret)
		return
	}
	ret = update(key, tok, &fc)
	if ret != robot.Ok {
		fmt.Printf("Storing datum: %s\n", ret)
		return
	}
	fmt.Println("Stored")
}

func cliList() {
	brain := interfaces.brain
	list, err := brain.List()
	if err != nil {
		fmt.Printf("Listing memories: %v\n", err)
		return
	}
	if len(list) > 0 {
		for _, memory := range list {
			fmt.Println(memory)
		}
		return
	}
	fmt.Println("No memories found")
}

func cliDelete(key string) {
	brain := interfaces.brain
	err := brain.Delete(key)
	if err != nil {
		fmt.Printf("Deleting memory: %v\n", err)
		return
	}
	fmt.Println("Deleted")
}
</file_content file: gopherbot-main/bot/cli_commands.go>
<preamble file: gopherbot-main/bot/cli_dump.go>

</preamble>
<file_content file: gopherbot-main/bot/cli_dump.go>
package bot

import (
	"fmt"
	"os"
	"path/filepath"
)

// Dump and expanded, but not parsed, configuration file - for troubleshooting yaml errors
func cliDump(which, file string) {
	var base string
	var custom bool
	switch which {
	case "installed":
		base = installPath
	case "configured":
		custom = true
		base = configPath
	}
	cfgfile := filepath.Join(base, "conf", file)
	raw, err := os.ReadFile(cfgfile)
	if err != nil {
		fmt.Printf("Reading '%s': %v\n", cfgfile, err)
		os.Exit(1)
	}
	dir := filepath.Dir(filepath.Join("conf", file))
	expanded, err := expand(dir, custom, raw)
	if err != nil {
		fmt.Printf("Expanding '%s': %v\n", cfgfile, err)
		os.Exit(1)
	}
	fmt.Println(string(expanded))
	os.Exit(0)
}
</file_content file: gopherbot-main/bot/cli_dump.go>
<preamble file: gopherbot-main/bot/conf.go>

</preamble>
<file_content file: gopherbot-main/bot/conf.go>
package bot

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"
	"unicode/utf8"

	"github.com/lnxjedi/gopherbot/robot"
)

/* conf.go - methods and types for reading and storing json configuration */

var protocolConfig, brainConfig, historyConfig json.RawMessage

var robotConfigFileName = "robot.yaml"

// ConfigLoader defines 'bot configuration, and is read from conf/robot.yaml
// Digested content ends up in currentCfg, see bot_process.go.
type ConfigLoader struct {
	AdminContact         string                  // Contact info for whomever administers the robot
	MailConfig           botMailer               // configuration for sending email
	Protocol             string                  // Name of the connector protocol to use, e.g. "slack"
	ProtocolConfig       json.RawMessage         // Protocol-specific configuration, type for unmarshalling arbitrary config
	BotInfo              *UserInfo               // Information about the robot
	UserRoster           []UserInfo              // List of users and related attributes
	ChannelRoster        []ChannelInfo           // List of channels mapping names to IDs
	Brain                string                  // Type of Brain to use
	BrainConfig          json.RawMessage         // Brain-specific configuration, type for unmarshalling arbitrary config
	EncryptBrain         bool                    // Whether the brain should be encrypted
	EncryptionKey        string                  // used to decrypt the "real" encryption key
	HistoryProvider      string                  // Name of provider to use for storing and retrieving job/plugin histories
	HistoryConfig        json.RawMessage         // History provider specific configuration
	WorkSpace            string                  // Read/Write area the robot uses to do work
	DefaultElevator      string                  // Elevator plugin to use by default for ElevatedCommands and ElevateImmediateCommands
	DefaultAuthorizer    string                  // Authorizer plugin to use by default for AuthorizedCommands, or when AuthorizeAllCommands = true
	DefaultMessageFormat string                  // How the robot should format outgoing messages unless told otherwise; default: Raw
	DefaultAllowDirect   bool                    // Whether plugins are available in a DM by default
	IgnoreUnlistedUsers  bool                    // Drop all messages from id not in the UserRoster
	DefaultChannels      []string                // Channels where plugins are active by default, e.g. [ "general", "random" ]
	IgnoreUsers          []string                // Users the 'bot never talks to - like other bots
	JoinChannels         []string                // Channels the 'bot should join when it logs in (not supported by all protocols)
	DefaultJobChannel    string                  // Where job status is posted by default
	TimeZone             string                  // For evaluating the hour in a job schedule
	ExternalJobs         map[string]TaskSettings // list of available jobs; config in conf/jobs/<jobname>.yaml
	ExternalPlugins      map[string]TaskSettings // List of non-Go plugins to load; config in conf/plugins/<plugname>.yaml
	ExternalTasks        map[string]TaskSettings // List executables that can be added to a pipeline (but can't start one)
	GoJobs               map[string]TaskSettings // settings for go jobs; config in conf/jobs/<jobname>.yaml
	GoPlugins            map[string]TaskSettings // settings for go plugins; config in conf/plugins/<plugname>.yaml
	GoTasks              map[string]TaskSettings // settings for go tasks
	NameSpaces           map[string]TaskSettings // namespaces for shared parameters & memory sharing
	ParameterSets        map[string]TaskSettings // named sets of parameters, for stuff like GITHUB_TOKEN used multiple places
	ScheduledJobs        []ScheduledTask         // see tasks.go
	AdminUsers           []string                // List of users who can access administrative commands
	Alias                string                  // One-character alias for commands directed at the 'bot, e.g. ';open the pod bay doors'
	LocalPort            int                     // Port number for listening on localhost, for CLI plugins
	LogLevel             string                  // Initial log level, can be modified by plugins. One of "trace" "debug" "info" "warn" "error"
}

// UserInfo is listed in the UserRoster of robot.yaml to provide:
// - Attributes and info that might not be provided by the connector:
//   - Mapping of protocol internal ID to username
//   - Additional user attributes such as first / last name, email, etc.
//
// - Additional information needed by bot internals
//   - BotUser flag
type UserInfo struct {
	UserName            string // name that refers to the user in bot config files
	UserID              string // unique/persistent ID given to the user by the connector
	Email, Phone        string // for Get*Attribute()
	FullName            string // for Get*Attribute()
	FirstName, LastName string // for Get*Attribute()
	protoMention        string // robot only, @(mention) string
	BotUser             bool   // these users aren't checked against MessageMatchers / ambient messages, and never fall-through to "catchalls"
}

// ChannelInfo maps channel IDs to channel names when the connector doesn't
// provide a sensible name for use in configuration files.
type ChannelInfo struct {
	ChannelName, ChannelID string // human-readable and protocol-internal channel representations
}

type userChanMaps struct {
	userID    map[string]*UserInfo    // Current map of userID to UserInfo struct
	user      map[string]*UserInfo    // Current map of username to UserInfo struct
	channelID map[string]*ChannelInfo // Current map of channel ID to ChannelInfo struct
	channel   map[string]*ChannelInfo // Current map of channel name to ChannelInfo struct
}

var currentUCMaps = struct {
	ucmap *userChanMaps // pointer to current struct
	sync.Mutex
}{
	nil,
	sync.Mutex{},
}

// Protects the bot config and list of repositories
var confLock sync.RWMutex
var config *ConfigLoader
var repositories map[string]robot.Repository

// loadConfig loads the 'bot's yaml configuration files.
func loadConfig(preConnect bool) error {
	raiseThreadPriv("loading configuration")
	var loglevel robot.LogLevel
	if preConnect {
		Log(robot.Info, "Loading initial pre-connection configuration")
	} else {
		Log(robot.Info, "Loading full post-connect configuration")
	}
	newconfig := &ConfigLoader{}
	newconfig.ExternalJobs = make(map[string]TaskSettings)
	newconfig.ExternalPlugins = make(map[string]TaskSettings)
	newconfig.ExternalTasks = make(map[string]TaskSettings)
	configload := make(map[string]json.RawMessage)
	processed := &configuration{}

	if err := getConfigFile(robotConfigFileName, true, configload); err != nil {
		return fmt.Errorf("Loading configuration file: %v", err)
	}

	reporaw := make(map[string]json.RawMessage)
	getConfigFile("repositories.yaml", false, reporaw)
	repolist := make(map[string]robot.Repository)
	for k, repojson := range reporaw {
		if strings.ContainsRune(k, ':') {
			Log(robot.Error, "Invalid repository '%s' contains ':', ignoring", k)
		} else {
			var repository robot.Repository
			json.Unmarshal(repojson, &repository)
			repolist[k] = repository
		}
	}

	explicitDefaultAllowDirect := false

	for key, value := range configload {
		var strval string
		var sarrval []string
		var urval []UserInfo
		var bival *UserInfo
		var crval []ChannelInfo
		var tval map[string]TaskSettings
		var stval []ScheduledTask
		var mailval botMailer
		var boolval bool
		var intval int
		var val interface{}
		skip := false
		switch key {
		case "AdminContact", "Email", "Protocol", "Brain", "EncryptionKey", "HistoryProvider", "WorkSpace", "DefaultJobChannel", "DefaultElevator", "DefaultAuthorizer", "DefaultMessageFormat", "Name", "Alias", "LogLevel", "TimeZone":
			val = &strval
		case "DefaultAllowDirect", "EncryptBrain", "IgnoreUnlistedUsers":
			val = &boolval
		case "BotInfo":
			val = &bival
		case "UserRoster":
			val = &urval
		case "ChannelRoster":
			val = &crval
		case "LocalPort":
			val = &intval
		case "ExternalJobs", "ExternalPlugins", "ExternalTasks", "GoJobs", "GoPlugins", "GoTasks", "NameSpaces", "ParameterSets":
			val = &tval
		case "ScheduledJobs":
			val = &stval
		case "DefaultChannels", "IgnoreUsers", "JoinChannels", "AdminUsers":
			val = &sarrval
		case "MailConfig":
			val = &mailval
		case "ProtocolConfig", "BrainConfig", "HistoryConfig":
			skip = true
		default:
			err := fmt.Errorf("Invalid configuration key in %s: %s", robotConfigFileName, key)
			Log(robot.Error, err.Error())
			return err
		}
		if !skip {
			if err := json.Unmarshal(value, val); err != nil {
				err = fmt.Errorf("Unmarshalling bot config value \"%s\": %v", key, err)
				Log(robot.Error, err.Error())
				return err
			}
		}
		switch key {
		case "AdminContact":
			newconfig.AdminContact = *(val.(*string))
		case "BotInfo":
			newconfig.BotInfo = *(val.(**UserInfo))
		case "MailConfig":
			newconfig.MailConfig = *(val.(*botMailer))
		case "Protocol":
			newconfig.Protocol = *(val.(*string))
		case "ProtocolConfig":
			newconfig.ProtocolConfig = value
		case "Brain":
			newconfig.Brain = *(val.(*string))
		case "EncryptionKey":
			newconfig.EncryptionKey = *(val.(*string))
		case "BrainConfig":
			newconfig.BrainConfig = value
		case "HistoryProvider":
			newconfig.HistoryProvider = *(val.(*string))
		case "HistoryConfig":
			newconfig.HistoryConfig = value
		case "WorkSpace":
			newconfig.WorkSpace = *(val.(*string))
		case "DefaultJobChannel":
			newconfig.DefaultJobChannel = *(val.(*string))
		case "DefaultElevator":
			newconfig.DefaultElevator = *(val.(*string))
		case "DefaultAuthorizer":
			newconfig.DefaultAuthorizer = *(val.(*string))
		case "DefaultMessageFormat":
			newconfig.DefaultMessageFormat = *(val.(*string))
		case "UserRoster":
			newconfig.UserRoster = *(val.(*[]UserInfo))
		case "ChannelRoster":
			newconfig.ChannelRoster = *(val.(*[]ChannelInfo))
		case "DefaultAllowDirect":
			newconfig.DefaultAllowDirect = *(val.(*bool))
			explicitDefaultAllowDirect = true
		case "DefaultChannels":
			newconfig.DefaultChannels = *(val.(*[]string))
		case "IgnoreUsers":
			newconfig.IgnoreUsers = *(val.(*[]string))
		case "JoinChannels":
			newconfig.JoinChannels = *(val.(*[]string))
		case "EncryptBrain":
			newconfig.EncryptBrain = *(val.(*bool))
		case "IgnoreUnlistedUsers":
			newconfig.IgnoreUnlistedUsers = *(val.(*bool))
		case "ExternalPlugins":
			newconfig.ExternalPlugins = *(val.(*map[string]TaskSettings))
		case "ExternalJobs":
			newconfig.ExternalJobs = *(val.(*map[string]TaskSettings))
		case "ExternalTasks":
			newconfig.ExternalTasks = *(val.(*map[string]TaskSettings))
		case "GoPlugins":
			newconfig.GoPlugins = *(val.(*map[string]TaskSettings))
		case "GoJobs":
			newconfig.GoJobs = *(val.(*map[string]TaskSettings))
		case "GoTasks":
			newconfig.GoTasks = *(val.(*map[string]TaskSettings))
		case "NameSpaces":
			newconfig.NameSpaces = *(val.(*map[string]TaskSettings))
		case "ParameterSets":
			newconfig.ParameterSets = *(val.(*map[string]TaskSettings))
		case "ScheduledJobs":
			newconfig.ScheduledJobs = *(val.(*[]ScheduledTask))
		case "AdminUsers":
			newconfig.AdminUsers = *(val.(*[]string))
		case "Alias":
			newconfig.Alias = *(val.(*string))
		case "LocalPort":
			newconfig.LocalPort = *(val.(*int))
		case "LogLevel":
			newconfig.LogLevel = *(val.(*string))
		case "TimeZone":
			newconfig.TimeZone = *(val.(*string))
		}
	}

	// Leave loglevel at Warn for CLI operations
	if !cliOp {
		loglevel = logStrToLevel(newconfig.LogLevel)
		setLogLevel(loglevel)
	}

	processed.ignoreUnlistedUsers = newconfig.IgnoreUnlistedUsers
	if newconfig.Protocol != "" {
		processed.protocol = newconfig.Protocol
	} else {
		return fmt.Errorf("Protocol not specified in %s", robotConfigFileName)
	}
	if newconfig.Brain != "" {
		processed.brainProvider = newconfig.Brain
	}
	if newconfig.BrainConfig != nil {
		brainConfig = newconfig.BrainConfig
	}
	if newconfig.HistoryProvider != "" {
		processed.historyProvider = newconfig.HistoryProvider
	}
	if newconfig.HistoryConfig != nil {
		historyConfig = newconfig.HistoryConfig
	}

	if newconfig.Alias != "" {
		alias, _ := utf8.DecodeRuneInString(newconfig.Alias)
		if !strings.ContainsRune(string(aliases+escapeAliases), alias) {
			return fmt.Errorf("Invalid alias specified, ignoring. Must be one of: %s%s", escapeAliases, aliases)
		}
		processed.alias = alias
	}

	if len(newconfig.DefaultMessageFormat) == 0 {
		processed.defaultMessageFormat = robot.Raw
	} else {
		processed.defaultMessageFormat = setFormat(newconfig.DefaultMessageFormat)
	}

	if explicitDefaultAllowDirect {
		processed.defaultAllowDirect = newconfig.DefaultAllowDirect
	} else {
		processed.defaultAllowDirect = true // rare case of defaulting to true
	}

	if newconfig.AdminContact != "" {
		processed.adminContact = newconfig.AdminContact
	}

	if newconfig.TimeZone != "" {
		tz, err := time.LoadLocation(newconfig.TimeZone)
		if err == nil {
			Log(robot.Info, "Set timezone: %s", tz)
			processed.timeZone = tz
		} else {
			Log(robot.Error, "Parsing time zone '%s', using local time; error: %v", newconfig.TimeZone, err)
			processed.timeZone = nil
		}
	}

	if newconfig.BotInfo != nil {
		// Note that connector-supplied values are copied
		// when processed becomes current.
		processed.botinfo = *newconfig.BotInfo
	}
	processed.mailConf = newconfig.MailConfig

	if newconfig.DefaultJobChannel != "" {
		processed.defaultJobChannel = newconfig.DefaultJobChannel
	}

	if newconfig.DefaultElevator != "" {
		processed.defaultElevator = newconfig.DefaultElevator
	}

	if newconfig.DefaultAuthorizer != "" {
		processed.defaultAuthorizer = newconfig.DefaultAuthorizer
	}

	if newconfig.AdminUsers != nil {
		processed.adminUsers = newconfig.AdminUsers
	} else {
		processed.adminUsers = []string{}
	}
	if newconfig.DefaultChannels != nil {
		processed.plugChannels = newconfig.DefaultChannels
	}
	if newconfig.ExternalPlugins != nil {
		et := make([]TaskSettings, 0)
		for name, task := range newconfig.ExternalPlugins {
			if task.Disabled {
				continue
			}
			task.Name = name
			if task.Privileged == nil {
				p := false
				task.Privileged = &p
			}
			et = append(et, task)
		}
		processed.externalPlugins = et
	}
	if newconfig.ExternalJobs != nil {
		et := make([]TaskSettings, 0)
		for name, task := range newconfig.ExternalJobs {
			if task.Disabled {
				continue
			}
			task.Name = name
			if task.Privileged == nil {
				p := true
				task.Privileged = &p
			}
			et = append(et, task)
		}
		processed.externalJobs = et
	}
	if newconfig.ExternalTasks != nil {
		et := make([]TaskSettings, 0)
		for name, task := range newconfig.ExternalTasks {
			if task.Disabled {
				continue
			}
			task.Name = name
			if task.Privileged == nil {
				p := false
				task.Privileged = &p
			}
			et = append(et, task)
		}
		processed.externalTasks = et
	}
	// NOTE on Go tasks - we can't just skip a disabled task, since they're
	// enabled by default. Disabled: true needs to pass through so it's disabled
	// in taskconf.go
	if newconfig.GoTasks != nil {
		gt := make([]TaskSettings, 0, len(newconfig.GoTasks))
		for name, task := range newconfig.GoTasks {
			task.Name = name
			gt = append(gt, task)
		}
		processed.goTasks = gt
	}
	if newconfig.GoPlugins != nil {
		gt := make([]TaskSettings, 0, len(newconfig.GoPlugins))
		for name, task := range newconfig.GoPlugins {
			task.Name = name
			gt = append(gt, task)
		}
		processed.goPlugins = gt
	}
	if newconfig.GoJobs != nil {
		gt := make([]TaskSettings, 0, len(newconfig.GoJobs))
		for name, task := range newconfig.GoJobs {
			task.Name = name
			gt = append(gt, task)
		}
		processed.goJobs = gt
	}
	if newconfig.NameSpaces != nil {
		ns := make([]TaskSettings, 0, len(newconfig.NameSpaces))
		for name, nameSpace := range newconfig.NameSpaces {
			nameSpace.Name = name
			ns = append(ns, nameSpace)
		}
		processed.nsList = ns
	}
	if newconfig.ParameterSets != nil {
		ps := make([]TaskSettings, 0, len(newconfig.ParameterSets))
		for name, parameterSet := range newconfig.ParameterSets {
			parameterSet.Name = name
			ps = append(ps, parameterSet)
		}
		processed.psList = ps
	}
	st := make([]ScheduledTask, 0, len(newconfig.ScheduledJobs))
	for _, s := range newconfig.ScheduledJobs {
		if len(s.Name) == 0 || len(s.Schedule) == 0 {
			Log(robot.Error, "Zero-length Name (%s) or Schedule (%s) in ScheduledTask, skipping", s.Name, s.Schedule)
		} else {
			st = append(st, s)
		}
	}
	processed.ScheduledJobs = st
	if newconfig.IgnoreUsers != nil {
		processed.ignoreUsers = newconfig.IgnoreUsers
	}
	if newconfig.JoinChannels != nil {
		processed.joinChannels = newconfig.JoinChannels
	}

	ucmaps := userChanMaps{
		make(map[string]*UserInfo),
		make(map[string]*UserInfo),
		make(map[string]*ChannelInfo),
		make(map[string]*ChannelInfo),
	}
	usermap := make(map[string]string)
	if len(newconfig.UserRoster) > 0 {
		for i, user := range newconfig.UserRoster {
			if len(user.UserName) == 0 || len(user.UserID) == 0 {
				Log(robot.Error, "One of Username/UserID empty (%s/%s), ignoring", user.UserName, user.UserID)
			} else {
				u := &newconfig.UserRoster[i]
				ucmaps.user[u.UserName] = u
				ucmaps.userID[u.UserID] = u
				usermap[u.UserName] = u.UserID
			}
		}
	}
	if len(newconfig.ChannelRoster) > 0 {
		for i, ch := range newconfig.ChannelRoster {
			if len(ch.ChannelName) == 0 || len(ch.ChannelID) == 0 {
				Log(robot.Error, "One of ChannelName/ChannelID empty (%s/%s), ignoring", ch.ChannelName, ch.ChannelID)
			} else {
				c := &newconfig.ChannelRoster[i]
				ucmaps.channel[c.ChannelName] = c
				ucmaps.channelID[c.ChannelID] = c
			}
		}
	}
	currentUCMaps.Lock()
	currentUCMaps.ucmap = &ucmaps
	currentUCMaps.Unlock()

	h := handler{}
	if len(newconfig.WorkSpace) > 0 {
		if err := h.GetDirectory(newconfig.WorkSpace); err == nil {
			processed.workSpace = newconfig.WorkSpace
			Log(robot.Debug, "Setting workspace directory to '%s'", processed.workSpace)
		} else {
			Log(robot.Error, "Getting WorkSpace directory '%s', using '%s': %v", newconfig.WorkSpace, configPath, err)
		}
	}

	// Items only read at start-up, before multi-threaded
	if preConnect {
		if newconfig.ProtocolConfig != nil {
			protocolConfig = newconfig.ProtocolConfig
		}

		if newconfig.EncryptBrain {
			encryptBrain = true
		}
		if newconfig.EncryptionKey != "" {
			processed.encryptionKey = newconfig.EncryptionKey
			newconfig.EncryptionKey = "XXXXXX" // too short to be valid anyway
		}
		if newconfig.LocalPort != 0 {
			processed.port = fmt.Sprintf("%d", newconfig.LocalPort)
		} else {
			processed.port = "0"
		}
		if len(newconfig.HistoryProvider) == 0 {
			newconfig.HistoryProvider = "mem"
		}
		var hprovider func(robot.Handler) robot.HistoryProvider
		var ok bool
		if !cliOp { // CLI operations don't need a real history
			if hprovider, ok = historyProviders[newconfig.HistoryProvider]; !ok {
				Log(robot.Error, "No provider registered for history type: \"%s\", falling back to 'mem'", processed.historyProvider)
				newconfig.HistoryProvider = "mem"
				hprovider = historyProviders["mem"]
			}
			hp := hprovider(handler{})
			interfaces.history = hp
			if newconfig.HistoryProvider != "mem" {
				// Initialize the memory provider as a last-ditch fallback
				mhprovider(handler{})
			}
		}
	} else {
		if len(usermap) > 0 {
			interfaces.SetUserMap(usermap)
		}
		// We should never dump the brain key
		newconfig.EncryptionKey = "XXXXXX"
		// initJobs need to run before post-connect loadTaskConfig
		initJobs()
	}

	newList, err := loadTaskConfig(processed, preConnect)
	if err != nil {
		return err
	}

	// Configuration successfully loaded, apply changes

	// Note we always take the locks on global values regardless
	// of preConnect.

	// Update structs supplied to "dump robot" and "GetRepositories"
	// Note that GetRepositories blanks out Parameters, but dump
	// commands are only allowed for the terminal connector.
	confLock.Lock()
	config = newconfig
	repositories = repolist
	confLock.Unlock()

	currentCfg.Lock()
	processed.botinfo.UserID = currentCfg.botinfo.UserID
	processed.botinfo.protoMention = currentCfg.botinfo.protoMention
	currentCfg.configuration = processed
	currentCfg.taskList = newList
	currentCfg.Unlock()

	if !preConnect {
		updateRegexes()
		scheduleTasks()
		initializePlugins()
	}

	return nil
}
</file_content file: gopherbot-main/bot/conf.go>
<preamble file: gopherbot-main/bot/config_load.go>

</preamble>
<file_content file: gopherbot-main/bot/config_load.go>
package bot

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	"github.com/ghodss/yaml"
	"github.com/lnxjedi/gopherbot/robot"
)

const appendPrefix = "Append"

// merge map merges maps and concatenates slices; values in m(erge) override values
// in t(arget).
func mergemap(m, t map[string]interface{}) map[string]interface{} {
	for k, v := range m {
		appendArr := false
		if strings.HasPrefix(k, appendPrefix) {
			k = strings.TrimPrefix(k, appendPrefix)
			appendArr = true
		}
		if tv, ok := t[k]; ok {
			if reflect.TypeOf(v) == reflect.TypeOf(tv) {
				switch v.(type) {
				case map[string]interface{}:
					mv := v.(map[string]interface{})
					mtv := tv.(map[string]interface{})
					t[k] = mergemap(mv, mtv)
				case []interface{}:
					sv := v.([]interface{})
					if !appendArr {
						t[k] = sv
					} else {
						tva := tv.([]interface{})
						t[k] = append(tva, sv...)
					}
				default:
					t[k] = v
				}
			} else {
				// mis-matched types, use new value if non-nil
				if v != nil {
					t[k] = v
				} else {
					t[k] = tv
				}
			}
		} else {
			t[k] = v
		}
	}
	return t
}

// env is for the config file template FuncMap. It returns
// the given environment var if found. If required is set,
// an Error-level log event is generated for empty vars.
func env(envvar string) string {
	val := os.Getenv(envvar)
	if len(val) == 0 {
		Log(robot.Debug, "Empty environment variable returned for '%s' in template expansion", envvar)
	}
	return val
}

// defval is for the config file template FuncMap. If an empty string is piped in,
// the default value is returned.
func defval(d, i string) string {
	if len(i) == 0 {
		return d
	}
	return i
}

// decryptTpl takes an base64 encoded string, decodes and decrypts, and returns
// the value.
func decryptTpl(encval string) string {
	cryptKey.RLock()
	initialized := cryptKey.initialized
	key := cryptKey.key
	cryptKey.RUnlock()
	if !initialized {
		Log(robot.Warn, "Template called decrypt(Tpl) function but encryption not initialized")
		return ""
	}
	encbytes, err := base64.StdEncoding.DecodeString(encval)
	if err != nil {
		Log(robot.Error, "Unable to base64 decode in template decrypt(Tpl): %v", err)
		return ""
	}
	secret, decerr := decrypt(encbytes, key)
	if decerr != nil {
		Log(robot.Error, "Unable to decrypt secret in template decrypt(Tpl): %v", decerr)
		return ""
	}
	return string(secret)
}

type loadTpl struct {
	dir      string
	isCustom bool
}

func (t loadTpl) Include(tpl string) string {
	base := installPath
	if t.isCustom {
		base = configPath
	}
	path := filepath.Join(base, t.dir, tpl)
	Log(robot.Debug, "Loading Include'd config: %s", path)
	incfile, err := os.Open(path)
	if err != nil {
		Log(robot.Error, "Opening include '%s'(%s): %v", tpl, path, err)
		return ""
	}
	var incbuff bytes.Buffer
	incscanner := bufio.NewScanner(incfile)
	for incscanner.Scan() {
		line := incscanner.Text()
		if !strings.HasPrefix(line, "---") {
			incbuff.WriteString(line)
			incbuff.WriteString("\n")
		}
	}
	err = incscanner.Err()
	if err != nil {
		Log(robot.Error, "Reading include '%s'(%s): %v", tpl, path, err)
		return ""
	}
	inc := incbuff.Bytes()
	expanded, err := expand(t.dir, t.isCustom, inc)
	if err != nil {
		Log(robot.Error, "Expanding included '%s': %v", tpl, err)
		return ""
	}
	return string(expanded)
}

// expand expands a text template
func expand(dir string, custom bool, in []byte) (out []byte, err error) {
	lt := loadTpl{
		dir:      dir,
		isCustom: custom,
	}
	tplFuncs := template.FuncMap{
		"decrypt": decryptTpl,
		"default": defval,
		"env":     env,
	}
	var outBuff bytes.Buffer
	tpl, err := template.New("").Funcs(tplFuncs).Parse(string(in))
	if err != nil {
		return nil, err
	}
	if err := tpl.Execute(&outBuff, lt); err != nil {
		return nil, err
	}
	return outBuff.Bytes(), nil
}

// getConfigFile loads a config file first from installPath, then from configPath
// if set. Required indicates whether to return an error if neither file is found.
func getConfigFile(filename string, required bool, jsonMap map[string]json.RawMessage, prev ...map[string]interface{}) error {
	var (
		cf           []byte
		err, realerr error
	)

	loaded := false
	var path string

	var cfg map[string]interface{}
	installed := make(map[string]interface{})
	configured := make(map[string]interface{})
	if len(prev) > 0 && prev[0] != nil {
		cfg = prev[0]
	} else {
		cfg = make(map[string]interface{})
	}
	path = filepath.Join(installPath, "conf", filename)
	// compatibility with old config file name
	if filename == "gopherbot.yaml" {
		Log(robot.Warn, "Merging legacy custom gopherbot.yaml with installed robot.yaml")
		path = filepath.Join(installPath, "conf", "robot.yaml")
	}
	dir := filepath.Dir(filepath.Join("conf", filename))
	cf, err = os.ReadFile(path)
	if err == nil {
		if cf, err = expand(dir, false, cf); err != nil {
			Log(robot.Error, "Expanding '%s': %v", path, err)
		}
		if err = yaml.Unmarshal(cf, &installed); err != nil {
			err = fmt.Errorf("Unmarshalling installed \"%s\": %v", filename, err)
			Log(robot.Error, err.Error())
			return err
		}
		if len(installed) == 0 {
			Log(robot.Error, "Empty config hash loading %s", path)
		} else {
			Log(robot.Debug, "Loaded installed conf/%s", filename)
			cfg = mergemap(installed, cfg)
			loaded = true
		}
	} else {
		realerr = err
	}
	if len(configPath) > 0 {
		path = filepath.Join(configPath, "conf", filename)
		cf, err = os.ReadFile(path)
		if err == nil {
			if cf, err = expand(dir, true, cf); err != nil {
				Log(robot.Error, "Expanding '%s': %v", path, err)
			}
			if err = yaml.Unmarshal(cf, &configured); err != nil {
				err = fmt.Errorf("Unmarshalling configured \"%s\": %v", filename, err)
				Log(robot.Error, err.Error())
				return err // If a badly-formatted config is loaded, we always return an error
			}
			if len(configured) == 0 {
				Log(robot.Error, "Empty config hash loading %s", path)
			} else {
				Log(robot.Debug, "Loaded configured conf/%s", filename)
				cfg = mergemap(configured, cfg)
				loaded = true
			}
		} else {
			realerr = err
		}
	}
	jsonData, _ := json.Marshal(cfg)
	json.Unmarshal(jsonData, &jsonMap)
	if required && !loaded {
		return realerr
	}
	return nil
}
</file_content file: gopherbot-main/bot/config_load.go>
<preamble file: gopherbot-main/bot/constants.go>

</preamble>
<file_content file: gopherbot-main/bot/constants.go>
package bot

// 65536
const maxIndex = 1 << 16

type pipeAddFlavor int
type pipeAddType int
type taskType int

const (
	flavorSpawn pipeAddFlavor = iota
	flavorAdd
	flavorFinal
	flavorFail
)

const (
	typeTask pipeAddType = iota
	typePlugin
	typeJob
)

const (
	taskGo taskType = iota
	taskExternal
)

// Indicates what started the pipeline
type pipelineType int

const (
	unset pipelineType = iota
	plugCommand
	plugMessage
	catchAll
	plugThreadSubscription
	jobTrigger
	spawnedTask
	scheduled
	initJob    // scheduled job schedule: @init
	jobCommand // i.e. run job xx
)

//go:generate stringer -type=pipeAddFlavor constants.go
//go:generate stringer -type=pipeAddType constants.go
//go:generate stringer -type=taskType constants.go
//go:generate stringer -type=pipelineType constants.go

// Generate String methods with: go generate ./bot/
</file_content file: gopherbot-main/bot/constants.go>
<preamble file: gopherbot-main/bot/dispatch.go>

</preamble>
<file_content file: gopherbot-main/bot/dispatch.go>
package bot

import (
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

const keepListeningDuration = 77 * time.Second

var spaceRe = regexp.MustCompile(`\s+`)

const lastMsgKey = "lastMsg"

// checkPluginMatchersAndRun checks either command matchers (for messages directed at
// the robot), or message matchers (for ambient commands that need not be
// directed at the robot), and calls the plugin if it matches. Note: this
// function is called under a read lock on the 'b' struct.
func (w *worker) checkPluginMatchersAndRun(pipelineType pipelineType) (messageMatched bool) {
	// un-needed, but more clear
	messageMatched = false
	matchMsg := w.msg
	// If we're checking messages, debugging messages require that the admin requested verboseness
	verboseOnly := false
	if pipelineType == plugMessage {
		verboseOnly = true
		matchMsg = w.fmsg
	}
	matchChannelOnly := false
	if len(w.Channel) > 0 && !w.Incoming.ThreadedMessage {
		matchChannelOnly = true
	}
	var runTask interface{}
	var matchedMatcher InputMatcher
	var cmdArgs []string
	// Note: skip the first task, dummy used for namespaces
	for _, t := range w.tasks.t[1:] {
		task, plugin, _ := getTask(t)
		if plugin == nil {
			continue
		}
		if task.Disabled {
			msg := fmt.Sprintf("Skipping disabled task '%s', reason: %s", task.name, task.reason)
			Log(robot.Trace, msg)
			continue
		}
		Log(robot.Trace, "Checking availability of task '%s' in channel '%s' for user '%s', active in %d channels (allchannels: %t)", task.name, w.Channel, w.User, len(task.Channels), task.AllChannels)
		ok, _ := w.pluginAvailable(task, false, verboseOnly)
		if !ok {
			Log(robot.Trace, "Task '%s' not available for user '%s' in channel '%s', doesn't meet criteria", task.name, w.User, w.Channel)
			continue
		}
		var matchers []InputMatcher
		switch pipelineType {
		case plugCommand:
			if len(plugin.CommandMatchers) == 0 {
				continue
			}
			matchers = plugin.CommandMatchers
		case plugMessage:
			if w.isCommand && !plugin.AmbientMatchCommand {
				continue
			}
			if len(plugin.MessageMatchers) == 0 {
				continue
			}
			if !w.listedUser && !plugin.MatchUnlisted && !w.isCommand {
				msg := fmt.Sprintf("ignoring unlisted user '%s' for plugin '%s' ambient messages", w.User, task.name)
				Log(robot.Debug, msg)
				continue
			}
			matchers = plugin.MessageMatchers
		}
		Log(robot.Trace, "Task '%s' is active, will check for matches", task.name)
		cmsg := spaceRe.ReplaceAllString(matchMsg, " ")
		for _, matcher := range matchers {
			if matcher.ChannelOnly && !matchChannelOnly {
				Log(robot.Trace, "Skipping '%s', requested ChannelOnly matching", matcher.Regex)
				continue
			}
			Log(robot.Trace, "Checking '%s' against '%s'", cmsg, matcher.Regex)
			matches := matcher.re.FindStringSubmatch(matchMsg)
			if matches != nil {
				cmsg = w.msg
			} else {
				matches = matcher.re.FindStringSubmatch(cmsg)
			}
			matched := false
			if matches != nil {
				matched = true
				Log(robot.Trace, "Message '%s' matches command '%s'", cmsg, matcher.Command)
				cmdArgs = matches[1:]
				if len(matcher.Contexts) > 0 {
					// Resolve & store "it" with ephemeral memories
					ts := time.Now()
					modified := false
					ephemeralMemories.Lock()
					for i, contextLabel := range matcher.Contexts {
						if contextLabel != "" {
							if len(cmdArgs) > i {
								ctxargs := strings.Split(contextLabel, ":")
								contextName := ctxargs[0]
								contextMatches := []string{""}
								contextMatches = append(contextMatches, ctxargs[1:]...)
								key := "context:" + contextName
								ctx := w.makeMemoryContext(key)
								// Check if the capture group matches the empty string
								// or one of the generic values (e.g. "it")
								cMatch := false
								for _, cm := range contextMatches {
									if cmdArgs[i] == cm {
										cMatch = true
									}
								}
								if cMatch {
									// If a generic matched, try to recall from ephemeral memory
									s, ok := ephemeralMemories.m[ctx]
									if ok {
										cmdArgs[i] = s.Memory
										// TODO: it would probably be best to substitute the value
										// from "it" back in to the original message and re-check for
										// a match. Failing a match, matched should be set to false.
										s.Timestamp = ts
										ephemeralMemories.m[ctx] = s
										modified = true
									} else {
										w.Say("Sorry, I don't remember which %s we were talking about - please re-enter your command and be more specific", contextLabel)
										ephemeralMemories.Unlock()
										return true
									}
								} else {
									// Didn't match generic, store the value in ephemeral context memory
									s := ephemeralMemory{cmdArgs[i], ts}
									ephemeralMemories.m[ctx] = s
									modified = true
								}
							} else {
								Log(robot.Error, "Plugin '%s', command '%s', has more contexts than match groups", task.name, matcher.Command)
							}
						}
					}
					if modified {
						ephemeralMemories.dirty = true
					}
					ephemeralMemories.Unlock()
				}
			}
			if matched {
				if messageMatched {
					prevTask, _, _ := getTask(runTask)
					Log(robot.Error, "Message '%s' matched multiple tasks: %s and %s", cmsg, prevTask.name, task.name)
					w.Say("Yikes! Your command matched multiple plugins, so I'm not doing ANYTHING")
					emit(MultipleMatchesNoAction)
					return
				}
				messageMatched = true
				runTask = t
				matchedMatcher = matcher
				break
			}
		} // end of matcher checking
	} // end of plugin checking
	if messageMatched {
		task, _, _ := getTask(runTask)
		w.messageHeard()
		matcher := matchedMatcher
		allow := false
		if task.name == "builtin-admin" {
			switch matcher.Command {
			case "ps", "kill", "abort":
				allow = true
			}
		}
		state.RLock()
		if state.shuttingDown && !allow {
			w.Say("Sorry, I'm shutting down and can't start any new tasks")
			state.RUnlock()
			return
		}
		state.RUnlock()
		w.startPipeline(nil, runTask, pipelineType, matcher.Command, cmdArgs...)
	}
	return
}

// handleMessage checks the message against plugin commands and full-message
// matches, then dispatches it to the applicable plugin. If the robot was
// addressed directly but nothing matched, any registered CatchAll plugins are
// called. There Should Be Only One (terminal plugin called).
func (w *worker) handleMessage() {
	defer checkPanic(w, w.msg)

	if w.Incoming.DirectMessage {
		emit(BotDirectMessage)
		Log(robot.Trace, "Bot received a direct message from %s: %s", w.User, w.msg)
	}
	messageMatched := false
	ts := time.Now()
	lastMsgContext := w.makeMemoryContext(lastMsgKey)
	var last ephemeralMemory
	var ok bool
	// First, see if the robot was waiting on a reply; replies from
	// user take precedence over everything else.
	var waiters []replyWaiter
	waitingForReply := false
	threadID := ""
	if w.Incoming.ThreadedMessage {
		threadID = w.Incoming.ThreadID
	}
	matcher := replyMatcher{w.User, w.Channel, threadID}
	Log(robot.Trace, "Checking replies for matcher: %q", matcher)
	replies.Lock()
	waiters, waitingForReply = replies.m[matcher]
	if !waitingForReply {
		replies.Unlock()
	} else {
		delete(replies.m, matcher)
		replies.Unlock()
		// if the robot was waiting on a reply from this user, it always
		// counts as a matched message.
		messageMatched = true
		for i, rep := range waiters {
			if i == 0 {
				cmsg := spaceRe.ReplaceAllString(w.fmsg, " ")
				matched := rep.re.MatchString(w.fmsg)
				if matched {
					cmsg = w.fmsg
				} else {
					matched = rep.re.MatchString(cmsg)
				}
				Log(robot.Debug, "Found replyWaiter for user '%s' in channel '%s'/thread '%s', checking if message '%s' matches '%s': %t", w.User, w.Channel, w.Incoming.ThreadID, cmsg, rep.re.String(), matched)
				rep.replyChannel <- reply{matched, replied, cmsg}
			} else {
				Log(robot.Debug, "Sending retry to next reply waiter")
				rep.replyChannel <- reply{false, retryPrompt, ""}
			}
		}
	}
	// See if the robot got a blank message, indicating that the last message
	// was meant for it (if it was in the keepListeningDuration); also handle "robot?"
	// This happens when the bareRegex matches.
	if !messageMatched && w.isCommand && !w.Incoming.SelfMessage && len(w.msg) == 0 && !w.BotUser {
		ephemeralMemories.Lock()
		last, ok = ephemeralMemories.m[lastMsgContext]
		ephemeralMemories.Unlock()
		Log(robot.Debug, "Barename/blank message to robot received ('%s'), checking last message: '%s'", w.fmsg, last.Memory)
		// Allow individual plugins to handle a lone "?"
		// Feature added for - you guessed it - the AI plugin
		if strings.HasSuffix(w.fmsg, "?") {
			w.msg = "?"
			messageMatched = w.checkPluginMatchersAndRun(plugCommand)
		}
		if !messageMatched {
			if ok && ts.Sub(last.Timestamp) < keepListeningDuration {
				w.msg = last.Memory
				messageMatched = w.checkPluginMatchersAndRun(plugCommand)
			} else {
				messageMatched = true
				w.Say("Yes?")
			}
		}
	}
	// NOTE: Another bot can send a plugCommand to the bot
	if !messageMatched && w.isCommand && !w.Incoming.SelfMessage {
		// See if a command matches (and runs)
		messageMatched = w.checkPluginMatchersAndRun(plugCommand)
	}
	// Direct commands were checked above; if a direct command didn't match,
	// and a there wasn't a reply being waited on, then we check ambient
	// MessageMatchers.
	if !messageMatched && !w.Incoming.SelfMessage && !w.BotUser {
		// check for ambient message matches
		messageMatched = w.checkPluginMatchersAndRun(plugMessage)
	}
	// Check for job commands
	if !messageMatched {
		messageMatched = w.checkJobMatchersAndRun()
	}
	catchAllMatched := false
	if w.isCommand && !messageMatched && !w.Incoming.SelfMessage && !w.BotUser { // the robot was spoken to, but nothing matched - call catchAlls
		state.RLock()
		if !state.shuttingDown {
			state.RUnlock()
			w.messageHeard()
			Log(robot.Debug, "Unmatched command sent to robot, calling catchalls: %s", w.msg)
			emit(CatchAllsRan) // for testing, otherwise noop
			var specificCatchAll, fallbackCatchAll interface{}
			var multipleCatchallMatched, multipleFallbackMatched bool
			for _, t := range w.tasks.t[1:] {
				task, plugin, _ := getTask(t)
				if plugin == nil || !plugin.CatchAll {
					Log(robot.Trace, "Checking plugin %s for catch-all (false)", task.name)
					continue
				}
				available, specific := w.pluginAvailable(task, false, false)
				if !available {
					continue
				}
				if specific {
					Log(robot.Trace, "Checking plugin %s for catch-all (true, specific)", task.name)
					if specificCatchAll == nil {
						specificCatchAll = t
					} else {
						multipleCatchallMatched = true
						break
					}
				} else {
					Log(robot.Trace, "Checking plugin %s for catch-all (true, non-specific)", task.name)
					if fallbackCatchAll == nil {
						fallbackCatchAll = t
					} else {
						multipleFallbackMatched = true
					}
				}
			}
			if multipleCatchallMatched {
				Log(robot.Error, "More than one specific catch-all matched, none will be called")
			} else {
				if specificCatchAll != nil {
					task, _, _ := getTask(specificCatchAll)
					Log(robot.Debug, "Unmatched command, calling specific catchall '%s' in channel '%s'", task.name, w.Channel)
					catchAllMatched = true
					w.startPipeline(nil, specificCatchAll, catchAll, "catchall", w.fmsg)
				} else if fallbackCatchAll != nil {
					if multipleFallbackMatched {
						Log(robot.Error, "More than one fallback catch-all matched, none will be called")
					} else {
						task, _, _ := getTask(fallbackCatchAll)
						Log(robot.Debug, "Unmatched command, calling fallback catchall '%s' in channel '%s'", task.name, w.Channel)
						catchAllMatched = true
						w.startPipeline(nil, fallbackCatchAll, catchAll, "catchall", w.fmsg)
					}
				} else {
					Log(robot.Debug, "Unmatched command to robot and no catchall defined")
				}
			}
		} else {
			// If the robot is shutting down, just ignore catch-all plugins
			state.RUnlock()
		}
	}
	// Last of all, check for thread subscriptions
	if !messageMatched && !w.Incoming.SelfMessage && (w.isCommand && !catchAllMatched || !w.isCommand) {
		subscriptionSpec := subscriptionMatcher{w.Channel, w.Incoming.ThreadID}
		subscriptions.Lock()
		if subscription, ok := subscriptions.m[subscriptionSpec]; ok {
			subscription.Timestamp = time.Now()
			subscriptions.Unlock()
			t := w.tasks.getTaskByName(subscription.Plugin)
			if w.Incoming.UserID != w.cfg.botinfo.UserID {
				Log(robot.Debug, "Unmatched message being routed to thread subscriber '%s' in thread '%s', channel '%s'", subscription.Plugin, w.Incoming.ThreadID, w.Channel)
				w.startPipeline(nil, t, plugThreadSubscription, "subscribed", w.fmsg)
			} else {
				Log(robot.Debug, "Ignoring message from the robot after subscription matched for thread subscriber '%s' in thread '%s', channel '%s'")
			}
		} else {
			subscriptions.Unlock()
		}
	}
	if w.BotUser {
		return
	}
	if messageMatched || w.isCommand {
		ephemeralMemories.Lock()
		delete(ephemeralMemories.m, lastMsgContext)
		ephemeralMemories.Unlock()
	} else {
		last = ephemeralMemory{w.msg, ts}
		ephemeralMemories.Lock()
		ephemeralMemories.m[lastMsgContext] = last
		ephemeralMemories.Unlock()
	}
}
</file_content file: gopherbot-main/bot/dispatch.go>
<preamble file: gopherbot-main/bot/elevate.go>

</preamble>
<file_content file: gopherbot-main/bot/elevate.go>
package bot

import "github.com/lnxjedi/gopherbot/robot"

const technicalElevError = "Sorry, elevation failed due to a problem with the elevation service"
const configElevError = "Sorry, elevation failed due to a configuration error"

// Elevator plugins provide an elevate method for checking if the user
// can run a privileged command.

func (r Robot) elevate(task *Task, immediate bool) (retval robot.TaskRetVal) {
	defaultElevator := r.cfg.defaultElevator
	if task.Elevator == "" && defaultElevator == "" {
		Log(robot.Audit, "Task '%s' requires elevation, but no elevator configured", task.name)
		r.Say(configElevError)
		emit(ElevNoRunMisconfigured)
		return robot.ConfigurationError
	}
	elevator := defaultElevator
	if task.Elevator != "" {
		elevator = task.Elevator
	}
	_, ePlug, _ := getTask(r.tasks.getTaskByName(elevator))
	if ePlug != nil {
		immedString := "true"
		if !immediate {
			immedString = "false"
		}
		w := getLockedWorker(r.tid)
		w.Unlock()
		_, elevRet := w.callTask(ePlug, "elevate", immedString)
		elevated := elevRet == robot.Success
		w.Lock()
		w.elevated = elevated
		w.currentTask = r.currentTask
		w.Unlock()
		if elevated {
			Log(robot.Audit, "Elevation succeeded by elevator '%s', user '%s', task '%s' in channel '%s'", ePlug.name, r.User, task.name, r.Channel)
			emit(ElevRanSuccess)
			return robot.Success
		}
		if elevRet == robot.Fail {
			Log(robot.Audit, "Elevation FAILED by elevator '%s', user '%s', task '%s' in channel '%s'", ePlug.name, r.User, task.name, r.Channel)
			r.Say("Sorry, this command requires elevation")
			emit(ElevRanFail)
			return robot.Fail
		}
		if elevRet == robot.MechanismFail {
			Log(robot.Audit, "Elevator plugin '%s' mechanism failure while elevating user '%s' for task '%s' in channel '%s'", ePlug.name, r.User, task.name, r.Channel)
			r.Say(technicalElevError)
			emit(ElevRanMechanismFailed)
			return robot.MechanismFail
		}
		if elevRet == robot.Normal {
			Log(robot.Audit, "Elevator plugin '%s' returned 'Normal' (0) instead of 'Success' (1), failing elevation in '%s' for task '%s' in channel '%s'", ePlug.name, r.User, task.name, r.Channel)
			r.Say(technicalElevError)
			emit(ElevRanFailNormal)
			return robot.MechanismFail
		}
		Log(robot.Audit, "Elevator plugin '%s' exit code %d while elevating user '%s' for task '%s' in channel '%s'", ePlug.name, retval, r.User, task.name, r.Channel)
		r.Say(technicalElevError)
		emit(ElevRanFailOther)
		return robot.MechanismFail
	}
	Log(robot.Audit, "Elevator plugin '%s' not found while elevating user '%s' for task '%s' in channel '%s'", task.Elevator, r.User, task.name, r.Channel)
	r.Say(technicalElevError)
	emit(ElevNoRunNotFound)
	return robot.ConfigurationError
}

// Check for a configured Elevator and check elevation
func (r Robot) checkElevation(t interface{}, command string) (retval robot.TaskRetVal, required bool) {
	task, plugin, _ := getTask(t)
	isPlugin := plugin != nil
	immediate := false
	elevationRequired := false
	if isPlugin && len(plugin.ElevateImmediateCommands) > 0 {
		for _, i := range plugin.ElevateImmediateCommands {
			if command == i {
				elevationRequired = true
				immediate = true
				break
			}
		}
	}
	if isPlugin && !elevationRequired && len(plugin.ElevatedCommands) > 0 {
		for _, i := range plugin.ElevatedCommands {
			if command == i {
				elevationRequired = true
				break
			}
		}
	}
	if !isPlugin {
		if len(task.Elevator) > 0 {
			elevationRequired = true
		}
	}
	if !elevationRequired {
		return robot.Success, false
	}
	retval = r.elevate(task, immediate)
	if retval == robot.Success {
		return robot.Success, true
	}
	Log(robot.Error, "Elevation failed for task '%s', command: '%s'", task.name, command)
	return robot.Fail, true
}
</file_content file: gopherbot-main/bot/elevate.go>
<preamble file: gopherbot-main/bot/email.go>

</preamble>
<file_content file: gopherbot-main/bot/email.go>
package bot

import (
	"bytes"
	"fmt"
	"net/smtp"
	"strings"

	"github.com/jordan-wright/email"
	"github.com/lnxjedi/gopherbot/robot"
)

type botMailer struct {
	Mailhost string // host(:port) to send email through
	Authtype string // none, plain
	User     string // optional username for authenticated email
	Password string // optional password for authenticated email
}

// Email provides a simple interface for sending the user an email from the
// bot. It relies on both the robot and the user having an email address.
// For the robot, this can be conifigured in gopherbot.conf, Email attribute.
// For the user, this should be provided by the chat protocol, or in
// gopherbot.conf.
// It returns an error and b.RetVal != 0 if there's a problem.
func (r Robot) Email(subject string, messageBody *bytes.Buffer, html ...bool) (ret robot.RetVal) {
	mailAttr := r.GetSenderAttribute("email")
	if mailAttr.RetVal != robot.Ok {
		return robot.NoUserEmail
	}
	return r.realEmail(subject, mailAttr.Attribute, messageBody, html...)
}

// EmailUser is a method for sending an email to a specified user. See Email.
func (r Robot) EmailUser(user, subject string, messageBody *bytes.Buffer, html ...bool) (ret robot.RetVal) {
	mailAttr := r.GetUserAttribute(user, "email")
	if mailAttr.RetVal != robot.Ok {
		return robot.NoUserEmail
	}
	return r.realEmail(subject, mailAttr.Attribute, messageBody, html...)
}

// EmailAddress is a method for sending an email to a specified address. See Email.
func (r Robot) EmailAddress(address, subject string, messageBody *bytes.Buffer, html ...bool) (ret robot.RetVal) {
	return r.realEmail(subject, address, messageBody, html...)
}

func (r Robot) realEmail(subject, mailTo string, messageBody *bytes.Buffer, html ...bool) (ret robot.RetVal) {
	var mailFrom, botName string

	mailAttr := r.GetBotAttribute("email")
	if mailAttr.RetVal != robot.Ok || mailAttr.Attribute == "" {
		r.Log(robot.Error, "Email send requested but robot has no Email set in config")
		return robot.NoBotEmail
	}
	mailFrom = mailAttr.Attribute
	// We can live without a full name
	botAttr := r.GetBotAttribute("fullName")
	if botAttr.RetVal != robot.Ok {
		botName = "Gopherbot"
	} else {
		botName = botAttr.Attribute
	}
	if !strings.Contains(mailTo, "@") {
		userMailAttr := r.GetUserAttribute(mailTo, "email")
		if userMailAttr.RetVal == robot.Ok {
			mailTo = userMailAttr.Attribute
		} else {
			r.Log(robot.Error, "Unable to look up email address for: %s", mailTo)
			return robot.AttributeNotFound
		}
	}

	e := email.NewEmail()
	from := fmt.Sprintf("%s <%s>", botName, mailFrom)
	e.From = from
	e.To = []string{mailTo}
	e.Subject = subject
	if len(html) > 0 && html[0] {
		e.HTML = messageBody.Bytes()
	} else {
		e.Text = messageBody.Bytes()
	}

	var a smtp.Auth
	if r.cfg.mailConf.Authtype == "plain" {
		host := strings.Split(r.cfg.mailConf.Mailhost, ":")[0]
		a = smtp.PlainAuth("", r.cfg.mailConf.User, r.cfg.mailConf.Password, host)
		Log(robot.Debug, "Sending authenticated email to \"%s\" from \"%s\" via \"%s\" with user: %s, password: xxxx, and host: %s",
			mailTo,
			from,
			r.cfg.mailConf.Mailhost,
			r.cfg.mailConf.User,
			host,
		)
	} else {
		Log(robot.Debug, "Sending unauthenticated email to \"%s\" from \"%s\" via \"%s\"",
			mailTo,
			from,
			r.cfg.mailConf.Mailhost,
		)
	}

	err := e.Send(r.cfg.mailConf.Mailhost, a)
	if err != nil {
		err = fmt.Errorf("Sending email: %v", err)
		Log(robot.Error, err.Error())
		return robot.MailError
	}
	return robot.Ok
}
</file_content file: gopherbot-main/bot/email.go>
<preamble file: gopherbot-main/bot/emit_noop.go>

</preamble>
<file_content file: gopherbot-main/bot/emit_noop.go>
// +build !test

package bot

func emit(e Event) {
	// noop - see emit_test.go
}

// GetEvents lets the test harness figure out what happened
func GetEvents() *[]Event {
	return &[]Event{}
}

// GetEventStrings for terminal connector
func (h handler) GetEventStrings() *[]string {
	return &[]string{}
}
</file_content file: gopherbot-main/bot/emit_noop.go>
<preamble file: gopherbot-main/bot/emit_testing.go>

</preamble>
<file_content file: gopherbot-main/bot/emit_testing.go>
//go:build test
// +build test

package bot

import (
	"path"
	"runtime"

	"github.com/lnxjedi/gopherbot/robot"
)

var events = make(chan Event, 16)

// shove an event in to the buffered channel for later retrieval by an
// integration test
func emit(e Event) {
	_, file, line, _ := runtime.Caller(1)
	select {
	case events <- e:
		Log(robot.Debug, "Event recorded: %s in %s, line %d", e, path.Base(file), line)
	default:
		Log(robot.Debug, "Event channel buffer full, didn't record: %s in %s, line %d", e, file, line)
	}
}

// GetEvents called by integration tests
func GetEvents() *[]Event {
	ev := make([]Event, 0)
loop:
	for {
		select {
		case e := <-events:
			ev = append(ev, e)
		default:
			break loop
		}
	}
	return &ev
}

// GetEventStrings called by terminal connector
func (h handler) GetEventStrings() *[]string {
	ev := make([]string, 0)
loop:
	for {
		select {
		case e := <-events:
			ev = append(ev, e.String())
		default:
			break loop
		}
	}
	return &ev
}
</file_content file: gopherbot-main/bot/emit_testing.go>
<preamble file: gopherbot-main/bot/ephemeral.go>

</preamble>
<file_content file: gopherbot-main/bot/ephemeral.go>
package bot

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

const ephemeralMemKey = "bot:_ephemeral-memories"

// ephemeral memories held im RAM that expire after a time
type ephemeralMemory struct {
	Memory    string
	Timestamp time.Time
}

type memoryContext struct {
	key, user, channel, thread string
}

type eMemories struct {
	m     map[memoryContext]ephemeralMemory
	dirty bool
	sync.Mutex
}

var ephemeralMemories = eMemories{
	m: make(map[memoryContext]ephemeralMemory),
}

// the lock should be held on entry and released after return
func (em eMemories) MarshalJSON() ([]byte, error) {
	tempMap := make(map[string]ephemeralMemory)
	for k, v := range em.m {
		// No need to thrash the brain with lastMsg memories
		if k.key == lastMsgKey {
			continue
		}
		keyString := fmt.Sprintf("%s{|}%s{|}%s{|}%s", k.key, k.user, k.channel, k.thread)
		tempMap[keyString] = v
	}
	return json.Marshal(tempMap)
}

// No locking needed - called before multi-threaded
func (e *eMemories) UnmarshalJSON(data []byte) error {
	var tempMap map[string]ephemeralMemory
	err := json.Unmarshal(data, &tempMap)
	if err != nil {
		return err
	}
	e.m = make(map[memoryContext]ephemeralMemory)
	for k, v := range tempMap {
		parts := strings.SplitN(k, "{|}", 4)
		if len(parts) != 4 {
			return fmt.Errorf("invalid key string format: %s", k)
		}
		key := memoryContext{
			key:     parts[0],
			user:    parts[1],
			channel: parts[2],
			thread:  parts[3],
		}
		e.m[key] = v
	}
	return nil
}

func restoreEphemeralMemories() {
	// Restore subscriptions and ephemeral memories
	var storedMemories eMemories
	sm_tok, sm_exists, sm_ret := checkoutDatum(ephemeralMemKey, &storedMemories, true)
	if sm_ret == robot.Ok {
		if sm_exists {
			if len(storedMemories.m) > 0 {
				Log(robot.Info, "Restored '%d' ephemeral memories from long-term memory", len(storedMemories.m))
				now := time.Now()
				for _, m := range storedMemories.m {
					m.Timestamp = now
				}
				ephemeralMemories.m = storedMemories.m
			} else {
				Log(robot.Info, "Restoring ephemeral memories from long-term memory: zero-length map")
				checkinDatum(ephemeralMemKey, sm_tok)
			}
		} else {
			Log(robot.Info, "Restoring ephemeral memories from long-term memory: memory doesn't exist")
			checkinDatum(ephemeralMemKey, sm_tok)
		}
	} else {
		Log(robot.Error, "Restoring ephemeral memories from long-term memory: error '%s' getting datum", sm_ret)
	}
}

func saveEphemeralMemories() {
	var storedEphemeralMemories eMemories
	sm_tok, _, sm_ret := checkoutDatum(ephemeralMemKey, &storedEphemeralMemories, true)
	if sm_ret == robot.Ok {
		ephemeralMemories.Lock()
		storedEphemeralMemories.m = ephemeralMemories.m
		ephemeralMemories.dirty = false
		ret := updateDatum(ephemeralMemKey, sm_tok, storedEphemeralMemories)
		// NOTE: Hold the lock until after serializing - the
		// storedEphmemeralMemories assignment doesn't copy.
		// NOTE also: getting the len counts as a read.
		stored := len(storedEphemeralMemories.m)
		ephemeralMemories.Unlock()
		if ret == robot.Ok {
			Log(robot.Debug, "Successfully saved '%d' ephemeral memories to long-term memory", stored)
		} else {
			Log(robot.Error, "Error '%s' updating ephemeral memories in long-term memory", ret)
		}
	} else {
		Log(robot.Error, "Saving ephemeral memories to long-term memory: error '%s' getting datum", sm_ret)
	}
}
</file_content file: gopherbot-main/bot/ephemeral.go>
<preamble file: gopherbot-main/bot/event_string.go>

</preamble>
<file_content file: gopherbot-main/bot/event_string.go>
// Code generated by "stringer -type=Event events.go"; DO NOT EDIT.

package bot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[IgnoredUser-0]
	_ = x[BotDirectMessage-1]
	_ = x[AdminCheckPassed-2]
	_ = x[AdminCheckFailed-3]
	_ = x[MultipleMatchesNoAction-4]
	_ = x[AuthNoRunMisconfigured-5]
	_ = x[AuthNoRunPlugNotAvailable-6]
	_ = x[AuthRanSuccess-7]
	_ = x[AuthRanFail-8]
	_ = x[AuthRanMechanismFailed-9]
	_ = x[AuthRanFailNormal-10]
	_ = x[AuthRanFailOther-11]
	_ = x[AuthNoRunNotFound-12]
	_ = x[ElevNoRunMisconfigured-13]
	_ = x[ElevNoRunNotAvailable-14]
	_ = x[ElevRanSuccess-15]
	_ = x[ElevRanFail-16]
	_ = x[ElevRanMechanismFailed-17]
	_ = x[ElevRanFailNormal-18]
	_ = x[ElevRanFailOther-19]
	_ = x[ElevNoRunNotFound-20]
	_ = x[CommandTaskRan-21]
	_ = x[AmbientTaskRan-22]
	_ = x[CatchAllsRan-23]
	_ = x[CatchAllTaskRan-24]
	_ = x[TriggeredTaskRan-25]
	_ = x[SpawnedTaskRan-26]
	_ = x[ScheduledTaskRan-27]
	_ = x[JobTaskRan-28]
	_ = x[GoPluginRan-29]
	_ = x[ExternalTaskBadPath-30]
	_ = x[ExternalTaskBadInterpreter-31]
	_ = x[ExternalTaskRan-32]
	_ = x[ExternalTaskStderrOutput-33]
	_ = x[ExternalTaskErrExit-34]
}

const _Event_name = "IgnoredUserBotDirectMessageAdminCheckPassedAdminCheckFailedMultipleMatchesNoActionAuthNoRunMisconfiguredAuthNoRunPlugNotAvailableAuthRanSuccessAuthRanFailAuthRanMechanismFailedAuthRanFailNormalAuthRanFailOtherAuthNoRunNotFoundElevNoRunMisconfiguredElevNoRunNotAvailableElevRanSuccessElevRanFailElevRanMechanismFailedElevRanFailNormalElevRanFailOtherElevNoRunNotFoundCommandTaskRanAmbientTaskRanCatchAllsRanCatchAllTaskRanTriggeredTaskRanSpawnedTaskRanScheduledTaskRanJobTaskRanGoPluginRanExternalTaskBadPathExternalTaskBadInterpreterExternalTaskRanExternalTaskStderrOutputExternalTaskErrExit"

var _Event_index = [...]uint16{0, 11, 27, 43, 59, 82, 104, 129, 143, 154, 176, 193, 209, 226, 248, 269, 283, 294, 316, 333, 349, 366, 380, 394, 406, 421, 437, 451, 467, 477, 488, 507, 533, 548, 572, 591}

func (i Event) String() string {
	if i < 0 || i >= Event(len(_Event_index)-1) {
		return "Event(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Event_name[_Event_index[i]:_Event_index[i+1]]
}
</file_content file: gopherbot-main/bot/event_string.go>
<preamble file: gopherbot-main/bot/events.go>

</preamble>
<file_content file: gopherbot-main/bot/events.go>
package bot

/* events.go - definitions for message disposition events used by the
integration testing framework. These mostly relate to security, and relate
what happened to a particular message. Note that these are only used for the
'test' and 'terminal' connectors, primarily for development and testing.
*/

//go:generate stringer -type=Event events.go

// Generate String method with: go generate ./bot/

// Event is a type for message disposition events
type Event int

const (
	IgnoredUser Event = iota
	BotDirectMessage
	AdminCheckPassed
	AdminCheckFailed
	MultipleMatchesNoAction
	AuthNoRunMisconfigured
	AuthNoRunPlugNotAvailable
	AuthRanSuccess
	AuthRanFail
	AuthRanMechanismFailed
	AuthRanFailNormal
	AuthRanFailOther
	AuthNoRunNotFound
	ElevNoRunMisconfigured
	ElevNoRunNotAvailable
	ElevRanSuccess
	ElevRanFail
	ElevRanMechanismFailed
	ElevRanFailNormal
	ElevRanFailOther
	ElevNoRunNotFound
	CommandTaskRan
	AmbientTaskRan
	CatchAllsRan
	CatchAllTaskRan
	TriggeredTaskRan
	SpawnedTaskRan
	ScheduledTaskRan
	JobTaskRan
	GoPluginRan
	ExternalTaskBadPath
	ExternalTaskBadInterpreter
	ExternalTaskRan
	ExternalTaskStderrOutput
	ExternalTaskErrExit
)
</file_content file: gopherbot-main/bot/events.go>
<preamble file: gopherbot-main/bot/exclusive.go>

</preamble>
<file_content file: gopherbot-main/bot/exclusive.go>
package bot

import (
	"sync"

	"github.com/lnxjedi/gopherbot/robot"
)

var runQueues = struct {
	m map[string][]chan struct{}
	sync.Mutex
}{
	make(map[string][]chan struct{}),
	sync.Mutex{},
}

// Exclusive lets a plugin or job pipeline request exclusive execution, to prevent
// processes from stepping on each other when it's not safe.
// The string argument ("" allowed) is appended to the pipeline namespace
// to allow for greater granularity; e.g. two builds of different packages
// could use the same pipeline and run safely together, but if it's the same
// package the pipeline might want to queue or just abort. The queueTask
// argument indicates whether the pipeline should queue up the task to be
// restarted, or abort at the end of the current task. When Exclusive returns
// false, the current task should exit. Note that a plugin should only
// set queue to true under rare circumstances; most often it should use
// false and emit an error on failure.
// If the task requests queueing, it will either re-run (if the lock holder
// has finished) or queue up (if not) when the current task exits. When it's
// ready to run, the task will be started from the beginning with the same
// arguments, holding the Exclusive lock, and the call to Exclusive will
// always succeed.
// The safest way to use Exclusive is near the beginning of a pipeline.
func (r Robot) Exclusive(tag string, queueTask bool) (success bool) {
	if r.exclusive {
		// TODO: make sure tag matches, or error! Note that it's legit and normal
		// to call Exclusive twice with the same tag name.
		return true
	}
	_, plugin, job := getTask(r.currentTask)
	isPlugin := plugin != nil
	isJob := job != nil
	w := getLockedWorker(r.tid)
	ns := r.nameSpace
	// The intent here is that simple tasks can only call exclusive in the
	// context of a job pipeline, which is the only case where r.nameSpace
	// is set.
	if !isPlugin && !isJob && queueTask && len(r.nameSpace) == 0 {
		r.Log(robot.Error, "Exclusive called by job or task with queueing outside of job pipeline")
		return false
	}
	if len(ns) == 0 {
		w.Unlock()
		ns = w.getNameSpace(r.currentTask)
		w.Lock()
	}
	defer w.Unlock()
	if len(tag) > 0 {
		tag = ":" + tag
	}
	tag = ns + tag
	w.exclusiveTag = tag
	runQueues.Lock()
	_, exists := runQueues.m[tag]
	if !exists {
		// Take the lock
		Log(robot.Debug, "Exclusive lock '%s' immediately acquired in pipeline '%s', bot #%d", tag, w.pipeName, w.id)
		runQueues.m[tag] = []chan struct{}{}
		w.exclusive = true
		success = true
		runQueues.Unlock()
		return
	}
	runQueues.Unlock()
	// Update state to indicate what to do after callTask()
	if queueTask {
		Log(robot.Debug, "Worker #%d requesting queueing", w.id)
		w.queueTask = true
	} else {
		// When a plugin requests Exclusive, it should handle false
		if plugin != nil {
			Log(robot.Debug, "Worker #%d requesting abort, exclusive lock failed", w.id)
			w.abortPipeline = true
		}
	}
	return
}
</file_content file: gopherbot-main/bot/exclusive.go>
<preamble file: gopherbot-main/bot/filebrain.go>

</preamble>
<file_content file: gopherbot-main/bot/filebrain.go>
package bot

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

var brainPath string
var fbhandler robot.Handler

type fbConfig struct {
	BrainDirectory string // path to brain files
	Encode         bool   // whether to base64 encode memories, default true
}

var fb fbConfig

func (fb *fbConfig) Store(k string, b *[]byte) error {
	k = strings.Replace(k, `/`, ":", -1)
	k = strings.Replace(k, `\`, ":", -1)
	datumPath := filepath.Join(brainPath, k)
	if fb.Encode {
		if err := WriteBase64File(datumPath, b); err != nil {
			return fmt.Errorf("writing datum '%s': %v", datumPath, err)
		}
		return nil
	}
	if err := os.WriteFile(datumPath, *b, 0600); err != nil {
		return fmt.Errorf("Writing datum '%s': %v", datumPath, err)
	}
	return nil
}

func (fb *fbConfig) Retrieve(k string) (*[]byte, bool, error) {
	k = strings.Replace(k, `/`, ":", -1)
	k = strings.Replace(k, `\`, ":", -1)
	datumPath := filepath.Join(brainPath, k)
	if _, err := os.Stat(datumPath); err == nil {
		datum, err := ReadBinaryFile(datumPath)
		if err != nil {
			err = fmt.Errorf("Error reading file \"%s\": %v", datumPath, err)
			fbhandler.Log(robot.Error, err.Error())
			return nil, false, err
		}
		return datum, true, nil
	}
	// Memory doesn't exist yet
	return nil, false, nil
}

func (fb *fbConfig) List() ([]string, error) {
	d, err := os.Open(brainPath)
	if err != nil {
		return []string{}, err
	}
	keys, err := d.Readdirnames(0)
	if err != nil {
		return []string{}, err
	}
	return keys, nil
}

func (fb *fbConfig) Delete(key string) (err error) {
	err = os.Remove(filepath.Join(brainPath, key))
	return
}

// The file brain doesn't need the logger, but other brains might
func fbprovider(r robot.Handler) robot.SimpleBrain {
	fbhandler = r
	fbhandler.GetBrainConfig(&fb)
	if len(fb.BrainDirectory) == 0 {
		fbhandler.Log(robot.Fatal, "BrainConfig missing value for BrainDirectory required by 'file' brain")
	}
	brainPath = fb.BrainDirectory
	if err := r.GetDirectory(brainPath); err != nil {
		fbhandler.Log(robot.Fatal, "Getting brain directory \"%s\": %v", brainPath, err)
	}
	fbhandler.Log(robot.Info, "Initialized file-backed brain with memories directory: '%s'", brainPath)
	return &fb
}

func init() {
	RegisterSimpleBrain("file", fbprovider)
}
</file_content file: gopherbot-main/bot/filebrain.go>
<preamble file: gopherbot-main/bot/go_jobs.go>

</preamble>
<file_content file: gopherbot-main/bot/go_jobs.go>
package bot

import (
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

func pausenotifies(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	notifies := make(map[string][]string)
	pausedJobs.Lock()
	for job, user := range pausedJobs.jobs {
		joblist, ok := notifies[user]
		if ok {
			joblist = append(joblist, job)
		} else {
			joblist = []string{job}
		}
		notifies[user] = joblist
	}
	pausedJobs.Unlock()
	for user, jobs := range notifies {
		ret := m.SendUserMessage(user, "Reminder, you have paused jobs: %s", strings.Join(jobs, ", "))
		if ret != robot.Ok {
			m.Log(robot.Error, "Failed sending reminder to user %s about paused jobs: %s", user, strings.Join(jobs, ", "))
		}
	}
	return
}

func init() {
	RegisterJob("pause-notifies", robot.JobHandler{Handler: pausenotifies})
}
</file_content file: gopherbot-main/bot/go_jobs.go>
<preamble file: gopherbot-main/bot/handler.go>

</preamble>
<file_content file: gopherbot-main/bot/handler.go>
package bot

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/lnxjedi/gopherbot/robot"
)

// an empty object type for passing a Handler to the connector.
type handler struct{}

// dummy var to pass a handler
var handle = handler{}

/* Handle incoming messages and other callbacks from the connector. */

// GetLogLevel returns the bot's current loglevel, mainly for the
// connector to make it's own decision about logging
func (h handler) GetLogLevel() robot.LogLevel {
	return getLogLevel()
}

// SetTerminalWriter let's the terminal connector set the output writer
// for logging of Warn and Error logs.
func (h handler) SetTerminalWriter(w io.Writer) {
	botStdErrLogger.SetOutput(w)
	terminalWriter = w
}

// GetInstallPath gets the path to the bot's install dir -
// the location of default configuration and stock external plugins.
func (h handler) GetInstallPath() string {
	return installPath
}

// GetConfigPath gets the path to the bot's (supposedly writable) configuration
// directory. This is the config path if specified, otherwise the install
// directory.
func (h handler) GetConfigPath() string {
	if len(configPath) > 0 {
		return configPath
	}
	return installPath
}

// RaisePriv raises privilege for connectors, brains, etc.
func (h handler) RaisePriv(reason string) {
	raiseThreadPriv(reason)
}

// A new worker is created for every incoming message, and may or may not end
// up creating a new pipeline. Workers are also created by scheduled jobs
// and Spawned jobs, in which case a pipeline is always created.
type worker struct {
	User            string                      // The user who sent the message; this can be modified for replying to an arbitrary user
	Channel         string                      // The channel where the message was received, or "" for a direct message. This can be modified to send a message to an arbitrary channel.
	ProtocolUser    string                      // The username or <userid> to be sent in connector methods
	ProtocolChannel string                      // the channel name or <channelid> where the message originated
	Protocol        robot.Protocol              // slack, terminal, test, others; used for interpreting rawmsg or sending messages with Format = 'Raw'
	Incoming        *robot.ConnectorMessage     // raw struct of message sent by connector
	Format          robot.MessageFormat         // robot's default message format
	id              int                         // integer worker ID used when being registered as an active pipeline
	tasks           *taskList                   // Pointers to current task configuration at start of pipeline
	maps            *userChanMaps               // Pointer to current user / channel maps struct
	repositories    map[string]robot.Repository // Set of configured repositories
	cfg             *configuration              // Active configuration when this context was created
	BotUser         bool                        // set for bots/programs that should never match ambient messages
	listedUser      bool                        // set for users listed in the UserRoster; ambient messages don't match unlisted users by default
	isCommand       bool                        // Was the message directed at the robot, dm or by mention
	cmdMode         string                      // one of "alias", "name", "direct" - for disambiguation
	msg, fmsg       string                      // the message text sent; without robot name/alias, and with for message matching
	automaticTask   bool                        // set for scheduled & triggers jobs, where user security restrictions don't apply
	*pipeContext                                // pointer to the pipeline context
	sync.Mutex                                  // Lock to protect the bot context when pipeline running
}

// clone a worker for a new execution context
func (w *worker) clone() *worker {
	clone := &worker{
		User:            w.User,
		ProtocolUser:    w.ProtocolUser,
		Channel:         w.Channel,
		ProtocolChannel: w.ProtocolChannel,
		Incoming:        w.Incoming,
		BotUser:         w.BotUser,
		listedUser:      w.listedUser,
		id:              getWorkerID(),
		cfg:             w.cfg,
		tasks:           w.tasks,
		maps:            w.maps,
		repositories:    w.repositories,
		automaticTask:   w.automaticTask,
		Protocol:        w.Protocol,
		Format:          w.Format,
		msg:             w.msg,
		fmsg:            w.fmsg,
	}
	if w.pipeContext != nil {
		w.Lock()
		clone.pipeContext = &pipeContext{
			pipeName:    w.pipeName,
			pipeDesc:    w.pipeDesc,
			ptype:       w.ptype,
			elevated:    w.elevated,
			environment: make(map[string]string),
		}
		w.Unlock()
	}
	return clone
}

// for logging raw messages from channels
var chanLoggers = struct {
	sync.Mutex
	channels map[string]*log.Logger
}{
	Mutex:    sync.Mutex{},
	channels: make(map[string]*log.Logger),
}

// ChannelMessage accepts an incoming channel message from the connector.
// func (h handler) IncomingMessage(channelName, userName, messageFull string, raw interface{}) {
func (h handler) IncomingMessage(inc *robot.ConnectorMessage) {
	// Note: zero-len channel name and ID is valid; true of direct messages for some connectors
	if len(inc.UserName) == 0 && len(inc.UserID) == 0 {
		Log(robot.Error, "Incoming message with no username or user ID")
		return
	}
	currentUCMaps.Lock()
	maps := currentUCMaps.ucmap
	currentUCMaps.Unlock()
	var channelName, userName, ProtocolChannel, ProtocolUser string
	var BotUser bool

	/* Make sure some form of User and Channel are set
	 */
	ProtocolChannel = bracket(inc.ChannelID)
	if !inc.DirectMessage {
		if cn, ok := maps.channelID[inc.ChannelID]; ok {
			channelName = cn.ChannelName
		} else if len(inc.ChannelName) > 0 {
			channelName = inc.ChannelName
		} else if len(inc.ChannelID) > 0 {
			channelName = bracket(inc.ChannelID)
		}
	} // ProtocolChannel / channelName should be "" for DM
	ProtocolUser = bracket(inc.UserID)
	listedUser := false
	if un, ok := maps.userID[inc.UserID]; ok {
		userName = un.UserName
		BotUser = un.BotUser
		listedUser = true
	} else if len(inc.UserName) > 0 {
		userName = inc.UserName
	} else {
		userName = bracket(inc.UserID)
	}
	protocol := getProtocol(inc.Protocol)

	messageFull := inc.MessageText
	var message string

	chanLoggers.Lock()
	clog, ok := chanLoggers.channels[channelName]
	chanLoggers.Unlock()
	if ok {
		clog.Printf("c:%s/%s(m:%s/t:%s/%t), u:%s/%s, m:'%s'\n", channelName, ProtocolChannel, inc.MessageID, inc.ThreadID, inc.ThreadedMessage, userName, ProtocolUser, messageFull)
	}
	Log(robot.Trace, "Incoming message in channel '%s/%s' from user '%s/%s': %s", channelName, ProtocolChannel, userName, ProtocolUser, messageFull)
	// When command == true, the message was directed at the bot
	isCommand := false
	logChannel := channelName

	currentCfg.RLock()
	ignoreUsers := currentCfg.ignoreUsers
	ignoreUnlisted := currentCfg.ignoreUnlistedUsers
	botAlias := currentCfg.alias
	currentCfg.RUnlock()
	if !listedUser && ignoreUnlisted {
		Log(robot.Debug, "IgnoreUnlistedUsers - ignoring: %s / %s", inc.UserID, userName)
		emit(IgnoredUser)
		return
	}
	for _, user := range ignoreUsers {
		if strings.EqualFold(userName, user) {
			Log(robot.Debug, "User listed in IgnoreUsers, ignoring: %s", userName)
			emit(IgnoredUser)
			return
		}
	}
	cmdMode := ""
	// Log(robot.Debug, "DEBUG: incoming %+v", inc)
	if inc.BotMessage {
		isCommand = true
		message = messageFull
		cmdMode = "alias" // technically not true, but makes more sense
	} else {
		regexes.RLock()
		preRegex := regexes.preRegex
		postRegex := regexes.postRegex
		bareRegex := regexes.bareRegex
		regexes.RUnlock()
		if preRegex != nil {
			matches := preRegex.FindStringSubmatch(messageFull)
			if len(matches) == 3 {
				isCommand = true
				name := matches[1]
				if name == string(botAlias) {
					cmdMode = "alias"
				} else {
					cmdMode = "name"
				}
				message = matches[2]
			}
		}
		if !isCommand && postRegex != nil {
			matches := postRegex.FindStringSubmatch(messageFull)
			if len(matches) == 3 {
				isCommand = true
				cmdMode = "name"
				message = matches[1] + matches[2]
			}
		}
		if !isCommand && bareRegex != nil {
			if bareRegex.MatchString(messageFull) {
				if messageFull == string(botAlias) {
					cmdMode = "alias"
				} else {
					cmdMode = "name"
				}
				isCommand = true
			}
		}
		if !isCommand {
			message = messageFull
		}
	}

	if inc.DirectMessage {
		isCommand = true
		// When the user addresses the robot by name or alias in a DM,
		// we stick with that, otherwise we use "direct" so the
		// plugin can try to be smart.
		if len(cmdMode) == 0 {
			cmdMode = "direct"
		}
		logChannel = "(direct message)"
		// We don't support threads in DMs; we blank out the thread
		// so replies will match.
		inc.ThreadID = ""
	}

	currentCfg.RLock()
	cfg := currentCfg.configuration
	t := currentCfg.taskList
	currentCfg.RUnlock()

	confLock.RLock()
	repolist := repositories
	confLock.RUnlock()

	// Create the worker and a goroutine to process the message and carry state,
	// which may eventually run a pipeline.
	w := &worker{
		User:            userName,
		Channel:         channelName,
		ProtocolUser:    ProtocolUser,
		ProtocolChannel: ProtocolChannel,
		Protocol:        protocol,
		Incoming:        inc,
		Format:          cfg.defaultMessageFormat,
		tasks:           t,
		cfg:             cfg,
		maps:            maps,
		BotUser:         BotUser,
		listedUser:      listedUser,
		id:              getWorkerID(),
		repositories:    repolist,
		isCommand:       isCommand,
		cmdMode:         cmdMode,
		msg:             message,
		fmsg:            messageFull,
	}
	if w.Incoming.DirectMessage {
		Log(robot.Debug, "Received private message from user '%s'", userName)
	} else {
		Log(robot.Debug, "Message '%s'/id '%s' from user '%s' in channel '%s'/thread '%s' (threaded: %t); isCommand: %t; cmdMode: %s", message, inc.MessageID, userName, logChannel, inc.ThreadID, inc.ThreadedMessage, isCommand, cmdMode)
	}
	go w.handleMessage()
}

/* NOTE NOTE NOTE: Connector, Brain and History do not change after start-up, and that
probably shouldn't change. There's no real good reason to allow it, and not changing means
we don't need to worry about locking. When absolutely necessary, there's always "restart".
*/

// GetProtocolConfig unmarshals the connector's configuration data into a provided struct
func (h handler) GetProtocolConfig(v interface{}) error {
	err := json.Unmarshal(protocolConfig, v)
	return err
}

// GetBrainConfig unmarshals the brain's configuration data into a provided struct
func (h handler) GetBrainConfig(v interface{}) error {
	err := json.Unmarshal(brainConfig, v)
	return err
}

// GetHistoryConfig unmarshals the history provider's configuration data into a provided struct
func (h handler) GetHistoryConfig(v interface{}) error {
	err := json.Unmarshal(historyConfig, v)
	return err
}

// Log logs a message to the robot's log file (or stderr)
func (h handler) Log(l robot.LogLevel, m string, v ...interface{}) {
	Log(l, m, v...)
}

// GetDirectory verfies or creates a directory with perms 0750, returning an error on failure.
func (h handler) GetDirectory(p string) error {
	if len(p) == 0 {
		return errors.New("invalid 0-length path in GetDirectory")
	}
	dperm := os.FileMode(0750)
	if filepath.IsAbs(p) {
		p = filepath.Clean(p)
	}
	if ds, err := os.Stat(p); err == nil {
		if !ds.Mode().IsDir() {
			return fmt.Errorf("getting directory; '%s' exists but is not a directory", p)
		}
		if err := os.Chmod(p, dperm); err != nil {
			return err
		}
		return nil
	}
	raiseThreadPriv(fmt.Sprintf("getting directory: %s", p))
	if err := os.MkdirAll(p, dperm); err != nil {
		return err
	}
	return nil
}

// SetBotID let's the connector set the bot's internal ID
func (h handler) SetBotID(id string) {
	currentCfg.Lock()
	currentCfg.botinfo.UserID = id
	currentCfg.Unlock()
}

// SetBotMention set's the @(mention) string, for regexes
func (h handler) SetBotMention(m string) {
	if len(m) == 0 {
		return
	}
	Log(robot.Info, "Protocol set bot mention string to: %s", m)
	currentCfg.Lock()
	currentCfg.botinfo.protoMention = m
	currentCfg.Unlock()
	updateRegexes()
}
</file_content file: gopherbot-main/bot/handler.go>
<preamble file: gopherbot-main/bot/history.go>

</preamble>
<file_content file: gopherbot-main/bot/history.go>
package bot

/*
	history.go provides the mechanism and methods for storing and retrieving
	job / plugin run histories of stdout/stderr for a given run. Each time
	a job / plugin is initiated by a trigger, scheduled job, or user command,
	a new history file is started if KeepLogs is != 0 for the job/plugin.
	The history provider will store histories up to some maximum, and return
	that history based on the index.
*/

import (
	"log"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

const histPrefix = "bot:histories:"

// Memory that holds a Ref -> historyLookup record
const histLookup = "bot:histories-lookup"

type historyLog struct {
	LogIndex   int
	Ref        string // 6 hex digits from worker ID
	CreateTime string
	Descriptor string // usually just the branch
}

type historyLookup struct {
	Tag   string
	Index int
}

type pipeHistory struct {
	NextIndex          int
	Histories          []historyLog
	ExtendedNamespaces []string
}

// start a new history log and manage memories
/*
Args:
- tag: pipeline name or job:extended_namespace; newHistory prepends histPrefix
- eid: 8 random hex digits generated in registerActive, for lookups
- descriptor: usually the branch for a repo; differentiates logs for logs
  aggregated with the same log tag, to prevent e.g. entirely separate log
  histories for every feature branch of a build - currently only used
  in ExtendNamespace
- wid: w.id, fallback index when memory fails
- keep: how many of this log to keep
Returns:
- logger: always a history logger, even if it's memory fallback
- url: URL for the log if available
- ref: 8 hex digit reference for e.g. "email|view log abcdef01"
- idx: the run index, or wid fallback - can always be used for tail-log, mail-log in pipeline
*/
func newLogger(tag, eid, descriptor string, wid, keep int) (logger robot.HistoryLogger, url, ref string, idx int) {
	var ph pipeHistory
	// limit the number of logs kept to 64 =< 4096/64 (back of napkin
	// calculation for listing logs w/ max message size of 4096)
	if keep > 64 {
		keep = 64
	}
	// Check out the memory for this specific history
	key := histPrefix + tag
	phtok, _, phret := checkoutDatum(key, &ph, true)
	if phret != robot.Ok {
		Log(robot.Error, "Checking out '%s', no history will be remembered for this pipeline", tag)
		idx = wid
		keep = 0
	} else {
		idx = ph.NextIndex
		ph.NextIndex++
		if ph.NextIndex == maxIndex {
			ph.NextIndex = 0
		}
		// Check out the memory mapping Ref's to logs
		var hmtok string
		var hmret robot.RetVal
		var remove []historyLog
		hm := make(map[string]historyLookup)
		if keep > 0 {
			hmtok, _, hmret = checkoutDatum(histLookup, &hm, true)
			if hmret == robot.Ok {
				ref = eid
				hl := historyLookup{tag, idx}
				hm[ref] = hl
			} else {
				Log(robot.Error, "Checking out '%s' failed for '%s', no lookups will be available for this log", histLookup, tag)
			}
			var start time.Time
			currentCfg.RLock()
			tz := currentCfg.timeZone
			currentCfg.RUnlock()
			if tz != nil {
				start = time.Now().In(tz)
			} else {
				start = time.Now()
			}
			hist := historyLog{
				LogIndex:   idx,
				Ref:        ref,
				Descriptor: descriptor,
				CreateTime: start.Format("Jan 2 15:04:05"),
			}
			ph.Histories = append(ph.Histories, hist)
			l := len(ph.Histories)
			if l > keep {
				remove = ph.Histories[0 : l-keep]
				ph.Histories = ph.Histories[l-keep:]
			}
		}
		mret := updateDatum(key, phtok, ph)
		if mret != robot.Ok {
			Log(robot.Error, "Updating '%s', no history will be remembered for the pipeline", tag)
			idx = wid
			keep = 0
		} else if keep > 0 && hmret == robot.Ok {
			for _, rm := range remove {
				delete(hm, rm.Ref)
			}
			mret := updateDatum(histLookup, hmtok, hm)
			if mret != robot.Ok {
				Log(robot.Error, "Updating '%s' failed for '%s', no lookups will be available for this log", histLookup, tag)
			}
		}
	}
	var err error
	logger, err = interfaces.history.NewLog(tag, idx, keep)
	if err != nil {
		Log(robot.Error, "Starting history for '%s' failed (%v) - falling back to memory log", tag, err)
		idx = wid
		ref = ""
		logger, _ = memHistories.NewLog(tag, idx, 0)
	} else {
		if keep > 0 {
			url, _ = interfaces.history.GetLogURL(tag, idx)
		}
	}
	return
}

// Map of registered history providers
var historyProviders = make(map[string]func(robot.Handler) robot.HistoryProvider)

// RegisterHistoryProvider allows history implementations to register a function
// with a named provider type that returns a HistoryProvider interface.
func RegisterHistoryProvider(name string, provider func(robot.Handler) robot.HistoryProvider) {
	if stopRegistrations {
		return
	}
	if historyProviders[name] != nil {
		log.Fatal("Attempted registration of duplicate history provider name:", name)
	}
	historyProviders[name] = provider
}
</file_content file: gopherbot-main/bot/history.go>
<preamble file: gopherbot-main/bot/http.go>

</preamble>
<file_content file: gopherbot-main/bot/http.go>
package bot

/* http.go translates posted JSON to Robot method calls, then packages
   and returns the JSON response.
*/

import (
	"encoding/base64"
	"encoding/json"
	"io"
	"net/http"

	"github.com/lnxjedi/gopherbot/robot"
)

type jsonFunction struct {
	FuncName string
	Format   string
	CallerID string
	FuncArgs json.RawMessage
}

// Types for FuncArgs

type attribute struct {
	Attribute string
}

type elevate struct {
	Immediate bool
}

type userattr struct {
	User      string
	Attribute string
}

type logmessage struct {
	Level   string
	Message string
	Base64  bool
}

type channelthreadmessage struct {
	Channel string
	Thread  string
	Message string
	Base64  bool
}

type taskcall struct {
	Name    string
	CmdArgs []string
}

type cmdcall struct {
	Plugin  string
	Command string
}

type paramcall struct {
	Name, Value string
	Base64      bool
}

type wdcall struct {
	Path string
}

// Something to be placed in ephemeral memory
type ephemeralmemory struct {
	Key, Value string
	Base64     bool
	Shared     bool
}

// Something to be recalled from ephemeral memory
type ephemeralrecollection struct {
	Key    string
	Base64 bool
	Shared bool
}

// Something to be remembered in long term memory
type memory struct {
	Key   string
	Token string
	Datum json.RawMessage
}

// Something to be recalled from long term memory
type recollection struct {
	Key string
	RW  bool
}

// Request for exclusive execution
type exclusive struct {
	Tag       string
	QueueTask bool
}

type usermessage struct {
	User    string
	Message string
	Base64  bool
}

type userchannelthreadmessage struct {
	User    string
	Channel string
	Thread  string
	Message string
	Base64  bool
}

type replyrequest struct {
	RegexID string
	User    string
	Channel string
	Thread  string
	Prompt  string
	Base64  bool
}

type extns struct {
	Extend    string
	Histories int
}

// These are only for json marshalling
type boolresponse struct {
	Boolean bool
}

type stringresponse struct {
	StrVal string
}

type boolretresponse struct {
	Boolean bool
	RetVal  int
}

type botretvalresponse struct {
	RetVal int
}

type checkoutresponse struct {
	LockToken string
	Exists    bool
	Datum     interface{}
	RetVal    int
}

type replyresponse struct {
	Reply  string
	RetVal int
}

// decode decodes a base64 string, primarily for the bash library
func decode(msg string) string {
	decoded, err := base64.StdEncoding.DecodeString(msg)
	if err != nil {
		Log(robot.Error, "Unable to decode base64 message %s: %v", msg, err)
		return msg
	}
	return string(decoded)
}

func getArgs(rw http.ResponseWriter, jsonargs *json.RawMessage, args interface{}) bool {
	err := json.Unmarshal(*jsonargs, args)
	if err != nil {
		rw.WriteHeader(http.StatusBadRequest)
		Log(robot.Error, "Couldn't deciper JSON args: ", err)
		return false
	}
	return true
}

func sendReturn(rw http.ResponseWriter, ret interface{}) {
	d, err := json.Marshal(ret)
	if err != nil { // this should never happen
		Log(robot.Fatal, "BUG in bot/http.go:sendReturn, error marshalling JSON: %v", err)
	}
	rw.WriteHeader(http.StatusOK)
	rw.Write(d)
}

func (h handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	data, err := io.ReadAll(req.Body)
	if err != nil {
		Log(robot.Fatal, err.Error())
	}
	defer req.Body.Close()

	var f jsonFunction
	err = json.Unmarshal(data, &f)
	if err != nil {
		rw.WriteHeader(http.StatusBadRequest)
		Log(robot.Error, "Couldn't decipher JSON command: ", err)
		return
	}

	if f.CallerID == "" {
		rw.WriteHeader(http.StatusBadRequest)
		Log(robot.Error, "JSON function '%s' called with empty CallerID; args: %v", f.FuncName, f.FuncArgs)
		return
	}

	// Look up the Robot
	taskLookup.RLock()
	r, ok := taskLookup.e[f.CallerID]
	taskLookup.RUnlock()
	if !ok {
		rw.WriteHeader(http.StatusBadRequest)
		Log(robot.Error, "JSON function '%s' called with invalid CallerID '%s'; args: %s", f.FuncName, f.CallerID, f.FuncArgs)
		return
	}
	if len(f.Format) > 0 {
		r.Format = setFormat(f.Format)
	} else {
		r.Format = r.cfg.defaultMessageFormat
	}
	task, _, _ := getTask(r.currentTask)
	Log(robot.Trace, "Task '%s' calling function '%s' in channel '%s' for user '%s'", task.name, f.FuncName, r.Channel, r.User)

	var (
		attr  *robot.AttrRet
		reply string
		ret   robot.RetVal
	)
	switch f.FuncName {
	case "CheckAdmin":
		bret := r.CheckAdmin()
		sendReturn(rw, boolresponse{Boolean: bret})
		return
	case "Subscribe":
		bret := r.Subscribe()
		sendReturn(rw, boolresponse{Boolean: bret})
		return
	case "Unsubscribe":
		bret := r.Unsubscribe()
		sendReturn(rw, boolresponse{Boolean: bret})
		return
	case "GetRepoData":
		sendReturn(rw, r.GetRepoData())
		return
	case "AddTask", "AddJob", "FinalTask", "FailTask", "SpawnJob":
		var ts taskcall
		if !getArgs(rw, &f.FuncArgs, &ts) {
			return
		}
		var ret robot.RetVal
		switch f.FuncName {
		case "AddJob":
			ret = r.AddJob(ts.Name, ts.CmdArgs...)
		case "AddTask":
			ret = r.AddTask(ts.Name, ts.CmdArgs...)
		case "FinalTask":
			ret = r.FinalTask(ts.Name, ts.CmdArgs...)
		case "FailTask":
			ret = r.FailTask(ts.Name, ts.CmdArgs...)
		case "SpawnJob":
			ret = r.SpawnJob(ts.Name, ts.CmdArgs...)
		default:
			return
		}
		sendReturn(rw, &botretvalresponse{int(ret)})
		return
	case "AddCommand", "FinalCommand", "FailCommand":
		var cc cmdcall
		if !getArgs(rw, &f.FuncArgs, &cc) {
			return
		}
		var ret robot.RetVal
		switch f.FuncName {
		case "AddCommand":
			ret = r.AddCommand(cc.Plugin, cc.Command)
		case "FinalCommand":
			ret = r.FinalCommand(cc.Plugin, cc.Command)
		case "FailCommand":
			ret = r.FailCommand(cc.Plugin, cc.Command)
		default:
			return
		}
		sendReturn(rw, &botretvalresponse{int(ret)})
		return
	case "SetParameter":
		var param paramcall
		if !getArgs(rw, &f.FuncArgs, &param) {
			return
		}
		if param.Base64 {
			param.Name = decode(param.Name)
			param.Value = decode(param.Value)
		}
		success := r.SetParameter(param.Name, param.Value)
		sendReturn(rw, boolresponse{Boolean: success})
	case "SetWorkingDirectory":
		var wd wdcall
		if !getArgs(rw, &f.FuncArgs, &wd) {
			return
		}
		success := r.SetWorkingDirectory(wd.Path)
		sendReturn(rw, boolresponse{Boolean: success})
	case "ExtendNamespace":
		var en extns
		if !getArgs(rw, &f.FuncArgs, &en) {
			return
		}
		success := r.ExtendNamespace(en.Extend, en.Histories)
		sendReturn(rw, boolresponse{Boolean: success})
	case "Exclusive":
		var e exclusive
		if !getArgs(rw, &f.FuncArgs, &e) {
			return
		}
		success := r.Exclusive(e.Tag, e.QueueTask)
		sendReturn(rw, boolresponse{Boolean: success})
	case "Elevate":
		var e elevate
		if !getArgs(rw, &f.FuncArgs, &e) {
			return
		}
		success := r.Elevate(e.Immediate)
		sendReturn(rw, boolresponse{Boolean: success})
		return
	case "CheckoutDatum":
		var rec recollection
		if !getArgs(rw, &f.FuncArgs, &rec) {
			return
		}
		var datum interface{}
		l, e, brv := r.CheckoutDatum(rec.Key, &datum, rec.RW)
		sendReturn(rw, checkoutresponse{
			LockToken: l,
			Exists:    e,
			Datum:     datum,
			RetVal:    int(brv),
		})
		return
	case "CheckinDatum":
		var m memory
		if !getArgs(rw, &f.FuncArgs, &m) {
			return
		}
		r.CheckinDatum(m.Key, m.Token)
		sendReturn(rw, &botretvalresponse{int(robot.Ok)})
		return
	case "UpdateDatum":
		var m memory
		if !getArgs(rw, &f.FuncArgs, &m) {
			return
		}
		var key string
		w := getLockedWorker(r.tid)
		w.Unlock()
		ns := w.getNameSpace(r.currentTask)
		key = ns + ":" + m.Key
		// Since we're getting raw JSON (=[]byte), we call update directly.
		// See brain.go
		ret = update(key, m.Token, (*[]byte)(&m.Datum))
		sendReturn(rw, &botretvalresponse{int(ret)})
		return
	case "Remember":
		var m ephemeralmemory
		if !getArgs(rw, &f.FuncArgs, &m) {
			return
		}
		if m.Base64 {
			m.Key = decode(m.Key)
			m.Value = decode(m.Value)
		}
		r.Remember(m.Key, m.Value, m.Shared)
		sendReturn(rw, &botretvalresponse{int(robot.Ok)})
		return
	case "RememberThread":
		var m ephemeralmemory
		if !getArgs(rw, &f.FuncArgs, &m) {
			return
		}
		if m.Base64 {
			m.Key = decode(m.Key)
			m.Value = decode(m.Value)
		}
		r.RememberThread(m.Key, m.Value, m.Shared)
		sendReturn(rw, &botretvalresponse{int(robot.Ok)})
		return
	case "Recall":
		var m ephemeralrecollection
		if !getArgs(rw, &f.FuncArgs, &m) {
			return
		}
		if m.Base64 {
			m.Key = decode(m.Key)
		}
		s := r.Recall(m.Key, m.Shared)
		sendReturn(rw, &stringresponse{s})
		return
	case "GetTaskConfig":
		if task.Config == nil {
			Log(robot.Error, "GetTaskConfig called by external script '%s', but no config found.", task.name)
			sendReturn(rw, handler{})
			return
		}
		sendReturn(rw, task.Config)
		return
	case "GetSenderAttribute", "GetBotAttribute":
		var a attribute
		if !getArgs(rw, &f.FuncArgs, &a) {
			return
		}
		if f.FuncName == "GetBotAttribute" {
			attr = r.GetBotAttribute(a.Attribute)
		} else {
			attr = r.GetSenderAttribute(a.Attribute)
		}
		sendReturn(rw, attr)
		return
	case "GetUserAttribute":
		var ua userattr
		if !getArgs(rw, &f.FuncArgs, &ua) {
			return
		}
		attr = r.GetUserAttribute(ua.User, ua.Attribute)
		sendReturn(rw, attr)
		return
	case "Log":
		var lm logmessage
		if !getArgs(rw, &f.FuncArgs, &lm) {
			return
		}
		l := logStrToLevel(lm.Level)
		if lm.Base64 {
			lm.Message = decode(lm.Message)
		}
		r.Log(l, lm.Message)
		sendReturn(rw, &botretvalresponse{int(robot.Ok)})
		return
	case "SendChannelThreadMessage":
		var ctm channelthreadmessage
		if !getArgs(rw, &f.FuncArgs, &ctm) {
			return
		}
		if ctm.Base64 {
			ctm.Message = decode(ctm.Message)
		}
		sendReturn(rw, &botretvalresponse{
			int(r.SendChannelThreadMessage(ctm.Channel, ctm.Thread, ctm.Message)),
		})
		return
	case "SendUserChannelThreadMessage":
		var uctm userchannelthreadmessage
		if !getArgs(rw, &f.FuncArgs, &uctm) {
			return
		}
		if uctm.Base64 {
			uctm.Message = decode(uctm.Message)
		}
		sendReturn(rw, &botretvalresponse{
			int(r.SendUserChannelThreadMessage(uctm.User, uctm.Channel, uctm.Thread, uctm.Message)),
		})
		return
	case "SendUserMessage":
		var um usermessage
		if !getArgs(rw, &f.FuncArgs, &um) {
			return
		}
		if um.Base64 {
			um.Message = decode(um.Message)
		}
		sendReturn(rw, &botretvalresponse{
			int(r.SendUserMessage(um.User, um.Message)),
		})
		return
	case "PromptUserChannelThreadForReply":
		var rr replyrequest
		if !getArgs(rw, &f.FuncArgs, &rr) {
			return
		}
		if rr.Base64 {
			rr.Prompt = decode(rr.Prompt)
		}
		reply, ret = r.promptInternal(rr.RegexID, rr.User, rr.Channel, rr.Thread, rr.Prompt)
		sendReturn(rw, &replyresponse{reply, int(ret)})
		return
	// NOTE: "Say", "Reply", PromptForReply and PromptUserForReply are implemented
	// in the scripting libraries
	default:
		Log(robot.Error, "Bad function name: %s", f.FuncName)
		rw.WriteHeader(http.StatusBadRequest)
		return
	}
}
</file_content file: gopherbot-main/bot/http.go>
<preamble file: gopherbot-main/bot/jobbuiltins.go>

</preamble>
<file_content file: gopherbot-main/bot/jobbuiltins.go>
package bot

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

/*

Job builtins are special:
- They're available in every channel
- Permissions are checked against the job being operated on, not job builtin

*/

const histPageSize = 2048 // how much history to display at a time

func init() {
	RegisterPlugin("builtin-history", robot.PluginHandler{Handler: jobhistory})
	RegisterPlugin("builtin-jobcmd", robot.PluginHandler{Handler: jobcommands})
}

func jobcommands(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	tasks := r.tasks
	if command == "init" {
		return
	}
	switch command {
	case "jobs":
		var jl []string
		alljobs := len(args[0]) > 0
		if alljobs {
			jl = []string{"Here's a list of all the jobs I know about:"}
		} else {
			jl = []string{"Here's a list of jobs for this channel:"}
		}
		for _, t := range tasks.t[1:] {
			if ok, _ := r.jobVisible(t, alljobs, true); !ok {
				continue
			}
			task, _, _ := getTask(t)
			after := ""
			if task.Disabled {
				after = fmt.Sprintf(" (disabled: %s)", task.reason)
			}
			if alljobs {
				jl = append(jl, fmt.Sprintf("%s (channel: %s)%s", task.name, task.Channel, after))
			} else {
				jl = append(jl, fmt.Sprintf("%s%s", task.name, after))
			}
		}
		if len(jl) == 1 {
			if alljobs {
				r.Say("I dont' have any jobs configured")
				return
			}
			r.Say("I don't see any jobs configured for this channel")
			return
		}
		r.Say(strings.Join(jl, "\n"))
	case "builds":
		rl := []string{"Here's a list of all the repositories I can build:"}
		for repo := range r.repositories {
			rl = append(rl, repo)
		}
		if len(rl) > 1 {
			r.MessageFormat(robot.Variable).Say(strings.Join(rl, "\n"))
		} else {
			r.Say("I don't have any repositories in my repositories.yaml")
		}
	}
	return
}

func emailhistory(r Robot, user, address, spec string, run int) (retval robot.TaskRetVal) {
	var buff []byte
	retval, buff = getLogMail(spec, run)
	if retval != robot.Normal {
		r.Say("Log for '%s', run %d not available", spec, run)
		return
	}
	body := new(bytes.Buffer)
	body.Write([]byte("<pre>\n"))
	body.Write(buff)
	body.Write([]byte("\n</pre>"))
	subject := fmt.Sprintf("Log for pipeline '%s', run %d", spec, run)
	var ret robot.RetVal
	if len(user) > 0 {
		ret = r.EmailUser(user, subject, body, true)
	} else if len(address) > 0 {
		ret = r.EmailAddress(address, subject, body, true)
	} else {
		ret = r.Email(subject, body, true)
	}
	if ret != robot.Ok {
		r.Reply("There was a problem emailing the history log, contact an administrator")
		return
	}
	r.Say("Email sent")
	return
}

func jobhistory(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	if command == "init" {
		return
	}
	r := m.(Robot)
	w := getLockedWorker(r.tid)
	w.Unlock()

	var histRef, histSpec, jobName, buildSpec, branch, index, user, address string
	var idx int

	switch command {
	case "maillog":
		histRef = args[0]
		user = args[1]
		address = args[2]
	case "taillog", "linklog":
		histRef = args[0]
	case "joblogs":
		jobName = args[0]
	case "buildlogs":
		buildSpec = args[0]
		branch = args[1]
	}

	if len(index) > 0 {
		var err error
		idx, err = strconv.Atoi(index)
		if err != nil {
			r.Say("Unable to convert '%s' to an index", index)
			return
		}
	}

	if len(histRef) > 0 {
		lmap := make(map[string]historyLookup)
		_, _, lret := checkoutDatum(histLookup, &lmap, false)
		if lret != robot.Ok {
			r.Say("There was a memory error looking up that log")
			r.Log(robot.Error, "Looking up '%s': %s", histLookup, lret)
			return
		}
		hl, ok := lmap[histRef]
		if !ok {
			r.Say("Log ref '%s' not found, possibly expired?", histRef)
			r.Log(robot.Warn, "Log ref '%s' not found: %s", histRef)
			return
		}
		histSpec = hl.Tag
		idx = hl.Index
	}

	if len(buildSpec) > 0 {
		found := false
		var repospec robot.Repository
		var reponame string
		reponames := []string{}
		for repo, spec := range r.repositories {
			components := strings.Split(repo, "/")
			if len(components) != 3 {
				r.Log(robot.Warn, "Repository '%s' doesn't match <site>/<org>/<name>, skipping")
				continue
			}
			org := components[1]
			rname := components[2]
			extname := strings.Join([]string{org, rname}, "/")
			var compare string
			switch len(strings.Split(buildSpec, "/")) {
			case 1:
				compare = rname
			case 2:
				compare = extname
			case 3:
				compare = repo
			}
			if buildSpec == compare {
				found = true
				repospec = spec
				reponame = repo
				reponames = append(reponames, reponame)
			}
		}
		if !found {
			r.Say("Repository matching '%s' not found", buildSpec)
			return
		}
		if len(reponames) > 1 {
			repos := strings.Join(reponames, ", ")
			r.Say("Matched multiple repositories: %s", repos)
			return
		}
		jobName = repospec.Type
		histSpec = jobName + ":" + reponame
	} else if len(jobName) > 0 {
		histSpec = jobName
	}

	// boilerplate availability and security checking for job commands;
	// note that both jobAvailable and jobSecurityCheck emit messages
	// to the user if they fail
	jname := strings.Split(histSpec, ":")[0]
	t := w.jobAvailable(jname)
	if t == nil {
		return
	}
	if !w.jobSecurityCheck(t, command) {
		return
	}

	jh := pipeHistory{}
	key := histPrefix + histSpec
	_, _, ret := checkoutDatum(key, &jh, false)
	if ret != robot.Ok {
		r.Say("No logs found for '%s'", histSpec)
		return
	}
	if len(jh.ExtendedNamespaces) > 0 {
		r.Say("Job '%s' is a build job, use 'buildlogs' instead", jobName)
		return
	}
	if len(jh.Histories) == 0 {
		r.Say("No logs found for '%s'", histSpec)
		return
	}

	switch command {
	case "maillog":
		return emailhistory(r, user, address, histSpec, idx)
	case "taillog":
		ret, buff := getLogTail(histSpec, idx)
		if ret == robot.Normal {
			r.Say("log excerpt for '%s', run %d:", histSpec, idx)
			r.Fixed().Say(string(buff))
		} else {
			r.Say("Log for '%s', run %d not available", histSpec, idx)
		}
	case "linklog":
		url, found := interfaces.history.GetLogURL(histSpec, idx)
		if !found {
			url, found = interfaces.history.MakeLogURL(histSpec, idx)
		}
		if !found {
			r.Say("URL for '%s', run %d not available", histSpec, idx)
			return
		}
		r.Say("Here you go: %s", url)
	case "joblogs", "buildlogs":
		var loglines []string
		isBuild := command == "buildlogs"
		checkBranch := len(branch) > 0
		if !isBuild {
			loglines = []string{fmt.Sprintf("Logs for job '%s':", jobName)}
		} else if checkBranch {
			loglines = []string{fmt.Sprintf("Build logs for '%s', branch '%s':", buildSpec, branch)}
		} else {
			loglines = []string{fmt.Sprintf("Build logs for '%s':", buildSpec)}
		}
		for _, log := range jh.Histories {
			if checkBranch && branch != log.Descriptor {
				continue
			}
			var logline string
			if isBuild {
				logline = fmt.Sprintf("Run #%d, %s, branch '%s'; log %s", log.LogIndex, log.CreateTime, log.Descriptor, log.Ref)
			} else {
				logline = fmt.Sprintf("Run #%d, %s; log %s", log.LogIndex, log.CreateTime, log.Ref)
			}
			loglines = append(loglines, logline)
		}
		if checkBranch && len(loglines) == 1 {
			r.Say("No build logs found for '%s', '%s' branch", buildSpec, branch)
			return
		}
		r.Say(strings.Join(loglines, "\n"))
		return
	}
	return
}

// jobSecurityCheck performs all security checks - RequireAdmin, Authorization
// and Elevation - and returns true if passed. It will message the user and
// return false if a check fails.
func (w *worker) jobSecurityCheck(t interface{}, command string) bool {
	if w.automaticTask {
		return true
	}
	if w.Incoming.HiddenMessage {
		w.Reply("Sorry, job commands cannot be run as hidden commands - use the robot's name or alias")
		return false
	}
	task, _, _ := getTask(w.currentTask)
	if task.RequireAdmin {
		if !w.CheckAdmin() {
			w.Say("Sorry, that command is only available to bot administrators")
			return false
		}
	}
	r := w.makeRobot()
	w.registerWorker(r.tid)
	if r.checkAuthorization(w, t, command) != robot.Success {
		deregisterWorker(r.tid)
		return false
	}
	if !w.elevated {
		eret, _ := r.checkElevation(t, command)
		if eret != robot.Success {
			deregisterWorker(r.tid)
			return false
		}
	}
	deregisterWorker(r.tid)
	return true
}

// jobVisible checks whether a user should see a job in a channel, unless
// ignoreChannelRestrictions is set. Note that changes to logic in jobVisible
// may need to propagate to jobAvailable, below.
func (r Robot) jobVisible(t interface{}, ignoreChannelRestrictions, disabledOk bool) (visible bool, channel string) {
	task, _, job := getTask(t)
	if job == nil {
		return
	}
	if task.Disabled && !disabledOk {
		return
	}
	if len(task.Users) > 0 {
		userOk := false
		for _, allowedUser := range task.Users {
			match, err := filepath.Match(allowedUser, r.User)
			if match && err == nil {
				userOk = true
			}
		}
		if !userOk {
			return
		}
	}
	if task.RequireAdmin {
		isAdmin := false
		admins := r.cfg.adminUsers
		for _, adminUser := range admins {
			if r.User == adminUser {
				isAdmin = true
				break
			}
		}
		if !isAdmin {
			return
		}
	}
	if !ignoreChannelRestrictions && r.Channel != task.Channel {
		channel = task.Channel
		return
	}
	return true, ""
}

// jobAvailable does the work of looking up a job and checking whether it's
// available, and messaging the user if it's not. Only called for interactive
// job commands like history, run job, etc. where the user provides a job name.
// Note that changes to login in jobAvailable may need to propagate to
// jobVisible, above.
func (w *worker) jobAvailable(taskName string) interface{} {
	t := w.tasks.getTaskByName(taskName)
	if t == nil {
		w.Say("Sorry, I couldn't find a job named '%s' configured", taskName)
		return nil
	}
	task, _, job := getTask(t)
	isJob := job != nil
	if !isJob {
		w.Say("Sorry, '%s' isn't a job", taskName)
		return nil
	}
	if w.automaticTask {
		return t
	}
	// If there's already a job initialized, this is a pipeline task for that
	// job, and should be available regardless of channel.
	if w.pipeContext != nil && !w.jobInitialized && w.Channel != task.Channel {
		w.Say("Sorry, job '%s' isn't available in this channel, try '%s'", taskName, task.Channel)
		return nil
	}
	if task.RequireAdmin {
		isAdmin := false
		admins := w.cfg.adminUsers
		for _, adminUser := range admins {
			if w.User == adminUser {
				isAdmin = true
				break
			}
		}
		if !isAdmin {
			w.Say("Sorry, '%s' is only available to bot administrators", taskName)
			return nil
		}
	}
	if len(task.Users) > 0 {
		userOk := false
		for _, allowedUser := range task.Users {
			match, err := filepath.Match(allowedUser, w.User)
			if match && err == nil {
				userOk = true
			}
		}
		if !userOk {
			w.Say("Sorry, you're not on the list of allowed users for that job")
			return nil
		}
	}
	return t
}
</file_content file: gopherbot-main/bot/jobbuiltins.go>
<preamble file: gopherbot-main/bot/jobrun.go>

</preamble>
<file_content file: gopherbot-main/bot/jobrun.go>
package bot

import (
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

// (?i:^\s*run[- ]job ([A-Za-z][\w-]*)(?: (.*))?\s*$)
const runJobRegex = `run[- ]job (` + identifierRegex + `)(?: (.*))?`

var runJobRe = regexp.MustCompile(`(?i:^\s*` + runJobRegex + `\s*$)`)

// checkJobMatchersAndRun handles triggers, 'run job <foo>'
func (w *worker) checkJobMatchersAndRun() (messageMatched bool) {
	// un-needed, but more clear
	messageMatched = false
	runTasks := []interface{}{}
	robots := []*worker{}
	taskArgs := [][]string{}
	var triggerArgs []string

	// First, check triggers
	for _, t := range w.tasks.t[1:] {
		task, _, job := getTask(t)
		if job == nil {
			continue
		}
		if task.Disabled {
			msg := fmt.Sprintf("Skipping disabled job '%s', reason: %s", task.name, task.reason)
			Log(robot.Trace, msg)
			continue
		}
		Log(robot.Trace, "Checking triggers for job '%s'", task.name)
		triggers := job.Triggers
		for _, trigger := range triggers {
			Log(robot.Trace, "Checking '%s' against user '%s', channel '%s', regex: '%s'", w.msg, trigger.User, trigger.Channel, trigger.Regex)
			if w.User != trigger.User {
				continue
			}
			if w.Channel != trigger.Channel {
				continue
			}
			matches := trigger.re.FindAllStringSubmatch(w.msg, -1)
			matched := false
			if matches != nil {
				Log(robot.Trace, "Message '%s' matches trigger for job '%s'", w.msg, task.name)
				matched = true
				triggerArgs = matches[0][1:]
			}
			if matched {
				messageMatched = true
				newbot := w.clone()
				newbot.automaticTask = true
				robots = append(robots, newbot)
				runTasks = append(runTasks, t)
				taskArgs = append(taskArgs, triggerArgs)
			}
		} // end of triggerer checking
	} // end of job trigger checking
	if messageMatched {
		state.RLock()
		if state.shuttingDown {
			w.Say("Ignoring triggered job(s): shutting down")
			state.RUnlock()
			return
		}
		state.RUnlock()
		if len(robots) > 0 {
			for i, robot := range robots {
				go robot.startPipeline(nil, runTasks[i], jobTrigger, "run", taskArgs[i]...)
			}
		}
		return
	}
	// Messages from the robot itself can match a job trigger, but
	// nothing else.
	if w.Incoming.SelfMessage {
		return
	}
	// Check for built-in run job
	if w.isCommand {
		var jname string
		cmsg := spaceRe.ReplaceAllString(w.msg, " ")
		matches := runJobRe.FindAllStringSubmatch(cmsg, -1)
		if matches != nil {
			jname = matches[0][1]
			messageMatched = true
			w.messageHeard()
		} else {
			return
		}
		t := w.jobAvailable(jname)
		if t != nil {
			r := w.makeRobot()
			visible, jchan := r.jobVisible(t, false, false)
			if !visible {
				if len(jchan) > 0 {
					r.Say("Job not available in this channel; try: %s", jchan)
				} else {
					r.Say("Sorry, that job isn't available")
				}
				return
			}
			c := &pipeContext{
				environment: make(map[string]string),
			}
			w.pipeContext = c
			c.currentTask = t
			// We need an active worker in case we need to call possibly
			// external authorizer or elevator.
			w.registerActive(nil)
			// REMOVE ME r := w.makeRobot()
			task, _, job := getTask(t)
			if task.Disabled {
				w.Say("Job '%s' is disabled: %s", jname, task.reason)
				w.deregister()
				return
			}
			if !w.jobSecurityCheck(t, "run") {
				w.deregister()
				return
			}
			var args []string
			// remember which job we're talking about
			ctx := w.makeMemoryContext("context:task")
			s := ephemeralMemory{jname, time.Now()}
			ephemeralMemories.Lock()
			ephemeralMemories.m[ctx] = s
			ephemeralMemories.Unlock()
			if len(matches[0][2]) > 0 {
				// arguments supplied with `run job foo bar baz`, check match to required arguments
				args = strings.Split(matches[0][2], " ")
				numargs := len(args)
				if numargs > 0 && numargs < len(job.Arguments) {
					w.Say("Too few arguments to job '%s', %d required but %d given", jname, len(job.Arguments), len(args))
					w.deregister()
					return
				}
				// Check regexes for required arguments
				for i, jobarg := range job.Arguments {
					if !jobarg.re.MatchString(args[i]) {
						w.Say("'%s' doesn't match the pattern for argument '%s': %s", args[i], jobarg.Label, jobarg.Regex)
						w.deregister()
						return
					}
				}
			} else {
				if len(job.Arguments) > 0 {
					args = make([]string, len(job.Arguments))
					c.currentTask = t
					c.pipeName = task.name
					c.pipeDesc = task.Description
					r := w.makeRobot()
					for i, argspec := range job.Arguments {
						var t int
						for t = 1; t < 3; t++ {
							arg, ret := r.PromptForReply(argspec.Label, fmt.Sprintf("What's the value for '%s'?", argspec.Label))
							if ret == robot.ReplyNotMatched {
								r.Say("That doesn't match the pattern for argument '%s'", argspec.Label)
							} else {
								if ret != robot.Ok {
									r.Log(robot.Warn, "Failed getting arguments running job '%s': %s", jname, ret)
									r.Say("(not running job '%s')", jname)
									w.deregister()
									return
								}
								args[i] = arg
								break
							}
						}
						if t == 3 {
							r.Say("(giving up)")
							w.deregister()
							return
						}
					}
				}
			}
			w.deregister()
			c.verbose = true
			w.startPipeline(nil, t, jobCommand, "run", args...)
		} // jobAvailable sends a message if it's not
	}
	return
}
</file_content file: gopherbot-main/bot/jobrun.go>
<preamble file: gopherbot-main/bot/linebuffer.go>

</preamble>
<file_content file: gopherbot-main/bot/linebuffer.go>
package bot

import (
	"bytes"
	"errors"
	"io"
	"strings"
	"sync"
)

type lineBuffer struct {
	buffer         []byte
	size, linesize int
	trunc          string
	start, end     int
	length         int
	closed         bool
	sync.Mutex
}

type lineBufferReader struct {
	lb       *lineBuffer
	size     int
	position int
}

func newLineBuffer(buffsize, linesize int, truncstr string) *lineBuffer {
	if !strings.HasSuffix(truncstr, "\n") {
		truncstr += "\n"
	}
	if linesize > buffsize {
		linesize = buffsize
	}
	l := &lineBuffer{
		buffer:   make([]byte, buffsize),
		size:     buffsize,
		linesize: linesize,
		trunc:    truncstr,
		length:   0,
		closed:   false,
	}
	return l
}

func (m *lineBuffer) close() {
	m.Lock()
	defer m.Unlock()
	m.closed = true
}

// writeLine writes a line to the memlog, up to m.linesize length
func (m *lineBuffer) writeLine(line string) {
	m.Lock()
	defer m.Unlock()
	if m.closed {
		return
	}
	if !strings.HasSuffix(line, "\n") {
		line = line + "\n"
	}
	var lbytes []byte
	if len(line) > m.linesize {
		lbytes = make([]byte, m.linesize)
		copy(lbytes, []byte(line)[0:(m.linesize-len(m.trunc))])
		copy(lbytes[m.linesize-len(m.trunc):m.linesize], []byte(m.trunc))
	} else {
		lbytes = []byte(line)
	}
	lsize := len(lbytes)
	// Copy string and move m.end
	copied := copy(m.buffer[m.end:], lbytes)
	if copied != lsize {
		copy(m.buffer, lbytes[copied:])
	}
	fallbackStart := m.end
	if fallbackStart == m.size {
		fallbackStart = 0
	}
	m.end += lsize
	if m.end > m.size {
		m.end -= m.size
	}
	if lsize == m.size {
		m.length = m.size
		return
	}
	m.length += lsize
	if m.length > m.size {
		// overlap - end passed start, need to move start and shorten
		if m.end == m.size {
			m.start = 0
		} else {
			m.start = m.end
		}
		m.length = m.size
		// Now scan for the next newline and move start to there
		limit := m.size - lsize
		inc := bytes.IndexByte(m.buffer[m.start:], byte('\n'))
		if inc == -1 {
			inc = len(m.buffer[m.start:])
			inc += bytes.IndexByte(m.buffer, byte('\n'))
		}
		// move start past the "\n"
		inc++
		if inc >= limit {
			// use fallback
			m.start = fallbackStart
			m.length = lsize
			return
		}
		m.length -= inc
		m.start += inc
		if m.start >= m.size {
			m.start -= m.size
		}
	}
}

// getReader returns a memreader from a memlog
func (m *lineBuffer) getReader() (io.Reader, error) {
	m.Lock()
	defer m.Unlock()
	if !m.closed {
		return nil, errors.New("Not closed")
	}
	mr := &lineBufferReader{
		lb:       m,
		position: 0,
		size:     m.length,
	}
	return mr, nil
}

// copyReader locks the linebuffer and returns a reader for
// a copy.
func (m *lineBuffer) copyReader() io.Reader {
	m.Lock()
	defer m.Unlock()
	lb := &lineBuffer{
		buffer: make([]byte, m.size),
		size:   m.size,
		start:  m.start,
		end:    m.end,
		length: m.length,
		closed: true,
		Mutex:  sync.Mutex{},
	}
	copy(lb.buffer, m.buffer)
	mr := &lineBufferReader{
		lb:       lb,
		position: 0,
		size:     m.length,
	}
	return mr
}

// Read implements Read() for a linebuffer
func (mr *lineBufferReader) Read(p []byte) (int, error) {
	rsize := len(p)
	eof := false
	if mr.position+rsize > mr.size {
		eof = true
		rsize = mr.size - mr.position
	}
	m := mr.lb
	rpos := m.start + mr.position
	if rpos > m.size {
		rpos -= m.size
	}
	if rpos+rsize <= m.size {
		copy(p, m.buffer[rpos:rpos+rsize])
	} else {
		copy(p, m.buffer[rpos:m.size])
		copy(p[len(m.buffer[rpos:m.size]):], m.buffer[0:rsize-len(m.buffer[rpos:m.size])])
	}
	mr.position += rsize
	if eof {
		return rsize, io.EOF
	}
	return rsize, nil
}
</file_content file: gopherbot-main/bot/linebuffer.go>
<preamble file: gopherbot-main/bot/logbuffers.go>

</preamble>
<file_content file: gopherbot-main/bot/logbuffers.go>
package bot

import (
	"bufio"
	"io"

	"github.com/lnxjedi/gopherbot/robot"
)

// logbuffers.go - utility functions for pulling pipeline logs in to
// tail or email buffers.

const maxMailBody = 10485760 // 10MB
const maxMailLine = 16384    // 16k lines
const tailBody = 3072        // 3k total buffer
const tailLine = 512         // max line length for tail

func getLogTail(tag string, idx int) (ret robot.TaskRetVal, buff []byte) {
	ret, buff = getLogBuffer(tag, " ...", idx, tailBody, tailLine)
	return
}

func getLogMail(tag string, idx int) (ret robot.TaskRetVal, buff []byte) {
	ret, buff = getLogBuffer(tag, "< ... truncated>", idx, maxMailBody, maxMailLine)
	return
}

func getLogBuffer(tag, trunc string, idx, buffsize, linesize int) (ret robot.TaskRetVal, buff []byte) {
	logReader, err := interfaces.history.GetLog(tag, idx)
	if err != nil && interfaces.history == memHistories {
		Log(robot.Error, "Failed getting log reader in tail-log for history %s, index: %d", tag, idx)
		ret = robot.NotFound
		return
	}
	if err != nil {
		Log(robot.Debug, "Failed getting log reader in tail-log, checking for memlog fallback")
		logReader, err = memHistories.GetLog(tag, idx)
	}
	if err != nil {
		Log(robot.Error, "Failed memlog fallback retrieving %s:%d in tail-log")
		ret = robot.NotFound
		return
	}
	tail := newLineBuffer(buffsize, linesize, trunc)
	scanner := bufio.NewScanner(logReader)
	for scanner.Scan() {
		line := scanner.Text()
		tail.writeLine(line)
	}
	tail.close()
	tailReader, _ := tail.getReader()
	buff, _ = io.ReadAll(tailReader)

	return
}
</file_content file: gopherbot-main/bot/logbuffers.go>
<preamble file: gopherbot-main/bot/logging.go>

</preamble>
<file_content file: gopherbot-main/bot/logging.go>
package bot

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

// loggers of last resort, initialize early and update in start.go
func init() {
	botStdErrLogger = log.New(os.Stderr, "", log.LstdFlags)
	botStdOutLogger = log.New(os.Stdout, "", log.LstdFlags)
}

// initialized in start.go
var botStdErrLogger, botStdOutLogger *log.Logger

// Set by terminal connector
var terminalWriter io.Writer

var errorThreshold = robot.Warn

// Should be ample for the internal circular log
const buffLines = 500
const maxLines = 50 // maximum lines to send in a message
var logFileName string

type botLoggerInfo struct {
	logger    *log.Logger
	f         *os.File
	level     robot.LogLevel
	buffer    []string
	buffLine  int
	pageLines int
	buffPages int
	totLines  int // total number of lines logged, ever
	sync.Mutex
}

var botLogger = botLoggerInfo{
	logger:    nil,
	f:         nil,
	level:     robot.Info,
	buffer:    make([]string, buffLines),
	buffLine:  0,
	pageLines: 20,
	buffPages: buffLines / 20,
	Mutex:     sync.Mutex{},
}

// note that closing the old output file probably isn't strictly necessary,
// since the old file will be automatically closed by garbage collection.
func (bl *botLoggerInfo) setOutputFile(f *os.File) {
	bl.Lock()
	of := bl.f
	bl.f = f
	bl.Unlock()
	bl.logger.SetOutput(f)
	err := of.Close()
	if err != nil {
		Log(robot.Error, "Closing old log file: %v", err)
	}
}

// rename current logfile with given extension and create new log file
func logRotate(extension string) robot.TaskRetVal {
	if len(logFileName) == 0 {
		return robot.Normal
	}
	raiseThreadPriv("rotating log")
	if len(extension) > 0 {
		oldext := filepath.Ext(logFileName)
		barename := strings.TrimSuffix(logFileName, oldext)
		if !strings.HasPrefix(extension, ".") {
			extension = "." + extension
		}
		oldFileName := barename + extension
		os.Remove(oldFileName)
		err := os.Rename(logFileName, oldFileName)
		if err != nil {
			Log(robot.Error, "Renaming '%s' to '%s': %v", logFileName, oldFileName, err)
			return robot.Fail
		}
	} else {
		if err := os.Remove(logFileName); err != nil {
			Log(robot.Error, "Unlinking old log file '%s': %v", logFileName, err)
			return robot.Fail
		}
	}
	lf, err := os.Create(logFileName)
	if err != nil {
		Log(robot.Error, "Creating new log file '%s': %v", logFileName, err)
		return robot.Fail
	}
	botLogger.setOutputFile(lf)
	return robot.Normal
}

func logStrToLevel(l string) robot.LogLevel {
	switch strings.ToLower(l) {
	case "trace":
		return robot.Trace
	case "debug":
		return robot.Debug
	case "info":
		return robot.Info
	case "audit":
		return robot.Audit
	case "warn":
		return robot.Warn
	default:
		return robot.Error
	}
}

func logLevelToStr(l robot.LogLevel) string {
	switch l {
	case robot.Trace:
		return "Trace"
	case robot.Debug:
		return "Debug"
	case robot.Info:
		return "Info"
	case robot.Audit:
		return "Audit"
	case robot.Warn:
		return "Warning"
	case robot.Error:
		return "Error"
	case robot.Fatal:
		return "Fatal"
	default:
		return ""
	}
}

// logPage returns a slice of log strings of length pageLines. If p = 0,
// it returns the most recent page, for p>0 it goes back
func logPage(p int) ([]string, bool) {
	wrapped := false
	botLogger.Lock()
	page := p % botLogger.buffPages
	if page != p {
		wrapped = true
	}
	pageSlice := make([]string, botLogger.pageLines)
	start := (botLogger.buffLine + buffLines - ((page + 1) * botLogger.pageLines))
	start = (botLogger.totLines - start) % buffLines
	if start+botLogger.pageLines > buffLines {
		copy(pageSlice, botLogger.buffer[start:buffLines])
		copy(pageSlice[buffLines-start:], botLogger.buffer[0:])
	} else {
		copy(pageSlice, botLogger.buffer[start:start+botLogger.pageLines])
	}
	botLogger.Unlock()
	return pageSlice, wrapped
}

// setLogPageLines updates the number of lines per page of log output
func setLogPageLines(l int) int {
	lines := l
	if l > maxLines {
		lines = maxLines
	}
	if l == 0 {
		lines = 1
	}
	botLogger.Lock()
	botLogger.pageLines = lines
	botLogger.buffPages = buffLines / botLogger.pageLines
	botLogger.Unlock()
	return lines
}

// setLogLevel updates the connector log level
func setLogLevel(l robot.LogLevel) {
	botLogger.Lock()
	botLogger.level = l
	botLogger.Unlock()
}

func getLogLevel() robot.LogLevel {
	botLogger.Lock()
	l := botLogger.level
	botLogger.Unlock()
	return l
}

// Log logs messages whenever the connector log level is
// less than the given level
func Log(l robot.LogLevel, m string, v ...interface{}) bool {
	botLogger.Lock()
	currlevel := botLogger.level
	logger := botLogger.logger
	botLogger.Unlock()
	prefix := logLevelToStr(l) + ":"
	msg := prefix + " " + m
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	// Note logger is nil very briefly on startup
	if logger == nil && l >= currlevel {
		botStdOutLogger.Print(msg)
		return true
	}
	if nullConn && l >= errorThreshold {
		botStdOutLogger.Print(msg)
	}
	if l >= currlevel || l == robot.Audit {
		if l == robot.Fatal {
			logger.Fatal(msg)
		} else {
			if localTerm {
				if terminalWriter != nil {
					terminalWriter.Write([]byte("LOG " + msg + "\n"))
				} else {
					botStdOutLogger.Print("LOG " + msg)
				}
			}
			logger.Print(msg)
			tsMsg := fmt.Sprintf("%s %s\n", time.Now().Format("Jan 2 15:04:05"), msg)
			botLogger.Lock()
			botLogger.buffer[botLogger.buffLine] = tsMsg
			botLogger.buffLine = (botLogger.buffLine + 1) % (buffLines - 1)
			botLogger.totLines++
			botLogger.Unlock()
		}
		return true
	}
	return false
}
</file_content file: gopherbot-main/bot/logging.go>
<preamble file: gopherbot-main/bot/membrain.go>

</preamble>
<file_content file: gopherbot-main/bot/membrain.go>
package bot

// membrain is a trivial memory-based implementation of the bot.SimpleBrain
// interface, which gives the robot a place to store it's memories. Memories
// are lost when the robot stops, so this is mainly only useful for testing;
// however, if no other brain is configured, membrain is used as the default.

import (
	"github.com/lnxjedi/gopherbot/robot"
)

// NOTE: brains shouldn't need to do their own locking. See bot/brain.go
type memBrain struct {
	memories map[string]*[]byte
}

func (mb *memBrain) Store(k string, b *[]byte) error {
	mb.memories[k] = b
	return nil
}

func (mb *memBrain) Retrieve(k string) (*[]byte, bool, error) {
	datum, exists := mb.memories[k]
	if exists {
		return datum, true, nil
	}
	// Memory doesn't exist yet
	return datum, false, nil
}

func (mb *memBrain) List() ([]string, error) {
	keys := make([]string, 0, len(mb.memories))
	for key := range mb.memories {
		keys = append(keys, key)
	}
	return keys, nil
}

func (mb *memBrain) Delete(key string) error {
	delete(mb.memories, key)
	return nil
}

// The file brain doesn't need the logger, but other brains might
func provider(r robot.Handler) robot.SimpleBrain {
	mb := &memBrain{
		memories: make(map[string]*[]byte),
	}
	return mb
}

func init() {
	RegisterSimpleBrain("mem", provider)
}
</file_content file: gopherbot-main/bot/membrain.go>
<preamble file: gopherbot-main/bot/memhistory.go>

</preamble>
<file_content file: gopherbot-main/bot/memhistory.go>
package bot

// memhistory provides a trivial history provider that only keeps
// active (un-Finalize()'d) histories in 64k buffers

import (
	"errors"
	"fmt"
	"io"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

type memlogentry struct {
	tag string
	idx int
}

type memlog struct {
	entry memlogentry
	log   *lineBuffer
}

type memHistLog struct {
	logs map[memlogentry]memlog
	sync.Mutex
}

type memHistoryConfig struct {
	BufferSize, MaxLineLength int
	Truncated                 string
}

var mhc memHistoryConfig

var memHistories *memHistLog

// Log writes a timestamped line to the buffer
func (m memlog) Log(line string) {
	tsLine := fmt.Sprintf("%s %s", time.Now().Format("Jan 2 15:04:05"), line)
	m.log.writeLine(tsLine)
}

// Line writes a bare line to a buffer
func (m memlog) Line(line string) {
	m.log.writeLine(line)
}

// Close closes the log against further writes
func (m memlog) Close() {
	m.log.close()
}

// Finalize removes the log from the lookup map
func (m memlog) Finalize() {
	memHistories.Lock()
	defer memHistories.Unlock()
	delete(memHistories.logs, m.entry)
}

// NewHistory returns a lineBuffer based history logger
func (h *memHistLog) NewLog(tag string, index, maxHistories int) (robot.HistoryLogger, error) {
	lb := newLineBuffer(mhc.BufferSize, mhc.MaxLineLength, mhc.Truncated)
	entry := memlogentry{tag, index}
	ml := memlog{entry, lb}
	memHistories.Lock()
	defer memHistories.Unlock()
	memHistories.logs[entry] = ml
	return ml, nil
}

// GetLogURL does nothing for mem logs
func (h *memHistLog) GetLogURL(tag string, index int) (string, bool) {
	return "", false
}

// MakeLogURL does nothing for mem logs
func (h *memHistLog) MakeLogURL(tag string, index int) (string, bool) {
	return "", false
}

// GetHistory returns a reader for the log if it exists
func (h *memHistLog) GetLog(tag string, index int) (io.Reader, error) {
	entry := memlogentry{tag, index}
	memHistories.Lock()
	defer memHistories.Unlock()
	mh, ok := memHistories.logs[entry]
	if !ok {
		return nil, errors.New("not found")
	}
	mr, err := mh.log.getReader()
	if err != nil {
		mr = mh.log.copyReader()
	}
	return mr, nil
}

func mhprovider(r robot.Handler) robot.HistoryProvider {
	r.GetHistoryConfig(&mhc)
	if mhc.BufferSize < 4096 {
		mhc.BufferSize = 4096
	}
	if mhc.MaxLineLength < 1024 {
		mhc.MaxLineLength = 1024
	}
	if mhc.Truncated == "" {
		mhc.Truncated = "<... truncated>"
	}
	memHistories = &memHistLog{
		make(map[memlogentry]memlog),
		sync.Mutex{},
	}
	return memHistories
}

func init() {
	RegisterHistoryProvider("mem", mhprovider)
}
</file_content file: gopherbot-main/bot/memhistory.go>
<preamble file: gopherbot-main/bot/null_connector.go>

</preamble>
<file_content file: gopherbot-main/bot/null_connector.go>
package bot

import (
	"fmt"
	"log"
	"os"

	"github.com/lnxjedi/gopherbot/robot"
)

type nullConnector struct{}

func nullStart(robot.Handler, *log.Logger) robot.Connector {
	nc := nullConnector{}
	return nc
}

func init() {
	RegisterConnector("nullconn", nullStart)
}

func (nc nullConnector) GetProtocolUserAttribute(u, a string) (value string, ret robot.RetVal) {
	return
}

func (nc nullConnector) JoinChannel(c string) robot.RetVal {
	return robot.Ok
}

func (nc nullConnector) MessageHeard(u, c string) {
	return
}

func (nc nullConnector) Run(stop <-chan struct{}) {
	<-stop
}

func (nc nullConnector) FormatHelp(input string) string {
	return input
}

func (nc nullConnector) DefaultHelp() []string {
	return []string{}
}

func (nc nullConnector) SendProtocolChannelThreadMessage(ch string, thr, msg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	return nc.sendMessage(msg, f)
}

func (nc nullConnector) SendProtocolUserChannelThreadMessage(uid, uname, ch, thr, msg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	return nc.sendMessage(msg, f)
}

func (nc nullConnector) SendProtocolUserMessage(u string, msg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	return nc.sendMessage(msg, f)
}

func (nc nullConnector) SetUserMap(map[string]string) {
	return
}

func (nc nullConnector) sendMessage(msg string, f robot.MessageFormat) (ret robot.RetVal) {
	output := fmt.Sprintf("null connector: %s\n", msg)
	if f != robot.Fixed {
		output = Wrap(output, 80)
		os.Stdout.Write([]byte(output)[0 : len(output)-1])
	} else {
		os.Stdout.Write([]byte(output))
	}
	return robot.Ok
}
</file_content file: gopherbot-main/bot/null_connector.go>
<preamble file: gopherbot-main/bot/pipe_tasks.go>

</preamble>
<file_content file: gopherbot-main/bot/pipe_tasks.go>
package bot

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

// func template(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
// 	r := m.(Robot)
// 	return
// }

// rotatelog (task rotate-log); rotate the log file when logging to file
func rotatelog(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	ext := ""
	if len(args) == 1 {
		ext = args[0]
	}
	return logRotate(ext)
}

// pause just adds a pause to the pipeline
func pause(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	if len(args) != 1 {
		m.Log(robot.Warn, "Pause called with wrong number or args, not pausing")
		return
	}
	seconds, err := strconv.Atoi(args[0])
	if err != nil {
		m.Log(robot.Warn, "Unable to parse integer argument for pause, not pausing")
		return
	}
	time.Sleep(time.Duration(seconds) * time.Second)
	return
}

// logtail - task tail-log; get the last 2k of pipeline log
func logtail(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	w := getLockedWorker(r.tid)
	hist := w.histName
	idx := w.runIndex
	w.Unlock()
	var buffer []byte
	retval, buffer = getLogTail(hist, idx)
	if retval == robot.Normal {
		r.Fixed().Say(string(buffer))
	}
	return
}

// sendmsg - task send-message just sends a message to the job/plugin channel
// functionally equivalent to status/say (bash tasks)
func sendmsg(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	r := m.GetMessage()
	if len(args) == 0 {
		m.Log(robot.Warn, "Empty status message")
		return
	}
	full := strings.Join(args, " ")
	ret := m.Say(full)
	if ret != robot.Ok {
		m.Log(robot.Error, "Failed sending message '%s' in channel '%s', return code: %d (%s)", full, r.Channel, ret, ret)
	}
	return
}

// logmail - task email-log; send the job log to one or more email
// addresses.
func logmail(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	if len(args) == 0 {
		defaultMail := false
		if len(r.Message.User) > 0 {
			sa := r.GetSenderAttribute("email")
			if sa.RetVal == robot.Ok {
				defaultMail = true
				args = []string{sa.Attribute}
			}
		}
		if !defaultMail {
			m.Log(robot.Error, "Email-log called with no addresses")
			return robot.Fail
		}
	}
	w := getLockedWorker(r.tid)
	hist := w.histName
	idx := w.runIndex
	w.Unlock()
	var buff []byte
	retval, buff = getLogMail(hist, idx)
	if retval != robot.Normal {
		return
	}
	body := new(bytes.Buffer)
	body.Write([]byte("<pre>\n"))
	body.Write(buff)
	body.Write([]byte("\n</pre>"))
	subject := fmt.Sprintf("Log for pipeline '%s', run %d", hist, idx)
	var ret robot.RetVal = robot.Ok
	for _, addr := range args {
		check := r.EmailAddress(addr, subject, body, true)
		if check != robot.Ok {
			ret = check
		}
	}
	if ret != robot.Ok {
		r.Log(robot.Error, "There was a problem emailing one or more pipeline logs, contact an administrator: %s", ret)
		return robot.Fail
	}
	return
}

func restart(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	pn := r.pipeName
	state.Lock()
	if state.shuttingDown {
		state.Unlock()
		Log(robot.Warn, "Restart triggered in pipeline '%s' with shutdown already in progress", pn)
		return
	}
	running := state.pipelinesRunning - 1
	state.shuttingDown = true
	state.restart = true
	state.Unlock()
	r.Log(robot.Info, "Restart triggered in pipeline '%s' with %d pipelines running (including this one)", pn, running)
	go stop()
	return
}

func quit(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	pn := r.pipeName
	state.Lock()
	if state.shuttingDown {
		state.Unlock()
		Log(robot.Warn, "Quit triggered in pipeline '%s' with shutdown already in progress", pn)
		return
	}
	running := state.pipelinesRunning - 1
	state.shuttingDown = true
	state.Unlock()
	r.Log(robot.Info, "Quit triggered in pipeline '%s' with %d pipelines running (including this one)", pn, running)
	go stop()
	return
}

func pauseBrainTask(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	w := getLockedWorker(r.tid)
	w.Unlock()
	resume := make(chan struct{})
	brainLocks.Lock()
	brainLocks.locks[w.id] = resume
	brainLocks.Unlock()
	pauseBrain(w.id, resume)
	return
}

func resume(m robot.Robot, args ...string) (retval robot.TaskRetVal) {
	r := m.(Robot)
	w := getLockedWorker(r.tid)
	w.Unlock()
	brainLocks.Lock()
	if resume, ok := brainLocks.locks[w.id]; ok {
		close(resume)
		delete(brainLocks.locks, w.id)
	}
	brainLocks.Unlock()
	return
}

func init() {
	RegisterTask("email-log", true, robot.TaskHandler{Handler: logmail})
	RegisterTask("pause-brain", true, robot.TaskHandler{Handler: pauseBrainTask})
	RegisterTask("pause", false, robot.TaskHandler{Handler: pause})
	RegisterTask("restart-robot", true, robot.TaskHandler{Handler: restart})
	RegisterTask("resume-brain", true, robot.TaskHandler{Handler: resume})
	RegisterTask("robot-quit", true, robot.TaskHandler{Handler: quit})
	RegisterTask("rotate-log", true, robot.TaskHandler{Handler: rotatelog})
	RegisterTask("send-message", false, robot.TaskHandler{Handler: sendmsg})
	RegisterTask("tail-log", false, robot.TaskHandler{Handler: logtail})
}
</file_content file: gopherbot-main/bot/pipe_tasks.go>
<preamble file: gopherbot-main/bot/pipeaddflavor_string.go>

</preamble>
<file_content file: gopherbot-main/bot/pipeaddflavor_string.go>
// Code generated by "stringer -type=pipeAddFlavor constants.go"; DO NOT EDIT.

package bot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[flavorSpawn-0]
	_ = x[flavorAdd-1]
	_ = x[flavorFinal-2]
	_ = x[flavorFail-3]
}

const _pipeAddFlavor_name = "flavorSpawnflavorAddflavorFinalflavorFail"

var _pipeAddFlavor_index = [...]uint8{0, 11, 20, 31, 41}

func (i pipeAddFlavor) String() string {
	if i < 0 || i >= pipeAddFlavor(len(_pipeAddFlavor_index)-1) {
		return "pipeAddFlavor(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _pipeAddFlavor_name[_pipeAddFlavor_index[i]:_pipeAddFlavor_index[i+1]]
}
</file_content file: gopherbot-main/bot/pipeaddflavor_string.go>
<preamble file: gopherbot-main/bot/pipeaddtype_string.go>

</preamble>
<file_content file: gopherbot-main/bot/pipeaddtype_string.go>
// Code generated by "stringer -type=pipeAddType constants.go"; DO NOT EDIT.

package bot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[typeTask-0]
	_ = x[typePlugin-1]
	_ = x[typeJob-2]
}

const _pipeAddType_name = "typeTasktypePlugintypeJob"

var _pipeAddType_index = [...]uint8{0, 8, 18, 25}

func (i pipeAddType) String() string {
	if i < 0 || i >= pipeAddType(len(_pipeAddType_index)-1) {
		return "pipeAddType(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _pipeAddType_name[_pipeAddType_index[i]:_pipeAddType_index[i+1]]
}
</file_content file: gopherbot-main/bot/pipeaddtype_string.go>
<preamble file: gopherbot-main/bot/pipecontext.go>

</preamble>
<file_content file: gopherbot-main/bot/pipecontext.go>
package bot

import (
	"crypto/rand"
	"fmt"
	"os/exec"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

/* pipeContext.go - internal methods on pipeContexts

Note that the pipeContext includes a sync.mutex, since it keeps pipeline state
and changes over the course of a running pipeline. Since the pipeContext is
nested in the worker, it can be locked with w.Lock() and modified with simple
assignments to w.xxx.
*/

// Global context run number (incrementing int)
var workerID = struct {
	idx int
	sync.Mutex
}{
	0,
	sync.Mutex{},
}

// Get the next context ID
func getWorkerID() int {
	workerID.Lock()
	for {
		workerID.idx++
		if workerID.idx == maxIndex {
			workerID.idx = 1
		}
		activePipelines.Lock()
		_, exists := activePipelines.i[workerID.idx]
		activePipelines.Unlock()
		if !exists {
			break
		}
	}
	ctxid := workerID.idx
	workerID.Unlock()
	return ctxid
}

// Global persistent maps of pipelines running, only used for listing/forcibly
// stopping pipelines.
var activePipelines = struct {
	i    map[int]*worker
	eids map[string]struct{}
	sync.Mutex
}{
	make(map[int]*worker),
	make(map[string]struct{}),
	sync.Mutex{},
}

// Assign a worker an external ID and register it in the global map of running
// pipelines.
func (w *worker) registerActive(parent *worker) {
	// Only needed for bots not created by IncomingMessage
	if w.maps == nil {
		currentUCMaps.Lock()
		w.maps = currentUCMaps.ucmap
		currentUCMaps.Unlock()
	}
	if len(w.ProtocolUser) == 0 && len(w.User) > 0 {
		if idRegex.MatchString(w.User) {
			w.ProtocolUser = w.User
		} else if ui, ok := w.maps.user[w.User]; ok {
			w.ProtocolUser = bracket(ui.UserID)
			w.BotUser = ui.BotUser
		} else {
			w.ProtocolUser = w.User
		}
	}
	if len(w.ProtocolChannel) == 0 && len(w.Channel) > 0 {
		if idRegex.MatchString(w.Channel) {
			w.ProtocolChannel = w.Channel
		} else if ci, ok := w.maps.channel[w.Channel]; ok {
			w.ProtocolChannel = bracket(ci.ChannelID)
		} else {
			w.ProtocolChannel = w.Channel
		}
	}

	activePipelines.Lock()
	if len(w.eid) == 0 {
		var eid string
		for {
			// 4 bytes of entropy per pipeline
			b := make([]byte, 4)
			rand.Read(b)
			eid = fmt.Sprintf("%02x%02x%02x%02x", b[0], b[1], b[2], b[3])
			if _, ok := activePipelines.eids[eid]; !ok {
				activePipelines.eids[eid] = struct{}{}
				break
			}
		}
		w.eid = eid
	}
	if parent != nil {
		parent._child = w
		w._parent = parent
	}
	activePipelines.i[w.id] = w
	activePipelines.Unlock()
	w.active = true
}

// deregister must be called for all registered Robots to prevent a memory leak.
func (w *worker) deregister() {
	w.Lock()
	id := w.id
	eid := w.eid
	w.active = false
	w.Unlock()
	activePipelines.Lock()
	delete(activePipelines.i, id)
	delete(activePipelines.eids, eid)
	activePipelines.Unlock()
}

// pipeContext is created for each running pipeline, and holds the state
// for the pipeline.
type pipeContext struct {
	// Parent and child values protected by the activePipelines lock
	_parent, _child  *worker
	workingDirectory string            // directory where tasks run relative to $(pwd)
	baseDirectory    string            // base for this pipeline relative to $(pwd), depends on `Homed`, affects SetWorkingDirectory
	eid              string            // unique ID for external tasks
	active           bool              // whether this context has been registered as active
	environment      map[string]string // environment vars set for each job/plugin in the pipeline
	runIndex         int               // run number of a job
	histName         string            // GetLog(histName, index) can be used in final/fail pipes
	verbose          bool              // flag if initializing job was verbose
	nextTasks        []TaskSpec        // tasks in the pipeline
	finalTasks       []TaskSpec        // clean-up tasks that always run when the pipeline ends
	failTasks        []TaskSpec        // clean-up tasks that run when a pipeline fails
	finalFailed      []string          // list of task names of final tasks that failed
	taskName         string            // name of current task
	taskDesc         string            // description for same
	taskType         string            // one of task, plugin, job
	taskClass        string            // one of Go, Ext
	plugCommand      string            // plugin command if type=plugin, else blank
	taskArgs         []string          // args for current task
	osCmd            *exec.Cmd         // running Command, for aborting a pipeline
	exclusiveTag     string            // tasks with the same exclusiveTag never run at the same time
	queueTask        bool              // whether to queue up if Exclusive call failed
	abortPipeline    bool              // Exclusive request failed w/o queueTask
	// Stuff we want to copy in makeRobot
	privileged          bool                // privileged jobs flip this flag, causing tasks in the pipeline to run in cfgdir
	timeZone            *time.Location      // for history timestamping
	logger              robot.HistoryLogger // where to send stdout / stderr
	ptype               pipelineType        // what started this pipeline
	elevated            bool                // set when required elevation succeeds
	stage               pipeStage           // which pipeline is being run; primaryP, finalP, failP
	jobInitialized      bool                // whether a job has started
	jobName             string              // name of the running job
	nameSpace           string              // namespace for the pipeline, used by exclusive, brain and environment
	nameSpaceParameters []robot.Parameter   // namespace shared parameters
	parameterSets       []string            // parametersets for the pipeline for environment
	pipeName, pipeDesc  string              // name and description of task that started pipeline
	nsExtension         string              // extended namespace
	currentTask         interface{}         // pointer to currently executing task
	exclusive           bool                // indicates task was running exclusively
}

func (c *pipeContext) section(name, info string) {
	if c.logger != nil {
		c.logger.Line("*** " + name + " - " + info)
	}
}
</file_content file: gopherbot-main/bot/pipecontext.go>
<preamble file: gopherbot-main/bot/pipelinetype_string.go>

</preamble>
<file_content file: gopherbot-main/bot/pipelinetype_string.go>
// Code generated by "stringer -type=pipelineType constants.go"; DO NOT EDIT.

package bot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[unset-0]
	_ = x[plugCommand-1]
	_ = x[plugMessage-2]
	_ = x[catchAll-3]
	_ = x[plugThreadSubscription-4]
	_ = x[jobTrigger-5]
	_ = x[spawnedTask-6]
	_ = x[scheduled-7]
	_ = x[initJob-8]
	_ = x[jobCommand-9]
}

const _pipelineType_name = "unsetplugCommandplugMessagecatchAllplugThreadSubscriptionjobTriggerspawnedTaskscheduledinitJobjobCommand"

var _pipelineType_index = [...]uint8{0, 5, 16, 27, 35, 57, 67, 78, 87, 94, 104}

func (i pipelineType) String() string {
	if i < 0 || i >= pipelineType(len(_pipelineType_index)-1) {
		return "pipelineType(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _pipelineType_name[_pipelineType_index[i]:_pipelineType_index[i+1]]
}
</file_content file: gopherbot-main/bot/pipelinetype_string.go>
<preamble file: gopherbot-main/bot/privsep.go>

</preamble>
<file_content file: gopherbot-main/bot/privsep.go>
//go:build linux || dragonfly || freebsd || netbsd || openbsd
// +build linux dragonfly freebsd netbsd openbsd

package bot

import (
	"fmt"
	"log"
	"runtime"

	"github.com/lnxjedi/gopherbot/robot"
	"golang.org/x/sys/unix"
)

var privUID, unprivUID int

/* NOTE on privsep and setuid gopherbot:
Gopherbot "flips" the traditional sense of setuid; gopherbot is normally run
by the desired user, and installed setuid to a non-priviliged account like
"nobody". This makes it possible to run several instances of gopherbot with
different uids on a single host with a single install.
*/

func init() {
	uid := unix.Getuid()
	euid := unix.Geteuid()
	if uid != euid {
		privUID = uid
		unprivUID = euid
		unix.Umask(0022)
		runtime.LockOSThread()
		unix.Setreuid(unprivUID, privUID)
		privSep = true
	}
}

func raiseThreadPriv(reason string) {
	if privSep {
		ruid := unix.Getuid()
		euid := unix.Geteuid()
		if euid == privUID {
			tid := unix.Gettid()
			Log(robot.Debug, "Successful privilege check for '%s'; r/e for thread %d: %d/%d", reason, tid, ruid, euid)
		} else {
			// Not privileged, create a new privileged thread
			runtime.LockOSThread()
			tid := unix.Gettid()
			err := unix.Setreuid(unprivUID, privUID)
			if err != nil {
				Log(robot.Error, "Calling Setreuid(%d, %d) in raiseThreadPriv: %v", unprivUID, privUID, err)
				return
			}
			Log(robot.Debug, "Successfully raised privilege for '%s' thread %d; old r/euid %d/%d; new r/euid: %d/%d", reason, tid, ruid, euid, unprivUID, privUID)
		}
	}
}

// When raising for external scripts, we need to permanently raise privilege
// to prevent Go from spawning a child thread unprivileged
func raiseThreadPrivExternal(reason string) {
	if privSep {
		runtime.LockOSThread()
		tid := unix.Gettid()
		err := unix.Setreuid(privUID, privUID)
		if err != nil {
			Log(robot.Error, "Calling Setreuid(%d, %d) in raiseThreadPriv: %v", unprivUID, privUID, err)
			return
		}
		Log(robot.Debug, "Successfully raised privilege permanently for '%s' thread %d; new r/euid: %d/%d", reason, tid, privUID, privUID)
	}
}

func dropThreadPriv(reason string) {
	if privSep {
		runtime.LockOSThread()
		tid := unix.Gettid()
		err := unix.Setreuid(unprivUID, unprivUID)
		if err != nil {
			Log(robot.Error, "Calling Setreuid(%d, %d) in dropThreadPriv: %v", unprivUID, unprivUID, err)
			return
		}
		Log(robot.Debug, "Successfully dropped privileges for '%s' in thread %d; new r/euid: %d/%d", reason, tid, unprivUID, unprivUID)
	}
}

func checkprivsep(l *log.Logger) {
	if privSep {
		runtime.LockOSThread()
		ruid := unix.Getuid()
		euid := unix.Geteuid()
		tid := unix.Gettid()
		l.Printf(fmt.Sprintf("Privilege separation initialized; daemon UID %d, unprivileged UID %d; thread %d r/euid: %d/%d\n", privUID, unprivUID, tid, ruid, euid))
	} else {
		l.Printf("Privilege separation not in use\n")
	}
}
</file_content file: gopherbot-main/bot/privsep.go>
<preamble file: gopherbot-main/bot/replyprompt.go>

</preamble>
<file_content file: gopherbot-main/bot/replyprompt.go>
package bot

import (
	"fmt"
	"regexp"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

/* Technical notes on the waiter implementation
 - or -
Why retryPrompt is sent to all waiters, instead of just the head of a queue

After spending a good deal of one morning re-writing waiters as a proper queue,
I realized the problem with that implementation. Each script plugin is
posting JSON to a port and waiting for a reply, and most script libraries will
timeout waiting after no more than a minute (which is why the replyTimeout is
45 seconds). If we queue up all waiters, and the user doesn't reply to the first
waiter (or second), then the second waiter in the queue might not get a reply
for a 90 seconds - by which time the script would crash. To be certain that
every waiting plugin gets some kind of return value within 60 seconds, we just
send retryPrompt to all waiters, and let them race to be first.

Realize this isn't as bad as it might seem; the list of waiters is per
user/channel combination, so this kind of thing only happens if a single user
is absolutely going crazy with firing off interactive commands in a single
channel.

The moral of the story: don't bother implementing a queue for reply waiters,
and think hard before doing things any differently.
*/

const replyTimeout = 45 * time.Second

type replyDisposition int

const (
	replied          replyDisposition = iota
	replyInterrupted                  // user started another command or canceled
	retryPrompt                       // another prompt was in progress
)

// a replyWaiter is used when a plugin is waiting for a reply
type replyWaiter struct {
	re           *regexp.Regexp // The regular expression the reply needs to match
	replyChannel chan reply     // The channel to send the reply to when it is received
}

// a reply matcher is used as the key in the replies map
type replyMatcher struct {
	user, channel, thread string // Only one reply at a time can be requested for a given user/channel/thread combination
}

// a reply is sent over the replyWaiter channel when a user replies
type reply struct {
	matched     bool             // true if the regex matched
	disposition replyDisposition // replied, interrupted, retry
	rep         string           // text of the reply
}

var replies = struct {
	m map[replyMatcher][]replyWaiter
	sync.Mutex
}{
	make(map[replyMatcher][]replyWaiter),
	sync.Mutex{},
}

type stockReply struct {
	repTag   string
	repRegex string
}

var stockRepliesRegex = `^[A-Z]`
var stockRepliesRe *regexp.Regexp

var stockReplies = make(map[string]*regexp.Regexp)

var stockReplyList = []stockReply{
	{"Email", `[\w-\.]+@(?:[\w-]+\.)+[\w-]{2,4}`},
	{"Domain", `(?:[\w-]+\.)+[\w-]{2,4}`},
	{"OTP", `\d{6}`},
	//	{ "IPaddr", `[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}` }
	{"IPaddr", `(?:(?:0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)\.){3}(?:0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)`},
	{"SimpleString", `[-\w .,_'"?!]+`},
	{"YesNo", `(?i:yes|no|Y|N)`},
}

func init() {
	stockRepliesRe = regexp.MustCompile(stockRepliesRegex)
	for _, sr := range stockReplyList {
		stockReplies[sr.repTag] = regexp.MustCompile(`^\s*` + sr.repRegex + `\s*$`)
	}
}

// PromptForReply lets a plugin direct a prompt string to a user and temporarily
// register a regex for a reply expected to a multi-step command when the robot
// needs more info. If the regular expression matches, it returns the matched
// text and RetVal = Ok.
// If there's an error getting the reply, it returns an empty string
// with one of the following RetVals:
//
//	 UserNotFound
//	 ChannelNotFound
//		Interrupted - the user canceled with '-'
//	 UseDefaultValue - user supplied a single "=", meaning "use the default value"
//		ReplyNotMatched - didn't successfully match for any reason
//		MatcherNotFound - the regexId didn't correspond to a valid regex
//		TimeoutExpired - the user didn't respond within the timeout window
//
// Plugin authors can define regex's for regexId's in the plugin's JSON config,
// with the restriction that the regexId must start with a lowercase letter.
// A pre-definied regex from the following list can also be used:
//
//		Email
//		Domain - an alpha-numeric domain name
//		OTP - a 6-digit one-time password code
//		IPAddr
//		SimpleString - Characters commonly found in most english sentences, doesn't
//	   include special characters like @, {, etc.
//		YesNo
func (r Robot) PromptForReply(regexID string, prompt string, v ...interface{}) (string, robot.RetVal) {
	var rep string
	var ret robot.RetVal
	if len(v) > 0 {
		prompt = fmt.Sprintf(prompt, v...)
	}
	for i := 0; i < 3; i++ {
		var thread string
		if r.Incoming.ThreadedMessage {
			thread = r.Incoming.ThreadID
		}
		rep, ret = r.promptInternal(regexID, r.User, r.Channel, thread, prompt)
		if ret == robot.RetryPrompt {
			continue
		}
		return rep, ret
	}
	if ret == robot.RetryPrompt {
		return rep, robot.Interrupted
	}
	return rep, ret
}

func (r Robot) PromptThreadForReply(regexID string, prompt string, v ...interface{}) (string, robot.RetVal) {
	var rep string
	var ret robot.RetVal
	if len(v) > 0 {
		prompt = fmt.Sprintf(prompt, v...)
	}
	for i := 0; i < 3; i++ {
		rep, ret = r.promptInternal(regexID, r.User, r.Channel, r.Incoming.ThreadID, prompt)
		if ret == robot.RetryPrompt {
			continue
		}
		return rep, ret
	}
	if ret == robot.RetryPrompt {
		return rep, robot.Interrupted
	}
	return rep, ret
}

// PromptUserForReply is identical to PromptForReply, but prompts a specific
// user with a DM.
func (r Robot) PromptUserForReply(regexID string, user string, prompt string, v ...interface{}) (string, robot.RetVal) {
	var rep string
	var ret robot.RetVal
	if len(v) > 0 {
		prompt = fmt.Sprintf(prompt, v...)
	}
	for i := 0; i < 3; i++ {
		rep, ret = r.promptInternal(regexID, user, "", "", prompt)
		if ret == robot.RetryPrompt {
			continue
		}
		return rep, ret
	}
	if ret == robot.RetryPrompt {
		return rep, robot.Interrupted
	}
	return rep, ret
}

// PromptUserChannelForReply is identical to PromptForReply, but prompts a
// specific user in a given channel.
func (r Robot) PromptUserChannelForReply(regexID string, user string, channel string, prompt string, v ...interface{}) (string, robot.RetVal) {
	var rep string
	var ret robot.RetVal
	if len(v) > 0 {
		prompt = fmt.Sprintf(prompt, v...)
	}
	for i := 0; i < 3; i++ {
		rep, ret = r.promptInternal(regexID, user, channel, "", prompt)
		if ret == robot.RetryPrompt {
			continue
		}
		return rep, ret
	}
	if ret == robot.RetryPrompt {
		return rep, robot.Interrupted
	}
	return rep, ret
}

// PromptUserChannelForReply is identical to PromptForReply, but prompts a
// specific user in a given channel.
func (r Robot) PromptUserChannelThreadForReply(regexID string, user, channel, thread string, prompt string, v ...interface{}) (string, robot.RetVal) {
	var rep string
	var ret robot.RetVal
	if len(v) > 0 {
		prompt = fmt.Sprintf(prompt, v...)
	}
	for i := 0; i < 3; i++ {
		rep, ret = r.promptInternal(regexID, user, channel, "", prompt)
		if ret == robot.RetryPrompt {
			continue
		}
		return rep, ret
	}
	if ret == robot.RetryPrompt {
		return rep, robot.Interrupted
	}
	return rep, ret
}

// promptInternal can return 'RetryPrompt'
func (r Robot) promptInternal(regexID, user, channel, thread, prompt string) (string, robot.RetVal) {
	matcher := replyMatcher{
		user:    user,
		channel: channel,
		thread:  thread,
	}
	var rep replyWaiter
	task, _, job := getTask(r.currentTask)
	isJob := job != nil
	if stockRepliesRe.MatchString(regexID) {
		rep.re = stockReplies[regexID]
	} else {
		var rm []InputMatcher
		if isJob {
			rm = job.Arguments
		} else {
			rm = task.ReplyMatchers
		}
		for _, matcher := range rm {
			if matcher.Label == regexID {
				rep.re = matcher.re
				break
			} else if matcher.Command == regexID {
				rep.re = matcher.re
				break
			}
		}
	}
	if rep.re == nil {
		Log(robot.Error, "Unable to resolve a reply matcher for plugin %s, regexID %s", task.name, regexID)
		return "", robot.MatcherNotFound
	}
	rep.replyChannel = make(chan reply)

	replies.Lock()
	// See if there's already a continuation in progress for this Robot:user,channel,
	// and if so append to the list of waiters.
	waiters, exists := replies.m[matcher]
	if exists {
		Log(robot.Debug, "Delaying prompt \"%s\" and appending to the list of waiters for matcher: %q", prompt, matcher)
		waiters = append(waiters, rep)
		replies.m[matcher] = waiters
		replies.Unlock()
	} else {
		Log(robot.Debug, "Prompting for \"%s\" and creating reply waiters list and prompting for matcher: %q", prompt, matcher)
		var puser string
		if ui, ok := r.maps.user[user]; ok {
			puser = bracket(ui.UserID)
		} else {
			puser = user
		}
		var ret robot.RetVal
		if channel == "" {
			ret = interfaces.SendProtocolUserMessage(puser, prompt, r.Format, r.Incoming)
		} else {
			ret = interfaces.SendProtocolUserChannelThreadMessage(puser, user, channel, thread, prompt, r.Format, r.Incoming)
		}
		if ret != robot.Ok {
			replies.Unlock()
			return "", ret
		}
		waiters = make([]replyWaiter, 1, 2)
		waiters[0] = rep
		replies.m[matcher] = waiters
		replies.Unlock()
	}
	var replied reply
	select {
	case <-time.After(replyTimeout):
		Log(robot.Warn, "Timed out waiting for a reply to regex \"%s\" in channel: %s", regexID, channel)
		replies.Lock()
		waitlist, found := replies.m[matcher]
		if found {
			// reply timed out, free up this matcher for later reply requests
			delete(replies.m, matcher)
			replies.Unlock()
			Log(robot.Debug, "Timeout expired waiting for reply to: %s", prompt)
			// let other waiters know to retry
			for i, rep := range waitlist {
				if i != 0 {
					Log(robot.Debug, "Sending retryPrompt to waiters on primary waiter timeout")
					rep.replyChannel <- reply{false, retryPrompt, ""}
				}
			}
			// matched=false, timedOut=true
			return "", robot.TimeoutExpired
		}
		// race: we got a reply at the timeout deadline, and lost the race
		// to delete the entry, so we read the reply as if the timeout hadn't
		// expired.
		replies.Unlock()
		replied = <-rep.replyChannel
	case replied = <-rep.replyChannel:
	}
	if replied.disposition == replyInterrupted {
		return "", robot.Interrupted
	}
	if replied.disposition == retryPrompt {
		return "", robot.RetryPrompt
	}
	// Note: the replies.m[] entry is deleted in handleMessage
	if !replied.matched {
		if replied.rep == "=" {
			return "", robot.UseDefaultValue
		}
		if replied.rep == "-" {
			return "", robot.Interrupted
		}
		return "", robot.ReplyNotMatched
	}
	return replied.rep, robot.Ok
}
</file_content file: gopherbot-main/bot/replyprompt.go>
<preamble file: gopherbot-main/bot/robot.go>

</preamble>
<file_content file: gopherbot-main/bot/robot.go>
package bot

import (
	"fmt"
	"path/filepath"
	"reflect"
	"strings"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

/* robot_methods.go defines some convenience functions on struct Robot to
   simplify use by plugins. */

// Robot is the internal struct for a robot.Message, with bits copied
// from the pipeContext; see that struct for better descriptions.
// A new Robot is created for every task, plugin or job executed by
// callTask(...).
type Robot struct {
	*robot.Message
	tid          int                         // task ID for looking up the *worker
	*pipeContext                             // snapshot copy of pipeline context
	cfg          *configuration              // convenience only; r.cfg shorter than r.worker.cfg
	tasks        *taskList                   // same
	maps         *userChanMaps               // same
	repositories map[string]robot.Repository // same
}

// Incrementing tid for individual tasks that run, so Go Robots
// can look up the *worker when needed.
var taskID = struct {
	idx int
	sync.Mutex
}{
	0,
	sync.Mutex{},
}

// Get the next task ID; 0 is an illegal value
func getTaskID() int {
	taskID.Lock()
	taskID.idx++
	if taskID.idx == 0 {
		taskID.idx = 1
	}
	tid := taskID.idx
	taskID.Unlock()
	return tid
}

// makeRobot returns a Robot for plugins; the tid lets Robot methods
// get a reference back to the original context when needed. The Robot
// should contain a copy of almost all of the information needed for plugins
// to run.
func (w *worker) makeRobot() Robot {
	r := Robot{
		tid: getTaskID(),
		// Copy these bits, which can be modified for an individual Robot
		Message: &robot.Message{
			User:            w.User,
			ProtocolUser:    w.ProtocolUser,
			Channel:         w.Channel,
			ProtocolChannel: w.ProtocolChannel,
			Format:          w.Format,
			Protocol:        w.Protocol,
			Incoming:        w.Incoming,
		},
		cfg:          w.cfg,
		tasks:        w.tasks,
		maps:         w.maps,
		repositories: w.repositories,
	}
	if w.pipeContext != nil {
		r.pipeContext = &pipeContext{
			privileged:     w.privileged,
			timeZone:       w.timeZone,
			logger:         w.logger,
			ptype:          w.ptype,
			elevated:       w.elevated,
			stage:          w.stage,
			jobInitialized: w.jobInitialized,
			jobName:        w.jobName,
			nameSpace:      w.nameSpace,
			pipeName:       w.pipeName,
			pipeDesc:       w.pipeDesc,
			nsExtension:    w.nsExtension,
			currentTask:    w.currentTask,
			exclusive:      w.exclusive,
		}
	}
	return r
}

func (w *worker) makeMemoryContext(key string) memoryContext {
	var threadID string
	if w.Incoming.ThreadedMessage {
		threadID = w.Incoming.ThreadID
	}
	return memoryContext{
		key:     key,
		user:    w.Incoming.UserID,
		channel: w.Channel,
		thread:  threadID,
	}
}

func (r Robot) makeMemoryContext(key string, forceThread, shared bool) memoryContext {
	var threadID string
	if r.Incoming.ThreadedMessage || forceThread {
		threadID = r.Incoming.ThreadID
	}
	user := r.Incoming.UserID
	// if len(r.Channel) == 0, it's a direct message to the robot
	// and the idea of shared is meaningless - plus we NEED the user ID
	// to differentiate between different user's DM memories
	if shared && len(r.Channel) > 0 {
		user = ""
	}
	return memoryContext{
		key:     key,
		user:    user,
		channel: r.Channel,
		thread:  threadID,
	}
}

// CheckAdmin returns true if the user is a configured administrator of the
// robot, and true for automatic tasks. Should be used sparingly, when a single
// plugin has multiple commands, some which require admin. Otherwise the plugin
// should just configure RequireAdmin: true
func (r Robot) CheckAdmin() bool {
	// Note that this does "the right thing", using the user from the worker;
	// the user in the Robot is writeable.
	w := getLockedWorker(r.tid)
	w.Unlock()
	return w.CheckAdmin()
}

func (w *worker) CheckAdmin() bool {
	if w.automaticTask {
		return true
	}
	for _, adminUser := range w.cfg.adminUsers {
		if w.User == adminUser {
			if !w.listedUser {
				Log(robot.Error, "admin user %s not listed in roster; failing admin check", w.User)
				emit(AdminCheckFailed)
				return false
			}
			emit(AdminCheckPassed)
			return true
		}
	}
	emit(AdminCheckFailed)
	return false
}

// RaisePriv lets go plugins raise privilege for a thread, allowing filesystem
// access in GOPHER_HOME.
func (r Robot) RaisePriv(reason string) {
	raiseThreadPriv(reason)
}

// SetParameter sets a parameter for the current pipeline, useful only for
// passing parameters (as environment variables) to tasks later in the pipeline.
func (r Robot) SetParameter(name, value string) bool {
	if !identifierRe.MatchString(name) {
		return false
	}
	w := getLockedWorker(r.tid)
	defer w.Unlock()
	c := w.pipeContext
	c.environment[name] = value
	return true
}

// SetWorkingDirectory sets the working directory of the pipeline for all scripts
// executed. The value of path is interpreted as follows:
//   - "/absolute/path" - tasks that follow will start with this workingDirectory;
//     "cleanup" won't work, see tasks/cleanup.sh (unsafe)
//   - "relative/path" - sets workingDirectory relative to baseDirectory;
//     workSpace or $(pwd) depending on value of Homed for the job/plugin starting
//     the pipeline
//   - "./sub/directory" - appends to the current workingDirectory
//   - "." - resets workingDirectory to baseDirectory
//
// Fails if the new working directory doesn't exist
// See also: tasks/setworkdir.sh for updating working directory in a pipeline
func (r Robot) SetWorkingDirectory(path string) bool {
	w := getLockedWorker(r.tid)
	defer w.Unlock()
	c := w.pipeContext
	if path == "." {
		c.workingDirectory = c.baseDirectory
		return true
	}
	if filepath.IsAbs(path) {
		raiseThreadPriv("checking absolute path")
		_, ok := checkDirectory(path)
		if ok {
			c.workingDirectory = path
		} else {
			r.Log(robot.Error, "Invalid path '%s' in SetWorkingDirectory", path)
		}
		return ok
	}
	if strings.HasPrefix(path, "./") {
		checkPath := filepath.Join(c.workingDirectory, path)
		_, ok := checkDirectory(checkPath)
		if ok {
			c.workingDirectory = checkPath
		} else {
			r.Log(robot.Error, "Invalid path '%s'(%s) in SetWorkingDirectory", path, checkPath)
		}
		return ok
	}
	checkPath := filepath.Join(c.baseDirectory, path)
	_, ok := checkDirectory(checkPath)
	if ok {
		c.workingDirectory = checkPath
	} else {
		r.Log(robot.Error, "Invalid path '%s'(%s) in SetWorkingDirectory", path, checkPath)
	}
	return ok
}

// GetParameter retrieves the value of a parameter for a namespace. Only useful
// for Go plugins; external scripts have all parameters for the NameSpace stored
// as environment variables. Note that runtasks.go populates the environment
// with Stored parameters, too. So GetParameter is useful for both ephemeral
// parameters in a pipeline, and for getting long-term parameters such as
// credentials.
func (r Robot) GetParameter(key string) string {
	value, ok := r.environment[key]
	if ok {
		return value
	}
	return ""
}

// Elevate lets a plugin request elevation on the fly. When immediate = true,
// the elevator should always prompt for 2fa; otherwise a configured timeout
// should apply.
func (r Robot) Elevate(immediate bool) bool {
	task, _, _ := getTask(r.currentTask)
	retval := r.elevate(task, immediate)
	if retval == robot.Success {
		return true
	}
	return false
}

// Fixed is a deprecated convenience function for sending a message with fixed width
// font.
func (r Robot) Fixed() robot.Robot {
	nr := r
	m := *r.Message
	nr.Message = &m
	nr.Format = robot.Fixed
	return nr
}

// MessageFormat returns a robot object with the given format, most likely for a
// plugin that will mostly use e.g. Variable format.
func (r Robot) MessageFormat(f robot.MessageFormat) robot.Robot {
	nr := r
	m := *r.Message
	nr.Message = &m
	nr.Format = f
	return nr
}

// Direct is a convenience function for initiating a DM conversation with a
// user. Created initially so a plugin could prompt for a password in a DM.
func (r Robot) Direct() robot.Robot {
	nr := r
	m := *r.Message
	nr.Message = &m
	nr.Channel = ""
	return nr
}

// Threaded associates the robot with the thread of the incoming message.
func (r Robot) Threaded() robot.Robot {
	nr := r
	m := *r.Message
	nr.Message = &m
	if len(nr.Channel) > 0 {
		nr.Incoming.ThreadedMessage = true
	} else {
		nr.Incoming.ThreadedMessage = false
	}
	return nr
}

// Pause is a convenience function to pause some fractional number of seconds.
func (r Robot) Pause(s float64) {
	ms := time.Duration(s * float64(1000))
	time.Sleep(ms * time.Millisecond)
}

// RandomString is a convenience function for returning a random string
// from a slice of strings, so that replies can vary.
func (r Robot) RandomString(s []string) string {
	l := len(s)
	if l == 0 {
		return ""
	}
	return s[random.Intn(l)]
}

// RandomInt uses the robot's seeded random to return a random int 0 <= retval < n
func (r Robot) RandomInt(n int) int {
	return random.Intn(n)
}

// GetBotAttribute returns an attribute of the robot or "" if unknown.
// Current attributes:
// name, alias, fullName, contact
func (r Robot) GetBotAttribute(a string) *robot.AttrRet {
	a = strings.ToLower(a)
	ret := robot.Ok
	var attr string
	switch a {
	case "name":
		attr = r.cfg.botinfo.UserName
	case "fullname", "realname":
		attr = r.cfg.botinfo.FullName
	case "alias":
		attr = string(r.cfg.alias)
	case "mail", "email":
		attr = r.cfg.botinfo.Email
	case "contact", "admin", "admincontact":
		attr = r.cfg.adminContact
	case "protocol":
		attr = r.Protocol.String()
	case "id", "internalid", "protocolid":
		attr = fmt.Sprintf("<%s>", r.cfg.botinfo.UserID)
	default:
		ret = robot.AttributeNotFound
	}
	return &robot.AttrRet{attr, ret}
}

/*
GetTaskConfig sets a struct pointer to point to a config struct populated
from configuration when plugins were loaded. To use, a plugin should define
a struct for it's configuration data, e.g.:

	type pConf struct {
		Username, Password string
	}

In conf/plugins/<pluginname>.yaml, you would add a Config: stanza, e.g.:

	Config:
	  Username: foo
	  Password: bar

When registering the plugin, you pass a pointer to an empty config template, which the
robot will use to populate a struct when configuration is loaded:

	func init() {
		bot.RegisterPlugin("memes", bot.PluginHandler{
			DefaultConfig: defaultConfig, // yaml string providing default configuration
			Handler:       plugfunc, // callback function
			Config:        &pConf{}, // pointer to empty config struct
		})
	}

Then, to get a current copy of configuration when the plugin runs, define a struct pointer
and call GetTaskConfig with a double-pointer:

	var c *pConf
	r.GetTaskConfig(&c)

... And voila! *pConf is populated with the contents from the configured Config: stanza
*/
func (r Robot) GetTaskConfig(dptr interface{}) robot.RetVal {
	task, _, _ := getTask(r.currentTask)
	if task.config == nil {
		Log(robot.Error, "Task \"%s\" called GetTaskConfig, but no config was found.", task.name)
		return robot.NoConfigFound
	}
	tp := reflect.ValueOf(dptr)
	if tp.Kind() != reflect.Ptr {
		Log(robot.Error, "Task \"%s\" called GetTaskConfig, but didn't pass a double-pointer to a struct", task.name)
		return robot.InvalidDblPtr
	}
	p := reflect.Indirect(tp)
	if p.Kind() != reflect.Ptr {
		Log(robot.Error, "Task \"%s\" called GetTaskConfig, but didn't pass a double-pointer to a struct", task.name)
		return robot.InvalidDblPtr
	}
	if p.Type() != reflect.ValueOf(task.config).Type() {
		Log(robot.Error, "Task \"%s\" called GetTaskConfig with an invalid double-pointer", task.name)
		return robot.InvalidCfgStruct
	}
	p.Set(reflect.ValueOf(task.config))
	return robot.Ok
}

// Log logs a message to the robot's log file (or stderr) if the level
// is lower than or equal to the robot's current log level
func (r Robot) Log(l robot.LogLevel, msg string, v ...interface{}) (logged bool) {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	logged = Log(l, msg)
	// All robot Log calls get logged to terminal output
	if !logged && localTerm {
		if terminalWriter != nil {
			terminalWriter.Write([]byte("LOG " + logLevelToStr(l) + ": " + msg + "\n"))
		} else {
			botStdOutLogger.Print("LOG " + logLevelToStr(l) + ": " + msg)
		}
	}
	if r.logger != nil {
		line := "LOG " + logLevelToStr(l) + ": " + msg
		r.logger.Log(strings.TrimSpace(line))
	}
	return
}
</file_content file: gopherbot-main/bot/robot.go>
<preamble file: gopherbot-main/bot/robot_connector_methods.go>

</preamble>
<file_content file: gopherbot-main/bot/robot_connector_methods.go>
package bot

import (
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

// GetMessage returns a pointer to the message struct
func (r Robot) GetMessage() *robot.Message {
	return r.Message
}

// GetUserAttribute returns a AttrRet with
// - The string Attribute of a user, or "" if unknown/error
// - A RetVal which is one of Ok, UserNotFound, AttributeNotFound
// Current attributes:
// name(handle), fullName, email, firstName, lastName, phone, internalID
// TODO: supplement data with robot.yaml user's table, if an
// admin wants to supplment whats available from the protocol.
func (r Robot) GetUserAttribute(u, a string) *robot.AttrRet {
	a = strings.ToLower(a)
	var user string
	var ui *UserInfo
	var ok bool
	if ui, ok = r.maps.user[u]; ok {
		user = "<" + ui.UserID + ">"
	} else {
		user = u
	}
	if ui != nil {
		var attr string
		switch a {
		case "name", "username", "handle", "user":
			attr = ui.UserName
		case "id", "internalid", "protocolid":
			attr = ui.UserID
		case "mail", "email":
			attr = ui.Email
		case "fullname", "realname":
			attr = ui.FullName
		case "firstname", "givenname":
			attr = ui.FirstName
		case "lastname", "surname":
			attr = ui.LastName
		case "phone":
			attr = ui.Phone
		}
		if len(attr) > 0 {
			return &robot.AttrRet{attr, robot.Ok}
		}
	}
	attr, ret := interfaces.GetProtocolUserAttribute(user, a)
	return &robot.AttrRet{attr, ret}
}

// GetSenderAttribute returns a AttrRet with
// - The string Attribute of the sender, or "" if unknown/error
// - A RetVal which is one of Ok, UserNotFound, AttributeNotFound
// Current attributes:
// name(handle), fullName, email, firstName, lastName, phone, internalID
// TODO: (see above)
func (r Robot) GetSenderAttribute(a string) *robot.AttrRet {
	a = strings.ToLower(a)
	var ui *UserInfo
	ui, _ = r.maps.user[r.User]
	switch a {
	case "name", "username", "handle", "user":
		return &robot.AttrRet{r.User, robot.Ok}
	case "id", "internalid", "protocolid":
		return &robot.AttrRet{r.ProtocolUser, robot.Ok}
	}
	if ui != nil {
		var attr string
		switch a {
		case "mail", "email":
			attr = ui.Email
		case "fullname", "realname":
			attr = ui.FullName
		case "firstname", "givenname":
			attr = ui.FirstName
		case "lastname", "surname":
			attr = ui.LastName
		case "phone":
			attr = ui.Phone
		}
		if len(attr) > 0 {
			return &robot.AttrRet{attr, robot.Ok}
		}
	}
	user := r.ProtocolUser
	if len(user) == 0 {
		user = r.User
	}
	attr, ret := interfaces.GetProtocolUserAttribute(user, a)
	return &robot.AttrRet{attr, ret}
}
</file_content file: gopherbot-main/bot/robot_connector_methods.go>
<preamble file: gopherbot-main/bot/robot_pipecmd.go>

</preamble>
<file_content file: gopherbot-main/bot/robot_pipecmd.go>
package bot

import (
	"fmt"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

// GetRepoData returns the contents of configPath/conf/repodata.yaml, or an
// empty map/dict/hash. Mainly for GopherCI, Methods for Python and Ruby will
// retrieve it. Returns nil and logs an error if the calling task isn't a job,
// or the namespace has already been extended.
func (r Robot) GetRepoData() map[string]robot.Repository {
	t, p, j := getTask(r.currentTask)
	if j == nil && p == nil {
		r.Log(robot.Error, "GetRepoData called by non-job/plugin task '%s'", t.name)
		return nil
	}
	if len(r.nsExtension) > 0 {
		r.Log(robot.Error, "GetRepoData called with namespace extended: '%s'", r.nsExtension)
		return nil
	}
	export := make(map[string]robot.Repository)
	for r, d := range r.repositories {
		e := robot.Repository{
			Type:         d.Type,
			CloneURL:     d.CloneURL,
			Dependencies: d.Dependencies,
			KeepLogs:     d.KeepLogs,
			Parameters:   []robot.Parameter{},
		}
		export[r] = e
	}
	return export
}

// ExtendNamespace is for CI/CD applications to support building multiple
// repositories from a single triggered job. When ExtendNamespace is called,
// all future long-term memory lookups are prefixed with the extended
// namespace, and a new history is started for the extended namespace,
// including the branch (needed to differentiate histories for differing
// branches).
// It is an error to call ExtendNamespace twice in a single job pipeline, or
// outside of a running job. The histories argument is interpreted as the
// number of histories to keep for the extended namespace, or -1 to inherit
// from the parent job. The jobName must match the repository Type, to protect
// secret parameters stored in repositories.yaml.
// Arguments:
// ext (extension) => "<repository>/<branch>", where repository is listed in
//
//	repositories.yaml
//
// histories => number of histories to keep
func (r Robot) ExtendNamespace(ext string, histories int) bool {
	if strings.ContainsRune(ext, ':') {
		r.Log(robot.Error, "Invalid namespace extension contains ':'")
		return false
	}
	if r.stage != primaryTasks {
		r.Log(robot.Error, "ExtendNamespace called after pipeline end")
		return false
	}
	if len(r.jobName) == 0 {
		r.Log(robot.Error, "ExtendNamespace called with no job in progress")
		return false
	}
	if len(r.nsExtension) > 0 {
		r.Log(robot.Error, "ExtendNamespace called after namespace already extended")
		return false
	}
	cmp := strings.Split(ext, "/")
	repo := strings.Join(cmp[0:len(cmp)-1], "/")
	branch := cmp[len(cmp)-1]
	repository, exists := r.repositories[repo]
	if !exists {
		r.Log(robot.Error, "Repository '%s' not found in repositories.yaml (missing branch in call to ExtendNamespace?)", repo)
		return false
	}
	if r.jobName != repository.Type {
		r.Log(robot.Error, "Space called with jobName(%s) != repository Type(%s)", r.jobName, repository.Type)
		return false
	}
	r.Log(robot.Debug, "Extending namespace for job '%s': %s (branch %s)", r.jobName, repo, branch)
	w := getLockedWorker(r.tid)
	w.nsExtension = ext
	// old, deprecated, TODO: remove me someday
	w.environment["GOPHER_NAMESPACE_EXTENDED"] = repo
	// new hotness
	w.environment["GOPHER_REPOSITORY"] = repo
	jobLogger := w.logger
	wid := w.id
	eid := w.eid
	w.Unlock()

	jk := histPrefix + r.jobName
	var pjh pipeHistory
	jtok, _, jret := checkoutDatum(jk, &pjh, true)
	if jret != robot.Ok {
		r.Log(robot.Error, "Problem checking out '%s', unable to record extended namespace '%s'", jk, ext)
	} else {
		if len(pjh.ExtendedNamespaces) == 0 {
			pjh.ExtendedNamespaces = []string{ext}
			ret := updateDatum(jk, jtok, pjh)
			if ret != robot.Ok {
				r.Log(robot.Error, "Problem updating '%s', unable to record extended namespace '%s'", jk, ext)
			}
		} else {
			found := false
			for _, ns := range pjh.ExtendedNamespaces {
				if ns == ext {
					found = true
					break
				}
			}
			if !found {
				pjh.ExtendedNamespaces = append(pjh.ExtendedNamespaces, ext)
				ret := updateDatum(jk, jtok, pjh)
				if ret != robot.Ok {
					r.Log(robot.Error, "Problem updating '%s', unable to record extended namespace '%s'", jk, ext)
				}
			} else {
				checkinDatum(jk, jtok)
			}
		}
	}

	tag := r.jobName + ":" + repo
	var nh int
	if histories != -1 {
		nh = histories
	} else {
		j := r.tasks.getTaskByName(r.jobName)
		_, _, job := getTask(j)
		nh = job.KeepLogs
	}
	pipeHistory, link, ref, idx := newLogger(tag, eid, branch, wid, nh)
	w.section("close log", fmt.Sprintf("Job '%s' extended namespace: '%s'; starting new log on next task", r.jobName, ext))
	jobLogger.Close()
	jobLogger.Finalize()
	w.Lock()
	w.histName = tag
	w.runIndex = idx
	if nh > 0 && len(link) > 0 {
		w.environment["GOPHER_LOG_LINK"] = link
	} else {
		delete(w.environment, "GOPHER_LOG_LINK")
	}
	if nh > 0 && len(ref) > 0 {
		w.environment["GOPHER_LOG_REF"] = ref
	} else {
		delete(w.environment, "GOPHER_LOG_REF")
	}
	// Question: should repository parameters override job parameters, but _not_
	// parameters set with SetParameter?
	for _, param := range repository.Parameters {
		name := param.Name
		value := param.Value
		w.environment[name] = value
	}
	w.logger = pipeHistory
	w.Unlock()
	w.section("new log", fmt.Sprintf("Extended log created by job '%s'", r.jobName))
	r.Log(robot.Debug, "Started new history for job '%s' with namespace '%s'", r.jobName, ext)
	return true
}

// pipeTask does all the real work of adding tasks to pipelines or spawning
// new tasks.
func (r Robot) pipeTask(pflavor pipeAddFlavor, ptype pipeAddType, name string, args ...string) robot.RetVal {
	if r.stage != primaryTasks {
		task, _, _ := getTask(r.currentTask)
		r.Log(robot.Error, "Request to modify pipeline outside of initial pipeline in task '%s'", task.name)
		return robot.InvalidStage
	}
	t := r.tasks.getTaskByName(name)
	if t == nil {
		task, _, _ := getTask(r.currentTask)
		r.Log(robot.Error, "Task '%s' not found updating pipeline from task '%s'", name, task.name)
		return robot.TaskNotFound
	}
	task, plugin, job := getTask(t)
	isPlugin := plugin != nil
	isJob := job != nil
	if task.Disabled {
		r.Log(robot.Error, "Attempt to add disabled task '%s' to pipeline", name)
		return robot.TaskDisabled
	}
	if ptype == typePlugin && !isPlugin {
		r.Log(robot.Error, "Adding command to pipeline - not a plugin: %s", name)
		return robot.InvalidTaskType
	}
	if ptype == typeJob && !isJob {
		r.Log(robot.Error, "Adding job to pipeline - not a job: %s", name)
		return robot.InvalidTaskType
	}
	if ptype == typeTask && (isJob || isPlugin) {
		r.Log(robot.Error, "Adding task to pipeline - not a task: %s", name)
		return robot.InvalidTaskType
	}
	if !r.privileged {
		if isJob && job.Privileged {
			r.Log(robot.Error, "PrivilegeViolation adding privileged job '%s' to unprivileged pipeline", name)
			return robot.PrivilegeViolation
		}
		if isPlugin && plugin.Privileged {
			r.Log(robot.Error, "PrivilegeViolation adding privileged plugin '%s' to unprivileged pipeline", name)
			return robot.PrivilegeViolation
		}
		if !isJob && !isPlugin && task.Privileged {
			r.Log(robot.Error, "PrivilegeViolation adding privileged task '%s' to unprivileged pipeline", name)
			return robot.PrivilegeViolation
		}
	}
	var command string
	var cmdargs []string
	if isPlugin {
		if len(args) == 0 {
			r.Log(robot.Error, "Added plugin '%s' to pipeline with no command", name)
			return robot.MissingArguments
		}
		if len(args[0]) == 0 {
			r.Log(robot.Error, "Added plugin '%s' to pipeline with no command", name)
			return robot.MissingArguments
		}
		cmsg := args[0]
		matched := false
		for _, matcher := range plugin.CommandMatchers {
			Log(robot.Trace, "Checking '%s' against '%s'", cmsg, matcher.Regex)
			matches := matcher.re.FindAllStringSubmatch(cmsg, -1)
			if matches != nil {
				matched = true
				Log(robot.Trace, "Pipeline command '%s' matches '%s'", cmsg, matcher.Command)
				command = matcher.Command
				cmdargs = matches[0][1:]
				break
			}
		}
		if !matched {
			r.Log(robot.Error, "Command '%s' didn't match any CommandMatchers while adding plugin '%s' to pipeline", cmsg, name)
			return robot.CommandNotMatched
		}
	} else {
		command = "run"
		cmdargs = args
	}
	ts := TaskSpec{
		Name:      name,
		Command:   command,
		Arguments: cmdargs,
		task:      t,
	}
	argstr := strings.Join(args, " ")
	r.Log(robot.Debug, "Adding pipeline task %s/%s: %s %s", pflavor, ptype, name, argstr)
	w := getLockedWorker(r.tid)
	switch pflavor {
	case flavorAdd:
		w.nextTasks = append(w.nextTasks, ts)
		w.Unlock()
	case flavorFinal:
		// Final tasks are FILO/LIFO (run in reverse order of being added)
		w.finalTasks = append([]TaskSpec{ts}, w.finalTasks...)
		w.Unlock()
	case flavorFail:
		w.failTasks = append(w.failTasks, ts)
		w.Unlock()
	case flavorSpawn:
		w.Unlock()
		sb := w.clone()
		go sb.startPipeline(nil, t, spawnedTask, command, args...)
	}
	return robot.Ok
}

// SpawnJob creates a new pipeContext in a new goroutine to run a
// job. It's primary use is for CI/CD applications where a single
// triggered job may want to spawn several jobs when e.g. a dependency for
// multiple projects is updated.
func (r Robot) SpawnJob(name string, args ...string) robot.RetVal {
	return r.pipeTask(flavorSpawn, typeJob, name, args...)
}

// AddTask puts another task (job or plugin) in the queue for the pipeline. Unlike other
// CI/CD tools, gopherbot pipelines are code generated, not configured; it is,
// however, trivial to write code that reads an arbitrary configuration file
// and uses AddTask to generate a pipeline. When the task is a plugin, cmdargs
// should be a command followed by arguments. For jobs, cmdargs are just
// arguments passed to the job.
func (r Robot) AddTask(name string, args ...string) robot.RetVal {
	return r.pipeTask(flavorAdd, typeTask, name, args...)
}

// FinalTask adds a task that always runs when the pipeline ends, whether
// it succeeded or failed. This can be used to ensure that cleanup tasks like
// terminating a VM or stopping the ssh-agent will run, regardless of whether
// the pipeline failed.
// Note that unlike other tasks, final tasks are run in reverse of the order
// they're added.
func (r Robot) FinalTask(name string, args ...string) robot.RetVal {
	return r.pipeTask(flavorFinal, typeTask, name, args...)
}

// FailTask adds a task that runs only if the pipeline fails. This can be used
// to e.g. notify a user / channel on failure.
func (r Robot) FailTask(name string, args ...string) robot.RetVal {
	return r.pipeTask(flavorFail, typeTask, name, args...)
}

// AddJob puts another job in the queue for the pipeline. The added job
// will run in a new separate context, and when it completes the current
// pipeline will resume if the job succeeded.
func (r Robot) AddJob(name string, args ...string) robot.RetVal {
	return r.pipeTask(flavorAdd, typeJob, name, args...)
}

// AddCommand adds a plugin command to the pipeline. The command string
// argument should match a CommandMatcher for the given plugin.
func (r Robot) AddCommand(plugname, command string) robot.RetVal {
	return r.pipeTask(flavorAdd, typePlugin, plugname, command)
}

// FinalCommand adds a plugin command that always runs when a pipeline
// ends, for e.g. emailing the job history. The command string
// argument should match a CommandMatcher for the given plugin.
func (r Robot) FinalCommand(plugname, command string) robot.RetVal {
	return r.pipeTask(flavorFinal, typePlugin, plugname, command)
}

// FailCommand adds a plugin command that runs whenever a pipeline fails,
// for e.g. emailing the job history. The command string
// argument should match a CommandMatcher for the given plugin.
func (r Robot) FailCommand(plugname, command string) robot.RetVal {
	return r.pipeTask(flavorFail, typePlugin, plugname, command)
}
</file_content file: gopherbot-main/bot/robot_pipecmd.go>
<preamble file: gopherbot-main/bot/run_pipelines.go>

</preamble>
<file_content file: gopherbot-main/bot/run_pipelines.go>
package bot

import (
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

var envPassThrough = []string{
	"HOSTNAME",
	"LANG",
	"PATH",
	"USER",
}

// startPipeline is triggered by plugins, job triggers, scheduled tasks, and child jobs
// Called from dispatch: checkPluginMatchersAndRun,
// jobcommands: checkJobMatchersAndRun or ScheduledTask,
// runPipeline.
func (w *worker) startPipeline(parent *worker, t interface{}, ptype pipelineType, command string, args ...string) (ret robot.TaskRetVal) {
	task, plugin, job := getTask(t)
	state.RLock()
	if state.shuttingDown && task.name != "builtin-admin" {
		state.RUnlock()
		Log(robot.Warn, "Not starting new pipeline for task '%s', shutting down", task.name)
		return robot.RobotStopping
	}
	state.RUnlock()
	isJob := job != nil
	isPlugin := plugin != nil
	var ppipeName, ppipeDesc string
	if parent != nil {
		parent.Lock()
		ppipeName = parent.pipeName
		ppipeDesc = parent.pipeDesc
		parent.Unlock()
	}
	// NOTE: we don't need to worry about locking until the pipeline actually starts
	c := &pipeContext{
		environment: make(map[string]string),
	}
	w.pipeContext = c
	c.pipeName = task.name
	c.pipeDesc = task.Description
	if isPlugin {
		c.privileged = plugin.Privileged
	} else {
		c.privileged = job.Privileged
	}
	c.environment["GOPHER_WORKSPACE"] = w.cfg.workSpace
	// Initial baseDirectory and workingDirectory are the same; SetWorkingDirectory
	// modifies workingDirectory.
	if task.Homed {
		c.baseDirectory = "."
		c.workingDirectory = "."
	} else {
		c.baseDirectory = w.cfg.workSpace
		c.workingDirectory = w.cfg.workSpace
	}
	// Spawned pipelines keep the original ptype
	if c.ptype == unset {
		c.ptype = ptype
	}
	c.timeZone = w.cfg.timeZone
	// redundant but explicit
	c.stage = primaryTasks
	// TODO: Replace the waitgroup, pipelinesRunning, defer func(), etc.
	state.Add(1)
	state.Lock()
	state.pipelinesRunning++
	state.Unlock()
	defer func() {
		state.Lock()
		state.pipelinesRunning--
		// TODO: this check shouldn't be necessary; remove and test
		if state.pipelinesRunning >= 0 {
			state.Done()
		}
		state.Unlock()
	}()

	initChannel := w.Channel
	// A job or plugin is always the first task in a pipeline; a new
	// sub-pipeline is created if a job is added in another pipeline.
	if len(task.NameSpace) > 0 {
		if ns, ok := w.tasks.nameSpaces[task.NameSpace]; ok {
			c.nameSpaceParameters = ns.Parameters
		} else {
			Log(robot.Error, "NameSpace '%s' not found for task '%s' (this should never happen)", task.NameSpace, task.name)
		}
	}
	if len(task.ParameterSets) > 0 {
		c.parameterSets = task.ParameterSets
	}
	if isJob {
		// Job parameters are available to the whole pipeline, plugin
		// parameters are not.
		for _, p := range task.Parameters {
			_, exists := c.environment[p.Name]
			if !exists {
				c.environment[p.Name] = p.Value
			}
		}
		// TODO / NOTE: RawMsg will differ between plugins and triggers - document?
		// histories use the job name for maximum separation
		c.jobName = task.name
		// Only a Job pipeline sets a nameSpace that simple tasks in the
		// pipeline can inherit.
		c.nameSpace = w.getNameSpace(t)
		c.environment["GOPHER_JOB_NAME"] = c.jobName
		c.environment["GOPHER_START_CHANNEL"] = w.Channel
		c.environment["GOPHER_START_CHANNEL_ID"] = w.ProtocolChannel
		c.environment["GOPHER_START_THREAD_ID"] = w.Incoming.ThreadID
		c.environment["GOPHER_START_MESSAGE_ID"] = w.Incoming.MessageID
		if w.Incoming.ThreadedMessage {
			c.environment["GOPHER_START_THREADED_MESSAGE"] = "true"
		}
		// To change the channel to the job channel, we need to clear the ProcotolChannel
		w.Channel = task.Channel
		w.ProtocolChannel = ""
		w.Incoming.ThreadID = ""
		w.Incoming.MessageID = ""
		w.Incoming.ThreadedMessage = false
	}
	c.environment["GOPHER_PIPE_NAME"] = task.name
	// Once Active, we need to use the Mutex for access to some fields; see
	// pipeContext/type pipeContext
	w.registerActive(parent)
	rememberRuns := 0
	if isJob {
		rememberRuns = job.KeepLogs
	}
	w.Lock()
	pipeHistory, link, ref, idx := newLogger(c.pipeName, w.eid, "", w.id, rememberRuns)
	c.histName = c.pipeName
	c.runIndex = idx
	c.logger = pipeHistory
	var logref string
	if rememberRuns > 0 {
		if len(link) > 0 && len(ref) > 0 {
			c.environment["GOPHER_LOG_LINK"] = link
			c.environment["GOPHER_LOG_REF"] = ref
			logref = fmt.Sprintf(" (log %s; link %s)", ref, link)
		} else if len(link) > 0 {
			// TODO: this case should never happen; verify and remove?
			c.environment["GOPHER_LOG_LINK"] = link
			logref = fmt.Sprintf(" (link %s)", link)
		} else if len(ref) > 0 {
			c.environment["GOPHER_LOG_REF"] = ref
			logref = fmt.Sprintf(" (log %s)", ref)
		}
	}
	w.Unlock()
	if isJob && (!job.Quiet || c.verbose || ptype == jobCommand) {
		r := w.makeRobot()
		taskinfo := task.name
		if len(args) > 0 {
			taskinfo += " " + strings.Join(args, " ")
		}
		schannel := initChannel
		if schannel == "" {
			schannel = "(direct message)"
		}
		switch ptype {
		case jobTrigger:
			r.Say("Starting job '%s', run %d%s - triggered by app '%s' in channel '%s'", taskinfo, c.runIndex, logref, w.User, schannel)
		case jobCommand:
			r.Say("Starting job '%s', run %d%s - requested by user '%s' in channel '%s'", taskinfo, c.runIndex, logref, w.User, schannel)
		case spawnedTask:
			r.Say("Starting job '%s', run %d%s - spawned by pipeline '%s': %s", taskinfo, c.runIndex, logref, ppipeName, ppipeDesc)
		case scheduled:
			r.Say("Starting scheduled job '%s', run %d%s", taskinfo, c.runIndex, logref)
		case initJob:
			r.Say("Starting init job '%s', run %d%s", taskinfo, c.runIndex, logref)
		default:
			r.Say("Starting job '%s', run %d%s", taskinfo, c.runIndex, logref)
		}
		c.verbose = true
	}

	ts := TaskSpec{task.name, command, args, t}
	c.nextTasks = []TaskSpec{ts}

	var errString string
	ret, errString = w.runPipeline(primaryTasks, ptype, true)
	c.environment["GOPHER_FINAL_TASK"] = c.taskName
	finalTask := c.taskName
	c.environment["GOPHER_FINAL_TYPE"] = c.taskType
	finalType := c.taskType
	if c.taskType == "plugin" {
		c.environment["GOPHER_FINAL_COMMAND"] = c.plugCommand
	}
	c.environment["GOPHER_FINAL_ARGS"] = strings.Join(c.taskArgs, " ")
	c.environment["GOPHER_FINAL_DESC"] = c.taskDesc
	finalDesc := c.taskDesc
	numFailTasks := len(w.failTasks)
	if ret != robot.Normal {
		// Add a default tail-log for simple jobs
		if isJob && !job.Quiet && numFailTasks == 0 {
			tailtask := w.tasks.getTaskByName("tail-log")
			sendtask := w.tasks.getTaskByName("send-message")
			w.failTasks = []TaskSpec{
				{
					Name:      "send-message",
					Command:   "run",
					Arguments: []string{fmt.Sprintf("pipeline failed in task %s with exit code %d (%s); log excerpt:", c.taskName, ret, ret)},
					task:      sendtask,
				},
				{
					Name:    "tail-log",
					Command: "run",
					task:    tailtask,
				},
			}
			numFailTasks = 2
		}
		c.section("failed", fmt.Sprintf("pipeline failed in task %s with exit code %d (%s)", c.taskName, ret, ret))
		fc := int64(ret)
		c.environment["GOPHER_FAIL_CODE"] = strconv.FormatInt(fc, 10)
		c.environment["GOPHER_FAIL_STRING"] = ret.String()
	} else {
		c.section("done", "primary pipeline has completed")
	}
	// Close the log so final / fail tasks could potentially send log emails / links
	c.logger.Close()

	numFinalTasks := len(w.finalTasks)
	if numFinalTasks > 0 {
		w.runPipeline(finalTasks, ptype, false)
	}
	if ret != robot.Normal {
		if numFailTasks > 0 {
			w.runPipeline(failTasks, ptype, false)
		}
	}
	if isPlugin && ret != robot.Normal {
		if !w.automaticTask && errString != "" {
			w.Reply(errString)
		}
		plog, err := interfaces.history.GetLog(w.histName, w.runIndex)
		if err == nil {
			raiseThreadPriv("writing plugin fail log for " + w.pipeName)
			fname := w.pipeName + "-fail.log"
			flog, err := os.Create(fname)
			if err == nil {
				io.Copy(flog, plog)
				flog.Close()
			}
		}
	}
	// Release logs that shouldn't be saved
	c.logger.Finalize()

	if isJob && (!job.Quiet || c.verbose) {
		r := w.makeRobot()
		if ret == robot.Normal {
			r.Say("Finished job '%s', run %d, final task '%s', status: normal", c.pipeName, c.runIndex, finalTask)
		} else {
			var td string
			if len(c.taskDesc) > 0 {
				td = " - " + finalDesc
			}
			jobName := c.pipeName
			if len(c.nsExtension) > 0 {
				jobName += ":" + c.nsExtension
			}
			if ret == robot.PipelineAborted {
				r.Say("Job '%s', run number %d aborted, exclusive job '%s' already in progress", jobName, c.runIndex, c.exclusiveTag)
			} else {
				r.Say("Job '%s', run number %d failed in %s: '%s'%s, exit code: %d (%s)", jobName, c.runIndex, finalType, finalTask, td, int(ret), ret)
			}
		}
	}
	if c.exclusive {
		tag := c.exclusiveTag
		runQueues.Lock()
		queue, _ := runQueues.m[tag]
		queueLen := len(queue)
		if queueLen == 0 {
			Log(robot.Debug, "Bot #%d finished exclusive pipeline '%s', no waiters in queue, removing", w.id, c.exclusiveTag)
			delete(runQueues.m, tag)
		} else {
			Log(robot.Debug, "Bot #%d finished exclusive pipeline '%s', %d waiters in queue, waking next task", w.id, c.exclusiveTag, queueLen)
			wakeUpTask := queue[0]
			queue = queue[1:]
			runQueues.m[tag] = queue
			// Kiss the Princess
			wakeUpTask <- struct{}{}
		}
		runQueues.Unlock()
	}
	w.deregister()
	// Once deregistered, no Robot can get a pointer to the worker, and
	// locking is no longer needed. Invalid calls to getLockedWorker()
	// will log an error and return nil.
	return
}

type pipeStage int

const (
	primaryTasks pipeStage = iota
	finalTasks
	failTasks
)

func (w *worker) runPipeline(stage pipeStage, ptype pipelineType, initialRun bool) (ret robot.TaskRetVal, errString string) {
	var p []TaskSpec
	eventEmitted := false
	w.stage = stage
	switch stage {
	case primaryTasks:
		p = w.nextTasks
		w.nextTasks = []TaskSpec{}
	case finalTasks:
		p = w.finalTasks
	case failTasks:
		p = w.failTasks
	}

	l := len(p)
	for i := 0; i < l; i++ {
		ts := p[i]
		command := ts.Command
		args := ts.Arguments
		t := ts.task
		task, plugin, job := getTask(t)
		isJob := job != nil
		isPlugin := plugin != nil

		// Protect with lock for ps/kill
		w.Lock()
		w.taskName = task.name
		w.taskDesc = task.Description
		w.plugCommand = ""
		w.taskArgs = args
		if isJob {
			w.taskType = "job"
		} else if isPlugin {
			w.taskType = "plugin"
			w.plugCommand = command
		} else {
			w.taskType = "task"
		}
		if task.taskType == taskGo {
			w.taskClass = "Go"
		} else {
			w.taskClass = "Ext"
		}
		w.Unlock()

		// Security checks for jobs & plugins
		if (isJob || isPlugin) && !w.automaticTask {
			r := w.makeRobot()
			r.currentTask = t
			task, plugin, _ := getTask(t)
			adminRequired := task.RequireAdmin
			if !adminRequired && (plugin != nil && len(plugin.AdminCommands) > 0) {
				for _, i := range plugin.AdminCommands {
					if command == i {
						adminRequired = true
						break
					}
				}
			}
			w.registerWorker(r.tid)
			if adminRequired {
				if !r.CheckAdmin() {
					r.Say("Sorry, '%s/%s' is only available to bot administrators", task.name, command)
					ret = robot.Fail
					deregisterWorker(r.tid)
					break
				}
			}
			if isPlugin && r.Incoming.HiddenMessage {
				if r.checkHiddenCommands(w, t, command) != robot.Success {
					r.Reply("Sorry, '%s/%s' cannot be run as a hidden command - use the robot's name or alias", task.name, command)
					ret = robot.Fail
					deregisterWorker(r.tid)
					break
				}
			}
			if r.checkAuthorization(w, t, command, args...) != robot.Success {
				ret = robot.Fail
				deregisterWorker(r.tid)
				break
			}
			if !w.elevated {
				eret, _ := r.checkElevation(t, command)
				if eret != robot.Success {
					ret = robot.Fail
					deregisterWorker(r.tid)
					break
				}
			}
			deregisterWorker(r.tid)
		}

		if initialRun && !eventEmitted {
			eventEmitted = true
			switch ptype {
			case plugCommand:
				if command != "init" {
					emit(CommandTaskRan)
				}
			case plugMessage:
				emit(AmbientTaskRan)
			case catchAll:
				emit(CatchAllTaskRan)
			case jobTrigger:
				emit(TriggeredTaskRan)
			case spawnedTask:
				emit(SpawnedTaskRan)
			case scheduled, initJob:
				emit(ScheduledTaskRan)
			case jobCommand:
				emit(JobTaskRan)
			}
		}
		if isJob && i != 0 {
			child := w.clone()
			ret = child.startPipeline(w, t, ptype, command, args...)
		} else {
			errString, ret = w.callTask(t, command, args...)
		}
		if w.stage == finalTasks && ret != robot.Normal {
			w.finalFailed = append(w.finalFailed, task.name)
		}
		// All tasks in final and fail pipelines always run
		if w.stage != finalTasks && w.stage != failTasks && ret != robot.Normal {
			// task / job in pipeline failed
			break
		}
		if !w.exclusive {
			if w.abortPipeline {
				ret = robot.PipelineAborted
				if !isPlugin { // Plugins should catch and emit this
					errString = "Pipeline aborted, exclusive lock failed"
				}
				break
			}
			if w.queueTask {
				w.queueTask = false
				w.exclusive = true
				tag := w.exclusiveTag
				runQueues.Lock()
				queue, exists := runQueues.m[tag]
				if exists {
					wakeUp := make(chan struct{})
					queue = append(queue, wakeUp)
					runQueues.m[tag] = queue
					runQueues.Unlock()
					Log(robot.Debug, "Exclusive task in progress, queueing bot #%d and waiting; queue length: %d", w.id, len(queue))
					if (isJob && !job.Quiet) || ptype == jobCommand {
						w.makeRobot().Say("Queueing task '%s' in pipeline '%s'", task.name, w.pipeName)
					}
					// Now we block until kissed by a Handsome Prince
					<-wakeUp
					Log(robot.Debug, "Bot #%d in queue waking up and re-starting task '%s'", w.id, task.name)
					if (job != nil && !job.Quiet) || ptype == jobCommand {
						w.makeRobot().Say("Re-starting queued task '%s' in pipeline '%s'", task.name, w.pipeName)
					}
					// Decrement the index so this task runs again
					i--
					// Clear tasks added in the last run (if any)
					w.nextTasks = []TaskSpec{}
				} else {
					Log(robot.Debug, "Exclusive lock acquired in pipeline '%s', bot #%d", w.pipeName, w.id)
					runQueues.m[tag] = []chan struct{}{}
					runQueues.Unlock()
				}
			}
		}
		if w.stage == primaryTasks {
			t := len(w.nextTasks)
			if t > 0 {
				// If this is the last task in the pipeline, and more tasks
				// have been added, just append to the current pipeline.
				if i == l-1 {
					p = append(p, w.nextTasks...)
					l += t
				} else {
					// If more tasks are added in the middle of a pipeline,
					// run all those tasks before continuing with the current
					// tasks.
					ret, errString = w.runPipeline(stage, ptype, false)
				}
				w.nextTasks = []TaskSpec{}
				// the case where c.queueTask is true is handled right after
				// callTask
				if w.abortPipeline {
					ret = robot.PipelineAborted
					if !isPlugin { // Plugins should catch and emit this
						errString = "Pipeline aborted, exclusive lock failed"
					}
					break
				}
				if ret != robot.Normal {
					break
				}
			}
		}
	}
	return
}

// getEnvironment generates the environment for each task run.
// See callTask for the definition of pipeInit.
func (w *worker) getEnvironment(t interface{}) map[string]string {
	task, plugin, _ := getTask(t)
	isPlugin := plugin != nil
	c := w.pipeContext
	envhash := make(map[string]string)
	// Start with the pipeline environment; values configured for the job,
	// or set with SetParameter(name, value). Unprivileged plugins don't
	// get pipe env.
	pipeEnv := true
	if isPlugin && !task.Privileged {
		pipeEnv = false
	}
	if pipeEnv && len(c.environment) > 0 {
		for k, v := range c.environment {
			envhash[k] = v
		}
	}
	// These values are always fixed
	if len(homePath) > 0 {
		envhash["HOME"] = homePath
		envhash["GOPHER_HOME"] = homePath
	}
	envhash["GOPHER_CONFIGDIR"] = configFull
	envhash["GOPHER_CHANNEL"] = w.Channel
	envhash["GOPHER_CHANNEL_ID"] = w.ProtocolChannel
	envhash["GOPHER_MESSAGE_ID"] = w.Incoming.MessageID
	envhash["GOPHER_THREAD_ID"] = w.Incoming.ThreadID
	// Env vars are for scripting languages; unset vars are seen as false
	if w.Incoming.ThreadedMessage {
		envhash["GOPHER_THREADED_MESSAGE"] = "true"
	}
	if w.Incoming.HiddenMessage {
		envhash["GOPHER_HIDDEN_COMMAND"] = "true"
	}
	envhash["GOPHER_CMDMODE"] = w.cmdMode
	envhash["GOPHER_USER"] = w.User
	envhash["GOPHER_USER_ID"] = w.ProtocolUser
	envhash["GOPHER_PROTOCOL"] = strings.ToLower(w.Protocol.String())
	envhash["GOPHER_TASK_NAME"] = c.taskName
	envhash["GOPHER_PIPELINE_TYPE"] = c.ptype.String()
	envhash["GOPHER_CALLER_ID"] = w.eid
	envhash["GOPHER_HTTP_POST"] = "http://" + listenPort
	envhash["GOPHER_INSTALLDIR"] = installPath
	libPath := fmt.Sprintf("%s/lib:%s/lib", installPath, configFull)
	envhash["RUBYLIB"] = libPath
	envhash["GEM_HOME"] = fmt.Sprintf("%s/.local", homePath)
	envhash["PYTHONPATH"] = libPath
	envhash["GOPHER_ENVIRONMENT"] = os.Getenv("GOPHER_ENVIRONMENT")
	envhash["GOPHER_BRAIN"] = w.cfg.brainProvider

	/*
		NameSpace and ParameterSet parameters inherited from the pipeline.
		Highest priority, allowing jobs to set secret sets for the pipeline.
		Note that only privileged tasks/plugins can inherit secrets from
		the pipeline.
	*/
	// NOTE: Even if the job/plugin that started the pipeline isn't privileged,
	// it will still see the namespace and paramtersets parameters, since they're
	// directly attached to the task.
	if task.Privileged {
		// Next lowest prio are inherited namespace params; task parameters can override
		// parameters from the namespace.
		if len(c.nameSpaceParameters) > 0 {
			for _, p := range c.nameSpaceParameters {
				_, exists := envhash[p.Name]
				if !exists {
					envhash[p.Name] = p.Value
				}
			}
		}
		// Inherited ParameterSets can be overridden by inherited NameSpace parameters.
		if len(c.parameterSets) > 0 {
			for _, set := range c.parameterSets {
				if ps, ok := w.tasks.parameterSets[set]; ok {
					for _, p := range ps.Parameters {
						_, exists := envhash[p.Name]
						if !exists {
							envhash[p.Name] = p.Value
						}
					}
				}
			}
		}
	}
	/* end of pipeline inherited parameters */

	/*
		NameSpace and ParameterSets attached to the task.
		Second highest priority; effectively default parameter sets if not
		supplied by the pipeline.
	*/
	if len(task.NameSpace) > 0 {
		if ns, ok := w.tasks.nameSpaces[task.NameSpace]; ok {
			for _, p := range ns.Parameters {
				_, exists := envhash[p.Name]
				if !exists {
					envhash[p.Name] = p.Value
				}
			}
		}
	}
	// ParameterSets can be overridden by NameSpace parameters.
	if len(task.ParameterSets) > 0 {
		for _, set := range task.ParameterSets {
			if ps, ok := w.tasks.parameterSets[set]; ok {
				for _, p := range ps.Parameters {
					_, exists := envhash[p.Name]
					if !exists {
						envhash[p.Name] = p.Value
					}
				}
			}
		}
	}

	/*
		Parameters attached directly to the task.
		Lowest priority, failsafe fallbacks.
	*/

	// Configured parameters for a pipeline task don't apply if already set;
	// task parameters are effectively default values if not otherwise
	// provided by the pipeline or attached parameter sets.
	for _, p := range task.Parameters {
		_, exists := envhash[p.Name]
		if !exists {
			envhash[p.Name] = p.Value
		}
	}

	// Passed-through environment vars have the lowest priority
	for _, p := range envPassThrough {
		_, exists := envhash[p]
		if !exists {
			if value, ok := os.LookupEnv(p); ok {
				envhash[p] = value
			}
		}
	}
	return envhash
}

// getTaskPath searches configPath and installPath and returns the full path
// to the task.
func getTaskPath(task *Task, workDir string) (tpath string, err error) {
	if len(task.Path) == 0 {
		err := fmt.Errorf("path empty for external task: %s", task.name)
		Log(robot.Error, err.Error())
		return "", err
	}
	var info fs.FileInfo
	tpath, info, err = getObjectPath(task.Path)
	if err != nil {
		err = fmt.Errorf("couldn't locate external plugin %s: %v", task.name, err)
		Log(robot.Error, err.Error())
	}
	if !filepath.IsAbs(tpath) {
		tpath, err = filepath.Rel(workDir, tpath)
		if err != nil {
			return "", err
		}
	}
	if info.Mode()&0100 == 0 {
		return "", fmt.Errorf("not executable: %s", tpath)
	}
	return
}
</file_content file: gopherbot-main/bot/run_pipelines.go>
<preamble file: gopherbot-main/bot/scheduled_jobs.go>

</preamble>
<file_content file: gopherbot-main/bot/scheduled_jobs.go>
package bot

import (
	"sync"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/robfig/cron"
)

var taskRunner *cron.Cron
var schedMutex sync.Mutex

var pausedJobs = struct {
	jobs map[string]string
	sync.Mutex
}{
	make(map[string]string),
	sync.Mutex{},
}

func scheduleTasks() {
	schedMutex.Lock()
	if taskRunner != nil {
		taskRunner.Stop()
	}
	currentCfg.RLock()
	scheduled := currentCfg.ScheduledJobs
	tz := currentCfg.timeZone
	currentCfg.RUnlock()
	if tz != nil {
		Log(robot.Info, "Scheduling tasks in TimeZone: %s", tz)
		taskRunner = cron.NewWithLocation(tz)
	} else {
		Log(robot.Info, "Scheduling tasks in system default timezone")
		taskRunner = cron.New()
	}
	currentCfg.RLock()
	cfg := currentCfg.configuration
	tasks := currentCfg.taskList
	currentCfg.RUnlock()
	confLock.RLock()
	repolist := repositories
	confLock.RUnlock()
	for _, st := range scheduled {
		t := tasks.getTaskByName(st.Name)
		if t == nil {
			Log(robot.Error, "Task not found when scheduling task: %s", st.Name)
			continue
		}
		task, _, job := getTask(t)
		if job == nil {
			Log(robot.Error, "Ignoring '%s' in ScheduledJobs: not a job", st.Name)
			continue
		}
		if task.Disabled {
			Log(robot.Error, "Not scheduling disabled job '%s'; reason: %s", st.Name, task.reason)
			continue
		}
		if len(task.Channel) == 0 {
			Log(robot.Error, "Not scheduling job '%s'; zero-length Channel", st.Name)
			continue
		}
		ts := st.TaskSpec
		if st.Schedule != "@init" {
			Log(robot.Info, "Scheduling job '%s', args '%v' with schedule: %s", ts.Name, ts.Arguments, st.Schedule)
			taskRunner.AddFunc(st.Schedule, func() { runScheduledTask(t, ts, cfg, tasks, repolist, false) })
		}
	}
	taskRunner.Start()
	schedMutex.Unlock()
}

// initJobs - run init jobs that might be required by external plugins
func initJobs() {
	currentCfg.RLock()
	scheduled := currentCfg.ScheduledJobs
	cfg := currentCfg.configuration
	tasks := currentCfg.taskList
	currentCfg.RUnlock()
	confLock.RLock()
	repolist := repositories
	confLock.RUnlock()
	for _, st := range scheduled {
		ts := st.TaskSpec
		if st.Schedule == "@init" {
			t := tasks.getTaskByName(st.Name)
			if t == nil {
				Log(robot.Error, "Task not found when running init job: %s", st.Name)
				continue
			}
			task, _, job := getTask(t)
			if job == nil {
				Log(robot.Error, "Ignoring '%s' while running init jobs: not a job", st.Name)
				continue
			}
			if task.Disabled {
				Log(robot.Error, "Ignoring disabled job '%s' while running init jobs; reason: %s", st.Name, task.reason)
				continue
			}
			runScheduledTask(t, ts, cfg, tasks, repolist, true)
		}
	}
}

func runScheduledTask(t interface{}, ts TaskSpec, cfg *configuration, tasks *taskList, repolist map[string]robot.Repository, isInitJob bool) {
	task, _, _ := getTask(t)
	currentCfg.RLock()
	protocol := currentCfg.protocol
	currentCfg.RUnlock()
	pausedJobs.Lock()
	if user, ok := pausedJobs.jobs[task.name]; ok {
		Log(robot.Debug, "Skipping run of job '%s' paused by user '%s'", task.name, user)
		pausedJobs.Unlock()
		return
	}
	pausedJobs.Unlock()

	// Create the pipeContext to carry state through the pipeline.
	// startPipeline will take care of registerActive()
	w := &worker{
		Channel:       task.Channel,
		Protocol:      getProtocol(protocol),
		Incoming:      &robot.ConnectorMessage{},
		cfg:           cfg,
		id:            getWorkerID(),
		tasks:         tasks,
		repositories:  repolist,
		automaticTask: true, // scheduled jobs don't get authorization / elevation checks
	}
	if isInitJob {
		Log(robot.Debug, "Starting init job: %s", task.name)
	} else {
		Log(robot.Debug, "Starting scheduled job: %s", task.name)
	}
	jobtype := scheduled
	if isInitJob {
		jobtype = initJob
	}
	w.startPipeline(nil, t, jobtype, "run", ts.Arguments...)
}
</file_content file: gopherbot-main/bot/scheduled_jobs.go>
<preamble file: gopherbot-main/bot/send_message.go>

</preamble>
<file_content file: gopherbot-main/bot/send_message.go>
package bot

import (
	"fmt"

	"github.com/lnxjedi/gopherbot/robot"
)

/* send_message.go - all the message sending methods for a worker or a Robot.
The worker methods are used by the worker during message processing, before
any calls to makeRobot(). The main difference between the worker and Robot
versions is that the Robot version uses it's local copy of the robot.Message,
which may have been modified by e.g. r.Direct(), r.Fixed(), etc.
*/

// messageHeard sends a typing notification
func (r Robot) messageHeard() {
	user := r.ProtocolUser
	if len(user) == 0 {
		user = r.User
	}
	channel := r.ProtocolChannel
	if len(channel) == 0 {
		channel = r.Channel
	}
	interfaces.MessageHeard(user, channel)
}

func (w *worker) messageHeard() {
	user := w.ProtocolUser
	if len(user) == 0 {
		user = w.User
	}
	channel := w.ProtocolChannel
	if len(channel) == 0 {
		channel = w.Channel
	}
	interfaces.MessageHeard(user, channel)
}

// SendChannelMessage lets a plugin easily send a message to an arbitrary
// channel. Use Robot.Fixed().SendChannelMessage(...) for fixed-width
// font.
func (r Robot) SendChannelMessage(ch, msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in SendChannelMessage")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var channel string
	if ci, ok := r.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, "", msg, r.Format, r.Incoming)
}

func (w *worker) SendChannelMessage(ch, msg string, v ...interface{}) robot.RetVal {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var channel string
	if ci, ok := w.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, "", msg, w.Format, w.Incoming)
}

func (r Robot) SendChannelThreadMessage(ch, thr, msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in SendChannelMessage")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var channel string
	if ci, ok := r.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, thr, msg, r.Format, r.Incoming)
}

func (w *worker) SendChannelThreadMessage(ch, thr, msg string, v ...interface{}) robot.RetVal {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var channel string
	if ci, ok := w.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, thr, msg, w.Format, w.Incoming)
}

// SendUserChannelMessage lets a plugin easily send a message directed to
// a specific user in a specific channel without fiddling with the robot
// object. Note that this will fail with UserNotFound if the connector
// can't resolve usernames, or the username isn't mapped to a user ID in
// the UserRoster.
func (r Robot) SendUserChannelMessage(u, ch, msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in SendUserChannelMessage")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var user string
	if ui, ok := r.maps.user[u]; ok {
		user = bracket(ui.UserID)
	} else {
		user = u
	}
	var channel string
	if ci, ok := r.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, u, channel, "", msg, r.Format, r.Incoming)
}

func (w *worker) SendUserChannelMessage(u, ch, msg string, v ...interface{}) robot.RetVal {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var user string
	if ui, ok := w.maps.user[u]; ok {
		user = bracket(ui.UserID)
	} else {
		user = u
	}
	var channel string
	if ci, ok := w.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, u, channel, "", msg, w.Format, w.Incoming)
}

func (r Robot) SendUserChannelThreadMessage(u, ch, thr, msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in SendUserChannelMessage")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var user string
	if ui, ok := r.maps.user[u]; ok {
		user = bracket(ui.UserID)
	} else {
		user = u
	}
	var channel string
	if ci, ok := r.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, u, channel, thr, msg, r.Format, r.Incoming)
}

func (w *worker) SendUserChannelThreadMessage(u, ch, thr, msg string, v ...interface{}) robot.RetVal {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var user string
	if ui, ok := w.maps.user[u]; ok {
		user = bracket(ui.UserID)
	} else {
		user = u
	}
	var channel string
	if ci, ok := w.maps.channel[ch]; ok {
		channel = bracket(ci.ChannelID)
	} else {
		channel = ch
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, u, channel, thr, msg, w.Format, w.Incoming)
}

// SendUserMessage lets a plugin easily send a DM to a user. If a DM
// fails, an error should be returned, since DMs may be used for sending
// secret/sensitive information.
func (r Robot) SendUserMessage(u, msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in SendUserMessage")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var user string
	if ui, ok := r.maps.user[u]; ok {
		user = bracket(ui.UserID)
	} else {
		user = u
	}
	return interfaces.SendProtocolUserMessage(user, msg, r.Format, r.Incoming)
}

func (w *worker) SendUserMessage(u, msg string, v ...interface{}) robot.RetVal {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	var user string
	if ui, ok := w.maps.user[u]; ok {
		user = bracket(ui.UserID)
	} else {
		user = u
	}
	return interfaces.SendProtocolUserMessage(user, msg, w.Format, w.Incoming)
}

// Reply directs a message to the user
func (r Robot) Reply(msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in Reply")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	user := r.ProtocolUser
	if len(user) == 0 {
		user = r.User
	}
	// Support for Direct()
	if r.Channel == "" {
		return interfaces.SendProtocolUserMessage(user, msg, r.Format, r.Incoming)
	}
	channel := r.ProtocolChannel
	if len(channel) == 0 {
		channel = r.Channel
	}
	var thread string
	if r.Incoming.ThreadedMessage {
		thread = r.Incoming.ThreadID
	}
	w := getLockedWorker(r.tid)
	w.Unlock()
	if w.BotUser {
		return interfaces.SendProtocolChannelThreadMessage(r.Channel, thread, r.User+": "+msg, r.Format, r.Incoming)
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, r.User, r.Channel, thread, msg, r.Format, r.Incoming)
}

func (w *worker) Reply(msg string, v ...interface{}) robot.RetVal {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	user := w.ProtocolUser
	if len(user) == 0 {
		user = w.User
	}
	// Support for Direct()
	if w.Channel == "" {
		return interfaces.SendProtocolUserMessage(user, msg, w.Format, w.Incoming)
	}
	channel := w.ProtocolChannel
	if len(channel) == 0 {
		channel = w.Channel
	}
	var thread string
	if w.Incoming.ThreadedMessage {
		thread = w.Incoming.ThreadID
	}
	if w.BotUser {
		return interfaces.SendProtocolChannelThreadMessage(w.Channel, thread, w.User+": "+msg, w.Format, w.Incoming)
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, w.User, w.Channel, thread, msg, w.Format, w.Incoming)
}

// ReplyThread directs a message to the user, creating a new thread
func (r Robot) ReplyThread(msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in Reply")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	user := r.ProtocolUser
	if len(user) == 0 {
		user = r.User
	}
	// Support for Direct()
	if r.Channel == "" {
		return interfaces.SendProtocolUserMessage(user, msg, r.Format, r.Incoming)
	}
	channel := r.ProtocolChannel
	if len(channel) == 0 {
		channel = r.Channel
	}
	w := getLockedWorker(r.tid)
	w.Unlock()
	if w.BotUser {
		return interfaces.SendProtocolChannelThreadMessage(r.Channel, r.Incoming.ThreadID, r.User+": "+msg, r.Format, r.Incoming)
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, r.User, r.Channel, r.Incoming.ThreadID, msg, r.Format, r.Incoming)
}

func (w *worker) ReplyThread(msg string, v ...interface{}) robot.RetVal {
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	user := w.ProtocolUser
	if len(user) == 0 {
		user = w.User
	}
	// Support for Direct()
	if w.Channel == "" {
		return interfaces.SendProtocolUserMessage(user, msg, w.Format, w.Incoming)
	}
	channel := w.ProtocolChannel
	if len(channel) == 0 {
		channel = w.Channel
	}
	if w.BotUser {
		return interfaces.SendProtocolChannelThreadMessage(w.Channel, w.Incoming.ThreadID, w.User+": "+msg, w.Format, w.Incoming)
	}
	return interfaces.SendProtocolUserChannelThreadMessage(user, w.User, w.Channel, w.Incoming.ThreadID, msg, w.Format, w.Incoming)
}

// Say just sends a message to the user or channel
func (r Robot) Say(msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in Say")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	// Support for Direct()
	if r.Channel == "" {
		user := r.ProtocolUser
		if len(user) == 0 {
			user = r.User
		}
		return interfaces.SendProtocolUserMessage(user, msg, r.Format, r.Incoming)
	}
	channel := r.ProtocolChannel
	if len(channel) == 0 {
		channel = r.Channel
	}
	var thread string
	if r.Incoming.ThreadedMessage {
		thread = r.Incoming.ThreadID
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, thread, msg, r.Format, r.Incoming)
}

func (w *worker) Say(msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		Log(robot.Warn, "Ignoring zero-length message in Say")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	// Support for Direct()
	if w.Channel == "" {
		user := w.ProtocolUser
		if len(user) == 0 {
			user = w.User
		}
		return interfaces.SendProtocolUserMessage(user, msg, w.Format, w.Incoming)
	}
	channel := w.ProtocolChannel
	if len(channel) == 0 {
		channel = w.Channel
	}
	var thread string
	if w.Incoming.ThreadedMessage {
		thread = w.Incoming.ThreadID
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, thread, msg, w.Format, w.Incoming)
}

// SayThread creates a new thread if replying to an existing message
func (r Robot) SayThread(msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		r.Log(robot.Warn, "Ignoring zero-length message in SayThread")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	// Support for Direct()
	if r.Channel == "" {
		user := r.ProtocolUser
		if len(user) == 0 {
			user = r.User
		}
		return interfaces.SendProtocolUserMessage(user, msg, r.Format, r.Incoming)
	}
	channel := r.ProtocolChannel
	if len(channel) == 0 {
		channel = r.Channel
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, r.Incoming.ThreadID, msg, r.Format, r.Incoming)
}

func (w *worker) SayThread(msg string, v ...interface{}) robot.RetVal {
	if len(msg) == 0 {
		Log(robot.Warn, "Ignoring zero-length message in SayThread")
		return robot.Ok
	}
	if len(v) > 0 {
		msg = fmt.Sprintf(msg, v...)
	}
	// Support for Direct()
	if w.Channel == "" {
		user := w.ProtocolUser
		if len(user) == 0 {
			user = w.User
		}
		return interfaces.SendProtocolUserMessage(user, msg, w.Format, w.Incoming)
	}
	channel := w.ProtocolChannel
	if len(channel) == 0 {
		channel = w.Channel
	}
	return interfaces.SendProtocolChannelThreadMessage(channel, w.Incoming.ThreadID, msg, w.Format, w.Incoming)
}
</file_content file: gopherbot-main/bot/send_message.go>
<preamble file: gopherbot-main/bot/signal.go>

</preamble>
<file_content file: gopherbot-main/bot/signal.go>
//go:build !test
// +build !test

package bot

import (
	"log"
	"os"
	"os/signal"
	"runtime"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
	"golang.org/x/sys/unix"
)

func sigHandle(sigBreak chan struct{}) {
	sigs := make(chan os.Signal, 1)

	signal.Notify(sigs, unix.SIGINT, unix.SIGTERM, unix.SIGUSR1, unix.SIGUSR2)

loop:
	for {
		select {
		case sig := <-sigs:
			switch sig {
			case unix.SIGINT, unix.SIGTERM:
				state.Lock()
				if state.shuttingDown {
					Log(robot.Warn, "Received SIGINT/SIGTERM while shutdown in progress")
					state.Unlock()
				} else {
					state.shuttingDown = true
					state.Unlock()
					signal.Stop(sigs)
					Log(robot.Info, "Exiting on signal: %s", sig)
					stop()
				}
			case unix.SIGUSR1:
				buf := make([]byte, 32768)
				runtime.Stack(buf, true)
				log.Printf("%s", buf)
				time.Sleep(2 * time.Second)
				panic("SIGUSR1 received")
			case unix.SIGUSR2:
				Log(robot.Info, "Restarting logfile")
				logRotate("")
				Log(robot.Info, "Log rotated")
			}
		// done declared globally at top of this file
		case <-sigBreak:
			Log(robot.Info, "Stopping signal handler")
			break loop
		}
	}
}

// sigHandler for pid 1
func initSigHandle(c *os.Process) {
	Log(robot.Info, "Starting pid 1 signal handler")
	sigs := make(chan os.Signal, 1)

	signal.Notify(sigs, unix.SIGINT, unix.SIGTERM)

	for {
		select {
		case sig := <-sigs:
			signal.Stop(sigs)
			Log(robot.Info, "Caught signal '%s', propagating to child pid %d", sig, c.Pid)
			c.Signal(sig)
		}
	}
}
</file_content file: gopherbot-main/bot/signal.go>
<preamble file: gopherbot-main/bot/signal_testing.go>

</preamble>
<file_content file: gopherbot-main/bot/signal_testing.go>
//go:build test
// +build test

package bot

import (
	"os"
	"os/signal"
	"runtime"

	"github.com/lnxjedi/gopherbot/robot"
	"golang.org/x/sys/unix"
)

func sigHandle(sigBreak chan struct{}) {
	sigs := make(chan os.Signal, 1)

	signal.Notify(sigs, unix.SIGINT, unix.SIGTERM)

loop:
	for {
		select {
		case sig := <-sigs:
			buf := make([]byte, 65536)
			ss := runtime.Stack(buf, true)
			os.Stdout.Write(buf[0:ss])
			os.Stdout.Write([]byte("\n"))
			panic("Tests terminated by signal: " + sig.String())

		// done declared globally at top of this file
		case <-sigBreak:
			Log(robot.Info, "Stopping signal handler")
			break loop
		}
	}
}

// sigHandler for pid 1
func initSigHandle(c *os.Process) {
}
</file_content file: gopherbot-main/bot/signal_testing.go>
<preamble file: gopherbot-main/bot/start.go>

</preamble>
<file_content file: gopherbot-main/bot/start.go>
package bot

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/joho/godotenv"
	"github.com/lnxjedi/gopherbot/robot"
	"golang.org/x/sys/unix"
)

// Information about privilege separation, set in runtasks_linux.go
var privSep = false

// Set for CLI commands
var cliOp = false
var fileLog = false

func init() {
	hostName = os.Getenv("HOSTNAME")
}

// Start gets the robot going
func Start(v VersionInfo) {
	botVersion = v

	var configpath string

	// Save args in case we need to spawn child
	args := os.Args[1:]
	// Process command-line flags
	var explicitCfgPath string
	cusage := "path to the configuration directory"
	flag.StringVar(&explicitCfgPath, "config", "", cusage)
	flag.StringVar(&explicitCfgPath, "c", "", "")
	var daemonize bool
	var dusage = "daemonize on startup"
	flag.BoolVar(&daemonize, "daemonize", false, dusage)
	flag.BoolVar(&daemonize, "d", false, "")
	var logFile string
	lusage := "path to robot's log file (or 'stderr')"
	flag.StringVar(&logFile, "log", "", lusage)
	flag.StringVar(&logFile, "l", "", "")
	var overrideIDEMode bool
	ovusage := "Override GOPHER_IDE mode"
	flag.BoolVar(&overrideIDEMode, "override", false, ovusage)
	flag.BoolVar(&overrideIDEMode, "o", false, "")
	var plainlog bool
	plusage := "omit timestamps from the log"
	flag.BoolVar(&plainlog, "plainlog", false, plusage)
	flag.BoolVar(&plainlog, "p", false, "")
	var terminalmode bool
	tmusage := "set 'GOPHER_PROTOCOL=terminal' and default logging to 'robot.log'"
	flag.BoolVar(&terminalmode, "terminal", false, tmusage)
	flag.BoolVar(&terminalmode, "t", false, "")
	var help bool
	husage := "help for gopherbot"
	flag.BoolVar(&help, "help", false, husage)
	flag.BoolVar(&help, "h", false, "")
	// TODO: Gopherbot CLI commands suck. Make them suck less.
	flag.Parse()

	_, ideMode := os.LookupEnv("GOPHER_IDE")
	if ideMode {
		// To prevent inadvertently bootstrapping a production
		// robot in a random directory, we force it to run in $HOME.
		// This behavior can only be overridden by unsetting
		// GOPHER_IDE in the terminal before invoking gopherbot.
		// (`unset GOPHER_IDE; gopherbot`)
		homeDir := os.Getenv("HOME")
		os.Chdir(homeDir)
		if overrideIDEMode {
			ideMode = false
		} else {
			// Guardrail when running the gopherbot IDE from cbot.sh, which sets
			// GOPHER_IDE=true.  with
			// the terminal connector and memory brain, unless the user specifically
			// overrides this behavior.
			_, profileConfigured := os.LookupEnv("GOPHER_CUSTOM_REPOSITORY")
			termEnv := os.Getenv("GOPHER_PROTOCOL") == "terminal"
			if profileConfigured && !termEnv {
				os.Setenv("GOPHER_PROTOCOL", "terminal")
				os.Setenv("GOPHER_BRAIN", "mem")
			} else {
				ideMode = false
			}
		}
	}

	logFlags := log.LstdFlags
	if plainlog {
		logFlags = 0
	}
	botStdErrLogger = log.New(os.Stderr, "", logFlags)
	botStdOutLogger = log.New(os.Stdout, "", logFlags)
	// Container support
	pid := os.Getpid()
	if pid == 1 {
		Log(robot.Info, "PID == 1, spawning child")
		bin, _ := os.Executable()
		os.Setenv("GOPHER_CONTAINER", "iscontainer")
		env := os.Environ()
		cmd := exec.Command(bin, args...)
		cmd.Env = env
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		raiseThreadPrivExternal("exec child process")
		err := cmd.Start()
		if err != nil {
			log.Fatal(err)
		}
		go initSigHandle(cmd.Process)
		if pid == 1 {
			go func() {
				var ws unix.WaitStatus
				// Reap children FOREVER...
				for {
					pid, err := unix.Wait4(-1, &ws, 0, nil)
					if err == nil {
						Log(robot.Debug, "Reaped child pid: %d, status: %+v", pid, ws)
					}
				}
			}()
		}
		cmd.Wait()
		Log(robot.Info, "Quitting on child exit")
		return
	}

	usage := `Usage: gopherbot [options] [command [command options] [command args]]
  "command" can be one of:
	decrypt - decrypt a string or file
	encrypt - encrypt a string or file
	gentotp - generate a user TOTP string
	delete - delete a memory
	dump (installed|configured) [path/to/file.yaml] -
	  read and dump a raw config file, for yaml troubleshooting
	fetch - fetch the contents of a memory
	init (protocol) - create a new robot in currect directory
	list - list robot memories
	run - run the robot (default)
	store - store a memory
	version - display the gopherbot version
  <command> -h for help on a given command

  Common options:`

	if help {
		fmt.Println(usage)
		flag.PrintDefaults()
		os.Exit(0)
	}

	cliOp = len(flag.Args()) > 0 && flag.Arg(0) != "run"
	var cliCommand string
	if cliOp {
		cliCommand = flag.Arg(0)
	}

	var envFile string
	var fixed = []string{}
	for _, ef := range []string{"private/environment", ".env"} {
		if es, err := os.Stat(ef); err == nil {
			em := es.Mode()
			if (uint32(em) & 0077) != 0 {
				mask := os.FileMode(0700)
				want := em & mask
				if err := os.Chmod(ef, want); err != nil {
					log.Fatalf("Invalid file mode '%o' on environment file '%s', can't fix: %v", em, ef, err)
				}
				fixed = append(fixed, ef)
			}
			envFile = ef
		}
	}
	penvErr := godotenv.Overload(envFile)

	if _, ok := os.LookupEnv("GOPHER_ENVIRONMENT"); !ok {
		os.Setenv("GOPHER_ENVIRONMENT", "production")
	}

	// Configdir is where all user-supplied configuration and
	// external plugins are.
	if len(explicitCfgPath) != 0 {
		configpath = explicitCfgPath
	} else {
		if _, ok := checkDirectory("custom"); ok {
			configpath = "custom"
		} else if _, ok := checkDirectory("conf"); ok {
			configpath = "."
		} else {
			// If not explicitly set or cwd, use "custom" even if it
			// doesn't exist.
			configpath = "custom"
		}
	}

	// support for setup and bootstrap plugins
	var defaultProto, defaultLogfile bool

	termStart := func() {
		defaultProto = true
		os.Setenv("GOPHER_PROTOCOL", "terminal")
		if _, ok := os.LookupEnv("GOPHER_LOGFILE"); !ok {
			os.Setenv("GOPHER_LOGFILE", "robot.log")
			defaultLogfile = true
		}
	}

	protoEnv, protoSet := os.LookupEnv("GOPHER_PROTOCOL")
	testpath := filepath.Join(configpath, "conf", robotConfigFileName)
	_, err := os.Stat(testpath)
	if err != nil {
		testpath = filepath.Join(configpath, "conf", "gopherbot.yaml")
		_, err = os.Stat(testpath)
		if err == nil {
			robotConfigFileName = "gopherbot.yaml"
		}
	}
	unconfigured := false
	if err != nil {
		_, ok := os.LookupEnv("GOPHER_CUSTOM_REPOSITORY")
		if !ok {
			unconfigured = true
			os.Setenv("GOPHER_UNCONFIGURED", "unconfigured")
			// Start a setup plugin; if answerfile.txt is present, or ANS_PROTOCOL is set,
			// use the new-style, otherwise run the terminal connector for the interactive plugin.
			setup := false
			if _, err := os.Stat("answerfile.txt"); err == nil {
				// true for CLI setup
				setup = true
			} else if _, ok := os.LookupEnv("ANS_PROTOCOL"); ok {
				// true for container-based setup
				setup = true
			}
			if setup {
				defaultProto = true
				os.Setenv("GOPHER_PROTOCOL", "nullconn")
				if _, ok := os.LookupEnv("GOPHER_LOGFILE"); !ok {
					os.Setenv("GOPHER_LOGFILE", "robot.log")
					if !cliOp {
						Log(robot.Info, "Logging to robot.log")
					}
					defaultLogfile = true
				}
			} else {
				termStart()
			}
		} else {
			// no robot.yaml, but GOPHER_CUSTOM_REPOSITORY set
			os.Setenv("GOPHER_PROTOCOL", "nullconn")
		}
		defaultProto = true
	} else {
		os.Unsetenv("GOPHER_UNCONFIGURED")
		if !protoSet || terminalmode {
			termStart()
		}
	}

	// Set up Logging
	var logger *log.Logger
	logOut := os.Stdout
	if len(logFile) == 0 {
		logFile = os.Getenv("GOPHER_LOGFILE")
	}
	eproto := os.Getenv("GOPHER_PROTOCOL")
	if len(logFile) == 0 && (cliOp || eproto == "terminal") {
		logFile = "robot.log"
	}
	if len(logFile) != 0 {
		if logFile == "stderr" {
			logOut = os.Stderr
		} else {
			lf, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
			if err != nil {
				log.Fatalf("Error creating log file: (%T %v)", err, err)
			}
			fileLog = true
			logFileName = logFile
			logOut = lf
		}
	}

	logger = log.New(logOut, "", logFlags)
	botLogger.logger = logger
	if unconfigured {
		Log(robot.Warn, "Starting unconfigured; no robot.yaml/gopherbot.yaml found")
	}
	if ideMode {
		Log(robot.Info, "Starting in IDE mode, defaulting GOPHER_BRAIN to 'mem' and GOPHER_PROTOCOL to 'terminal'; override with '-o' flag")
	}

	if daemonize {
		scrubargs := []string{}
		skip := false
		for _, arg := range args {
			if arg == "-d" || arg == "-daemonize" {
				continue
			}
			if arg == "-l" || arg == "-log" {
				skip = true
				continue
			}
			if skip {
				skip = false
				continue
			}
			scrubargs = append(scrubargs, arg)
		}
		bin, _ := os.Executable()
		env := os.Environ()
		if !fileLog {
			Log(robot.Info, "Logging to robot.log")
			env = append(env, "GOPHER_LOGFILE=robot.log")
		} else {
			env = append(env, fmt.Sprintf("GOPHER_LOGFILE=%s", logFile))
		}
		Log(robot.Info, "Forking in to background...")
		cmd := exec.Command(bin, scrubargs...)
		cmd.Env = env
		cmd.Stdin = nil
		cmd.Stdout = nil
		cmd.Stderr = nil
		raiseThreadPrivExternal("fork in to background")
		err := cmd.Start()
		if err != nil {
			log.Fatal(err)
		}
		return
	}

	if !cliOp {
		lle := os.Getenv("GOPHER_LOGLEVEL")
		if len(lle) > 0 {
			loglevel := logStrToLevel(lle)
			setLogLevel(loglevel)
		}
		logger.Println("Initialized logging ...")
	}

	if !cliOp {
		if penvErr != nil {
			logger.Printf("No private environment loaded from '.env': %v\n", penvErr)
		} else {
			logger.Printf("Loaded initial private environment from '%s'\n", envFile)
		}
		if len(fixed) > 0 {
			logger.Printf("Notice! Fixed invalid file modes for environment file(s): %s", strings.Join(fixed, ", "))
		}

		// Create the 'bot and load configuration, supplying configpath and installpath.
		// When loading configuration, gopherbot first loads default configuration
		// from internal config, then loads from configpath/conf/..., which
		// overrides defaults.
		logger.Printf("Starting up with config dir: %s, and install dir: %s\n", configpath, binDirectory)
		checkprivsep(logger)
	}

	if cliCommand == "dump" {
		setLogLevel(robot.Warn)
		if len(flag.Args()) != 3 {
			fmt.Println(usage)
			flag.PrintDefaults()
			os.Exit(1)
		}
		switch flag.Arg(1) {
		case "installed", "configured":
			configPath = configpath
			installPath = binDirectory
			initCrypt()
			cliDump(flag.Arg(1), flag.Arg(2))
		default:
			fmt.Println("DEBUG default")
			fmt.Println(usage)
			flag.PrintDefaults()
			os.Exit(1)
		}
	}

	initBot(configpath, binDirectory)

	if cliOp {
		go runBrain()
		processCLI(usage)
		brainQuit()
		return
	}
	if currentCfg.protocol == "terminal" {
		localTerm = true
		if defaultLogfile {
			botStdOutLogger.Println("Logging to robot.log; warnings and errors duplicated to stdout")
		}
	}
	if currentCfg.protocol == "nullconn" {
		nullConn = true
	}
	initializeConnector, ok := connectors[currentCfg.protocol]
	if !ok {
		logger.Fatalf("No connector registered with name: %s", currentCfg.protocol)
	}

	// handler{} is just a placeholder struct for implementing the Handler interface
	conn := initializeConnector(handle, logger)

	// NOTE: we use setConnector instead of passing the connector to run()
	// because of the way Windows services were run. Maybe remove eventually?
	setConnector(conn)

	// Start the robot loops
	run()
	// ... and wait for the robot to stop
	restart := <-done
	raiseThreadPrivExternal("Exiting")
	time.Sleep(time.Second)
	if restart {
		if defaultProto {
			if protoSet {
				os.Setenv("GOPHER_PROTOCOL", protoEnv)
			} else {
				os.Unsetenv("GOPHER_PROTOCOL")
			}
		}
		if defaultLogfile {
			os.Unsetenv("GOPHER_LOGFILE")
		}
		bin, _ := os.Executable()
		env := os.Environ()
		defer func() {
			err := unix.Exec(bin, os.Args, env)
			if err != nil {
				fmt.Printf("Error re-exec'ing: %v", err)
			}
		}()
	}
}
</file_content file: gopherbot-main/bot/start.go>
<preamble file: gopherbot-main/bot/start_t.go>

</preamble>
<file_content file: gopherbot-main/bot/start_t.go>
package bot

/*
start_t.go - non-interactive StartTest() function for automated "black box"
testing.
*/

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"testing"

	"github.com/lnxjedi/gopherbot/robot"
)

var testInstallPath string

func init() {
	wd, _ := os.Getwd()
	testInstallPath = filepath.Dir(wd)
}

// StartTest will start a robot for testing, and return the exit / robot stopped channel
func StartTest(v VersionInfo, cfgdir, logfile string, t *testing.T) (chan bool, robot.Connector) {
	botVersion = v
	configpath := filepath.Join(testInstallPath, cfgdir)
	t.Logf("Initializing test bot with installpath: '%s', configpath: '%s' and logfile: %s", testInstallPath, configpath, logfile)

	if botLogger.logger == nil {
		var testLogger *log.Logger
		botStdOutLogger = log.New(os.Stdout, "", log.LstdFlags)
		if len(logfile) == 0 {
			testLogger = log.New(io.Discard, "", 0)
		} else {
			lf, err := os.Create(logfile)
			if err != nil {
				log.Fatalf("Error creating log file: (%T %v)", err, err)
			}
			testLogger = log.New(lf, "", log.LstdFlags)
		}
		botLogger.logger = testLogger
	} else {
		lf, err := os.Create(logfile)
		if err != nil {
			log.Fatalf("Error creating log file: (%T %v)", err, err)
		}
		botLogger.setOutputFile(lf)
	}
	initBot(configpath, testInstallPath)

	initializeConnector, ok := connectors[currentCfg.protocol]
	if !ok {
		Log(robot.Fatal, "No connector registered with name: %s", currentCfg.protocol)
	}
	Log(robot.Info, "Starting new test with cfgdir: %s\n", cfgdir)

	// handler{} is just a placeholder struct for implementing the Handler interface
	conn := initializeConnector(handle, botLogger.logger)

	// NOTE: we use setConnector instead of passing the connector to run()
	// because of the way Windows services were run. Maybe remove eventually?
	setConnector(conn)

	run()

	bk := filepath.Join(testInstallPath, cfgdir, "binary-encrypted-key")
	if err := os.Remove(bk); err != nil {
		fmt.Printf("Removing temporary key: %v\n", err)
	}
	return done, conn
}
</file_content file: gopherbot-main/bot/start_t.go>
<preamble file: gopherbot-main/bot/subscribe_thread.go>

</preamble>
<file_content file: gopherbot-main/bot/subscribe_thread.go>
package bot

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

/*
Thread subscriptions allow a plugin to Subscribe() to the current thread,
so that all future messages to the thread which aren't commands will be sent
to the plugin with a command of "subscribed". This is meant to replace message
matchers that match all messages.
*/

/*
NOTE on Marshalling, Unmarshalling and locks:
The Go linter is complaining about copying locks, but in reality we're not using the lock
that's being copied anyway.
*/

const subscriptionMemKey = "bot:_subscriptions"

// Plugins can subscribe to a thread in a channel. This struct is used as the
// key in the subscriptions map.
type subscriptionMatcher struct {
	channel, thread string
}

type subscriber struct {
	Plugin    string    // the plugin subscribed
	Timestamp time.Time // for expiring after subscriptionTimeout
}

type tSubs struct {
	m     map[subscriptionMatcher]subscriber
	dirty bool
	sync.Mutex
}

var subscriptions = tSubs{
	m: make(map[subscriptionMatcher]subscriber),
}

// the lock should be held on entry and released after return
func (s tSubs) MarshalJSON() ([]byte, error) {
	tempMap := make(map[string]subscriber)
	for k, v := range s.m {
		keyString := fmt.Sprintf("%s{|}%s", k.channel, k.thread)
		tempMap[keyString] = v
	}
	return json.Marshal(tempMap)
}

// No locking needed - called before multi-threaded
func (s *tSubs) UnmarshalJSON(data []byte) error {
	var tempMap map[string]subscriber
	err := json.Unmarshal(data, &tempMap)
	if err != nil {
		return err
	}

	Log(robot.Debug, "Unmarshalled data: %v", tempMap)

	s.m = make(map[subscriptionMatcher]subscriber)
	for k, v := range tempMap {
		parts := strings.SplitN(k, "{|}", 2)
		if len(parts) != 2 {
			return fmt.Errorf("invalid key string format: %s", k)
		}
		key := subscriptionMatcher{channel: parts[0], thread: parts[1]}
		s.m[key] = v
	}

	return nil
}

func restoreSubscriptions() {
	var storedSubscriptions tSubs
	ss_tok, ss_exists, ss_ret := checkoutDatum(subscriptionMemKey, &storedSubscriptions, true)
	if ss_ret == robot.Ok {
		if ss_exists {
			if len(storedSubscriptions.m) > 0 {
				Log(robot.Info, "Restored '%d' subscriptions from long-term memory", len(storedSubscriptions.m))
				now := time.Now()
				for _, s := range storedSubscriptions.m {
					s.Timestamp = now
				}
				subscriptions.m = storedSubscriptions.m
			} else {
				Log(robot.Info, "Restoring subscriptions from long-term memory: zero-length map")
				checkinDatum(subscriptionMemKey, ss_tok)
			}
		} else {
			Log(robot.Info, "Restoring suscriptions from long-term memory: memory doesn't exist")
			checkinDatum(subscriptionMemKey, ss_tok)
		}
	} else {
		Log(robot.Error, "Restoring suscriptions from long-term memory: error '%s' getting datum", ss_ret)
	}
}

func saveSubscriptions() {
	var storedSubscriptions tSubs
	ss_tok, _, ss_ret := checkoutDatum(subscriptionMemKey, &storedSubscriptions, true)
	if ss_ret == robot.Ok {
		subscriptions.Lock()
		storedSubscriptions.m = subscriptions.m
		subscriptions.dirty = false
		ret := updateDatum(subscriptionMemKey, ss_tok, storedSubscriptions)
		// NOTE: Hold the lock until after serializing - the
		// storedSubscriptions assignment doesn't copy.
		subscriptions.Unlock()
		if ret == robot.Ok {
			Log(robot.Debug, "Successfully saved '%d' long-term subscription memories", len(storedSubscriptions.m))
		} else {
			Log(robot.Error, "Error '%s' updating long-term subscription memory", ret)
		}
	} else {
		Log(robot.Error, "Saving suscriptions to long-term memory: error '%s' getting datum", ss_ret)
	}
}

// Subscribe allows a plugin to subscribe to it's current thread and
// receive all future responses. It returns a boolean - true on success,
// or false when a thread is already subscribed, or when called by anything
// other than a plugin. When false, an Error log message is generated.
func (r Robot) Subscribe() (success bool) {
	w := getLockedWorker(r.tid)
	defer w.Unlock()
	task, plugin, _ := getTask(r.currentTask)
	if plugin == nil {
		r.Log(robot.Error, "Subscribe called by non-plugin task '%s'", task.name)
		return false
	}
	subscriptionSpec := subscriptionMatcher{w.Channel, w.Incoming.ThreadID}
	subscriptions.Lock()
	defer subscriptions.Unlock()
	if subscription, ok := subscriptions.m[subscriptionSpec]; ok {
		if task.name != subscription.Plugin {
			r.Log(robot.Error, "Subscribe - plugin '%s' failed subscribing to thread '%s' in channel '%s', subscription already held by plugin '%s'", task.name, w.Incoming.ThreadID, w.Channel, subscription.Plugin)
			return false
		} else {
			r.Log(robot.Debug, "Subscribe - already subscribed; plugin '%s' subscribing to thread '%s' in channel '%s'", task.name, w.Incoming.ThreadID, w.Channel)
			return true
		}
	}
	subscriptions.m[subscriptionSpec] = subscriber{
		Plugin:    task.name,
		Timestamp: time.Now(),
	}
	subscriptions.dirty = true
	r.Log(robot.Debug, "Subscribe - plugin '%s' successfully subscribed to thread '%s' in channel '%s'", task.name, w.Incoming.ThreadID, w.Channel)
	return true
}

// Unsubscribe unsubscribes from the thread, returning true on success
// or false if no subscription was found. Generally, the return value
// can be ignored.
func (r Robot) Unsubscribe() (success bool) {
	w := getLockedWorker(r.tid)
	defer w.Unlock()
	task, plugin, _ := getTask(r.currentTask)
	if plugin == nil {
		r.Log(robot.Error, "Unsubscribe called by non-plugin task '%s'", task.name)
		return false
	}
	subscriptionSpec := subscriptionMatcher{w.Channel, w.Incoming.ThreadID}
	subscriptions.Lock()
	defer subscriptions.Unlock()
	if subscription, ok := subscriptions.m[subscriptionSpec]; ok {
		if task.name != subscription.Plugin {
			r.Log(robot.Error, "Unsubscribe - plugin '%s' failed subscribing to thread '%s' in channel '%s', subscription held by other plugin '%s'", task.name, w.Incoming.ThreadID, w.Channel, subscription.Plugin)
			return false
		} else {
			r.Log(robot.Debug, "Unsubscribe - plugin '%s' unsubscribing from thread '%s' in channel '%s'", task.name, w.Incoming.ThreadID, w.Channel)
			delete(subscriptions.m, subscriptionSpec)
			subscriptions.dirty = true
			return true
		}
	}
	r.Log(robot.Warn, "Unsubscribe - plugin '%s' not subscribed to thread '%s' in channel '%s'", task.name, w.Incoming.ThreadID, w.Channel)
	return true
}

// expireSubscriptions is called by the brainTicker
func expireSubscriptions(now time.Time) bool {
	subscriptions.Lock()
	for subscription, subscriber := range subscriptions.m {
		if now.Sub(subscriber.Timestamp) > threadMemoryDuration {
			delete(subscriptions.m, subscription)
			subscriptions.dirty = true
			Log(robot.Debug, "Subscribe - expiring subscription for plugin '%s' to thread '%s' in channel '%s'", subscriber.Plugin, subscription.thread, subscription.channel)
		}
	}
	updated := subscriptions.dirty
	subscriptions.Unlock()
	return updated
}
</file_content file: gopherbot-main/bot/subscribe_thread.go>
<preamble file: gopherbot-main/bot/taskconf.go>

</preamble>
<file_content file: gopherbot-main/bot/taskconf.go>
package bot

import (
	"encoding/json"
	"fmt"
	"reflect"
	"regexp"

	"github.com/ghodss/yaml"
	"github.com/lnxjedi/gopherbot/robot"
)

// loadTaskConfig() updates task/job/plugin configuration and namespaces/parametersets
// from robot.yaml and external configuration, then updates the
// globalTasks struct.
func loadTaskConfig(processed *configuration, preConnect bool) (*taskList, error) {
	newList := &taskList{
		t:             []interface{}{struct{}{}}, // initialize 0 to "nothing", for namespaces & parametersets only
		nameMap:       make(map[string]int),
		idMap:         make(map[string]int),
		nameSpaces:    make(map[string]ParameterSet),
		parameterSets: make(map[string]ParameterSet),
	}
	currentCfg.RLock()
	current := taskList{
		t:       currentCfg.t,
		nameMap: currentCfg.nameMap,
	}
	currentCfg.RUnlock()

	// Start with all the Go tasks, plugins and jobs
	for taskname := range taskHandlers {
		t := current.getTaskByName(taskname)
		newList.addTask(t)
	}

	for plugname := range pluginHandlers {
		t := current.getTaskByName(plugname)
		newList.addTask(t)
	}

	for jobname := range jobHandlers {
		t := current.getTaskByName(jobname)
		newList.addTask(t)
	}

	for _, ns := range processed.nsList {
		if _, ok := newList.nameMap[ns.Name]; ok {
			return newList, fmt.Errorf("NameSpace '%s' conflicts with another task/job/plugin/parameterset name", ns.Name)
		}
		newList.nameSpaces[ns.Name] = ParameterSet{
			name:        ns.Name,
			Description: ns.Description,
			Parameters:  ns.Parameters,
		}
		// The nameMap is the definitive list of all names, but namespaces don't correspond
		// to an actual task.
		newList.nameMap[ns.Name] = 0
	}

	for _, ps := range processed.psList {
		if _, ok := newList.nameMap[ps.Name]; ok {
			return newList, fmt.Errorf("ParameterSet '%s' conflicts with another task/job/plugin/parameterset name", ps.Name)
		}
		newList.parameterSets[ps.Name] = ParameterSet{
			name:        ps.Name,
			Description: ps.Description,
			Parameters:  ps.Parameters,
		}
		// The nameMap is the definitive list of all names, but parameter sets don't correspond
		// to an actual task.
		newList.nameMap[ps.Name] = 0
	}

	// Return disabled, error
	checkTaskSettings := func(ts TaskSettings, task *Task) (bool, error) {
		if ts.Disabled {
			task.Disabled = true
			task.reason = fmt.Sprintf("disabled in %s", robotConfigFileName)
			return true, nil
		}
		if len(ts.NameSpace) > 0 {
			if _, ok := newList.nameSpaces[ts.NameSpace]; !ok {
				return false, fmt.Errorf("configured NameSpace '%s' for task '%s' doesn't exist", ts.NameSpace, ts.Name)
			}
			task.NameSpace = ts.NameSpace
		}
		if len(ts.ParameterSets) > 0 {
			for _, set := range ts.ParameterSets {
				if _, ok := newList.parameterSets[set]; !ok {
					return false, fmt.Errorf("configured ParameterSet '%s' for task '%s' doesn't exist", set, ts.Name)
				}
			}
			task.ParameterSets = ts.ParameterSets
		}
		task.Description = ts.Description
		task.Parameters = ts.Parameters
		return false, nil
	}

	setupGoTask := func(ts TaskSettings, ttype pipeAddType) error {
		t := newList.getTaskByName(ts.Name)
		if t == nil {
			return fmt.Errorf("configuring Go task '%s' - no task found with that name", ts.Name)
		}
		task, plug, job := getTask(t)
		if (ttype == typePlugin && plug == nil) || (ttype == typeJob && job == nil) || task == nil {
			return fmt.Errorf("configuring Go task '%s' (type %s) - no task of that type registered with that name", ts.Name, ttype)
		}
		_, err := checkTaskSettings(ts, task)
		return err
	}

	// Get basic task configurations
	for _, ts := range processed.goTasks {
		if err := setupGoTask(ts, typeTask); err != nil {
			return newList, err
		}
	}
	for _, ts := range processed.goPlugins {
		if err := setupGoTask(ts, typePlugin); err != nil {
			return newList, err
		}
	}
	for _, ts := range processed.goJobs {
		if err := setupGoTask(ts, typeJob); err != nil {
			return newList, err
		}
	}

	addExternalTask := func(ts TaskSettings, ttype pipeAddType) (*Task, error) {
		if !identifierRe.MatchString(ts.Name) {
			return nil, fmt.Errorf("external task '%s' (type %s) doesn't match task name regex '%s'", ts.Name, ttype, identifierRe.String())
		}
		if ts.Name == "bot" {
			return nil, fmt.Errorf("illegal external task name 'bot' (type %s)", ts.Name)
		}
		if _, ok := newList.nameSpaces[ts.Name]; ok {
			return nil, fmt.Errorf("external task '%s' duplicates name of configured NameSpace", ts.Name)
		}
		if _, ok := newList.parameterSets[ts.Name]; ok {
			return nil, fmt.Errorf("external task '%s' duplicates name of configured ParameterSet", ts.Name)
		}
		if dupidx, ok := newList.nameMap[ts.Name]; ok {
			dupt := newList.t[dupidx]
			duptask, _, _ := getTask(dupt)
			if duptask.taskType == taskGo {
				return nil, fmt.Errorf("external task '%s' duplicates name of existing Go task/plugin/job", ts.Name)
			}
			return nil, fmt.Errorf("external task '%s' duplicates name of other external task/plugin/job", ts.Name)
		}
		task := &Task{
			name:        ts.Name,
			taskType:    taskExternal,
			Description: ts.Description,
			Parameters:  ts.Parameters,
		}
		// Note that disabled external tasks are skipped in conf.go
		_, err := checkTaskSettings(ts, task)
		if err != nil {
			return nil, err
		}
		if len(ts.Path) == 0 {
			return nil, fmt.Errorf("zero-length path for external task '%s'", ts.Name)
		}
		if _, _, err := getObjectPath(ts.Path); err != nil {
			return nil, fmt.Errorf("getting path '%s' for task '%s': %v", ts.Path, ts.Name, err)
		}
		task.Path = ts.Path
		return task, nil
	}

	for _, script := range processed.externalPlugins {
		var task *Task
		var err error
		if task, err = addExternalTask(script, typePlugin); err != nil {
			return newList, err
		}
		task.Privileged = *script.Privileged
		task.Homed = script.Homed
		p := &Plugin{
			Task: task,
		}
		newList.addTask(p)
	}

	for _, script := range processed.externalJobs {
		var task *Task
		var err error
		if task, err = addExternalTask(script, typeJob); err != nil {
			return newList, err
		}
		task.Privileged = *script.Privileged
		task.Homed = script.Homed
		j := &Job{
			Task: task,
		}
		newList.addTask(j)
	}

	for _, script := range processed.externalTasks {
		var task *Task
		var err error
		if task, err = addExternalTask(script, typeTask); err != nil {
			return newList, err
		}
		task.Privileged = *script.Privileged
		task.Homed = script.Homed
		newList.addTask(task)
	}

	// Load configuration for all valid tasks. Note that this is all being loaded
	// in to non-shared data structures that will replace current configuration
	// under lock at the end.
LoadLoop:
	for _, j := range newList.t[1:] {
		var plugin *Plugin
		var job *Job
		var task *Task
		var isPlugin, isJob bool
		switch t := j.(type) {
		case *Plugin:
			isPlugin = true
			plugin = t
			task = t.Task
			// Reset list of channels
			task.Channels = []string{}
		case *Job:
			isJob = true
			job = t
			task = t.Task
		// a bare task with no config to load
		default:
			continue
		}

		if task.Disabled {
			continue
		}
		tcfgdefault := make(map[string]interface{})
		tcfgload := make(map[string]json.RawMessage)
		if isPlugin {
			Log(robot.Info, "Loading configuration for plugin '%s', type %s", task.name, task.taskType)
		} else {
			Log(robot.Info, "Loading configuration for job '%s', type %s", task.name, task.taskType)
		}

		// Don't get plugin external configuration during preconnect,
		// since plugins may rely on stuff loaded by init jobs.
		if isPlugin && !preConnect {
			if plugin.taskType == taskExternal {
				// External plugins spit their default config to stdout when called with command="configure"
				cfg, err := getExtDefCfg(task)
				if err != nil {
					msg := fmt.Sprintf("Getting default configuration for external plugin, disabling: %v", err)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue
				}
				if err := yaml.Unmarshal(*cfg, &tcfgdefault); err != nil {
					msg := fmt.Sprintf("Unmarshalling default configuration, disabling: %v", err)
					Log(robot.Error, "Problem unmarshalling plugin default config for '%s', disabling: %v", task.name, err)
					task.Disabled = true
					task.reason = msg
					continue
				}
			} else {
				if err := yaml.Unmarshal([]byte(pluginHandlers[task.name].DefaultConfig), &tcfgdefault); err != nil {
					msg := fmt.Sprintf("Unmarshalling default configuration, disabling: %v", err)
					Log(robot.Error, "Problem unmarshalling plugin default config for '%s', disabling: %v", task.name, err)
					task.Disabled = true
					task.reason = msg
					continue
				}
			}
		}
		// getConfigFile overlays the default config with configuration from the install path, then config path
		cpath := "jobs/"
		if isPlugin {
			cpath = "plugins/"
		}
		if err := getConfigFile(cpath+task.name+".yaml", false, tcfgload, tcfgdefault); err != nil {
			msg := fmt.Sprintf("Problem loading configuration file(s) for task '%s', disabling: %v", task.name, err)
			Log(robot.Error, msg)
			task.Disabled = true
			task.reason = msg
			continue
		}
		if disjson, ok := tcfgload["Disabled"]; ok {
			disabled := false
			if err := json.Unmarshal(disjson, &disabled); err != nil {
				msg := fmt.Sprintf("Problem unmarshalling value for 'Disabled' in plugin/job '%s', disabling: %v", task.name, err)
				Log(robot.Error, msg)
				task.Disabled = true
				task.reason = msg
				continue
			}
			if disabled {
				msg := fmt.Sprintf("Plugin/Job '%s' is disabled by configuration", task.name)
				Log(robot.Info, msg)
				task.Disabled = true
				task.reason = msg
				continue
			}
		}
		// Boolean false values can be explicitly false, or default to false
		// when not specified. In some cases that matters.
		explicitAllChannels := false
		explicitAllowDirect := false

		for key, value := range tcfgload {
			var strval string
			var intval int
			var boolval bool
			var sarrval []string
			var hval []PluginHelp
			var mval []InputMatcher
			var tval []JobTrigger
			var val interface{}
			skip := false
			switch key {
			case "Elevator", "Authorizer", "AuthRequire", "NameSpace", "Channel":
				val = &strval
			case "KeepLogs":
				val = &intval
			case "Disabled":
				skip = true
			case "AllowDirect", "AmbientMatchCommand", "DirectOnly", "DenyDirect", "AllChannels", "RequireAdmin", "AuthorizeAllCommands", "CatchAll", "MatchUnlisted", "Quiet":
				val = &boolval
			case "Channels", "ElevatedCommands", "ElevateImmediateCommands", "Users", "AuthorizedCommands", "AllowedHiddenCommands", "AdminCommands", "ParameterSets":
				val = &sarrval
			case "Help":
				val = &hval
			case "CommandMatchers", "ReplyMatchers", "MessageMatchers", "Arguments":
				val = &mval
			case "Triggers":
				val = &tval
			case "Config":
				skip = true
			case "Privileged":
				return newList, fmt.Errorf("task '%s' illegally specifies 'Privileged' outside of %s", task.name, robotConfigFileName)
			default:
				msg := fmt.Sprintf("Invalid configuration key for task '%s': %s - disabling", task.name, key)
				Log(robot.Error, msg)
				task.Disabled = true
				task.reason = msg
				continue LoadLoop
			}

			if !skip {
				if err := json.Unmarshal(value, val); err != nil {
					msg := fmt.Sprintf("Disabling plugin '%s' - error unmarshalling value '%s': %v", task.name, key, err)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue LoadLoop
				}
			}

			mismatch := false
			// Defaults
			switch key {
			case "AllowDirect":
				task.AllowDirect = *(val.(*bool))
				explicitAllowDirect = true
			case "DirectOnly":
				task.DirectOnly = *(val.(*bool))
			// plugins can be scheduled, so Channel applies to both
			case "Channel":
				task.Channel = *(val.(*string))
			// Channels are only used for plugin visibility
			case "Channels":
				if isPlugin {
					task.Channels = *(val.(*[]string))
				} else {
					mismatch = true
				}
			case "AllChannels":
				task.AllChannels = *(val.(*bool))
				explicitAllChannels = true
			case "RequireAdmin":
				task.RequireAdmin = *(val.(*bool))
			case "AdminCommands":
				if isPlugin {
					plugin.AdminCommands = *(val.(*[]string))
				} else {
					mismatch = true
				}
			case "NameSpace":
				Log(robot.Error, "Task '%s' specifies NameSpace outside of %s, ignoring", robotConfigFileName)
			case "ParameterSets":
				Log(robot.Error, "Task '%s' specifies ParameterSets outside of %s, ignoring", robotConfigFileName)
			case "Elevator":
				task.Elevator = *(val.(*string))
			case "ElevatedCommands":
				if isPlugin {
					plugin.ElevatedCommands = *(val.(*[]string))
				} else {
					mismatch = true
				}
			case "ElevateImmediateCommands":
				if isPlugin {
					plugin.ElevateImmediateCommands = *(val.(*[]string))
				} else {
					mismatch = true
				}
			case "Users":
				task.Users = *(val.(*[]string))
			case "KeepLogs":
				if isPlugin {
					mismatch = true
				} else {
					job.KeepLogs = *(val.(*int))
				}
			case "Authorizer":
				task.Authorizer = *(val.(*string))
			case "AuthRequire":
				task.AuthRequire = *(val.(*string))
			case "AllowedHiddenCommands":
				if isPlugin {
					plugin.AllowedHiddenCommands = *(val.(*[]string))
				} else {
					mismatch = true
				}
			case "AuthorizedCommands":
				if isPlugin {
					plugin.AuthorizedCommands = *(val.(*[]string))
				} else {
					mismatch = true
				}
			case "AuthorizeAllCommands":
				if isPlugin {
					plugin.AuthorizeAllCommands = *(val.(*bool))
				} else {
					mismatch = true
				}
			case "Help":
				if isPlugin {
					plugin.Help = *(val.(*[]PluginHelp))
				} else {
					mismatch = true
				}
			case "CommandMatchers":
				if isPlugin {
					plugin.CommandMatchers = *(val.(*[]InputMatcher))
				} else {
					mismatch = true
				}
			case "ReplyMatchers":
				if isPlugin {
					task.ReplyMatchers = *(val.(*[]InputMatcher))
				} else {
					mismatch = true
				}
			case "MessageMatchers":
				if isPlugin {
					plugin.MessageMatchers = *(val.(*[]InputMatcher))
				} else {
					mismatch = true
				}
			case "Arguments":
				if isPlugin {
					mismatch = true
				} else {
					job.Arguments = *(val.(*[]InputMatcher))
				}
			case "AmbientMatchCommand":
				if isPlugin {
					plugin.AmbientMatchCommand = *(val.(*bool))
				} else {
					mismatch = true
				}
			case "CatchAll":
				if isPlugin {
					plugin.CatchAll = *(val.(*bool))
				} else {
					mismatch = true
				}
			case "MatchUnlisted":
				if isPlugin {
					plugin.MatchUnlisted = *(val.(*bool))
				} else {
					mismatch = true
				}
			case "Quiet":
				if isPlugin {
					mismatch = true
				} else {
					job.Quiet = *(val.(*bool))
				}
			case "Triggers":
				if isPlugin {
					mismatch = true
				} else {
					job.Triggers = *(val.(*[]JobTrigger))
				}
			case "Config":
				task.Config = value
			}
			if mismatch {
				var msg string
				if isPlugin {
					msg = fmt.Sprintf("Disabling plugin '%s' - invalid configuration key: %s", task.name, key)
				} else {
					msg = fmt.Sprintf("Disabling job '%s' - invalid configuration key: %s", task.name, key)
				}
				Log(robot.Error, msg)
				task.Disabled = true
				task.reason = msg
				continue LoadLoop
			}
		}
		// End of reading configuration keys

		// Start sanity checking of configuration
		if task.DirectOnly {
			if explicitAllowDirect {
				if !task.AllowDirect {
					msg := fmt.Sprintf("Task '%s' has conflicting values for AllowDirect (false) and DirectOnly (true), disabling", task.name)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue
				}
			} else {
				Log(robot.Debug, "DirectOnly specified without AllowDirect; setting AllowDirect = true")
				task.AllowDirect = true
				explicitAllowDirect = true
			}
		}

		if !explicitAllowDirect {
			task.AllowDirect = processed.defaultAllowDirect
		}

		// Sanity checking / default for channel / channels
		if isJob && len(task.Channel) == 0 {
			task.Channel = processed.defaultJobChannel
		}
		if isPlugin {
			// Use bot default plugin channels if none defined, unless AllChannels requested.
			if len(task.Channels) == 0 {
				if len(processed.plugChannels) > 0 {
					if !task.AllChannels { // AllChannels = true is always explicit
						task.Channels = processed.plugChannels
					}
				} else { // no default channels specified
					if !explicitAllChannels { // if AllChannels wasn't explicitly configured, and no default channels, default to AllChannels = true
						task.AllChannels = true
					}
				}
			}
		}

		// Considering possible default channels, is the plugin visible anywhere?
		if isPlugin {
			if len(task.Channels) > 0 {
				msg := fmt.Sprintf("Plugin '%s' will be available in channels %q", task.name, task.Channels)
				Log(robot.Info, msg)
			} else {
				if !(task.AllowDirect || task.AllChannels) {
					msg := fmt.Sprintf("Plugin '%s' not visible in any channels or by direct message, disabling", task.name)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue
				} else {
					Log(robot.Info, "Plugin '%s' has no channel restrictions configured; all channels: %t", task.name, task.AllChannels)
				}
			}
		} else {
			if len(task.Channel) == 0 {
				Log(robot.Error, "Job '%s' has no channel, and no DefaultJobChannel set, disabling", task.name)
				task.Disabled = true
				task.reason = "no channel set"
				continue
			} else {
				Log(robot.Info, "Job '%s' will run in channel '%s'", task.name, task.Channel)
			}
		}

		// Compile the regex's
		if isPlugin {
			for i := range plugin.CommandMatchers {
				command := &plugin.CommandMatchers[i]
				regex := `^(?s:\s*` + command.Regex + `\s*)$`
				re, err := regexp.Compile(regex)
				if err != nil {
					msg := fmt.Sprintf("Disabling '%s', couldn't compile command regular expression '%s': %v", task.name, regex, err)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue LoadLoop
				} else {
					// Store the modified regex
					command.Regex = regex
					command.re = re
				}
			}
			for i := range plugin.MessageMatchers {
				// Note that full message regexes don't get the beginning and end anchors added - the individual plugin
				// will need to do this if necessary.
				message := &plugin.MessageMatchers[i]
				re, err := regexp.Compile(message.Regex)
				if err != nil {
					msg := fmt.Sprintf("Disabling '%s', couldn't compile message regular expression '%s': %v", task.name, message.Regex, err)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue LoadLoop
				} else {
					message.re = re
				}
			}
		} else {
			for i := range job.Triggers {
				trigger := &job.Triggers[i]
				if len(trigger.User) == 0 || len(trigger.Channel) == 0 {
					msg := fmt.Sprintf("Disabling '%s', zero-length User or Channel for trigger #%d", task.name, i+1)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue LoadLoop
				}
				re, err := regexp.Compile(trigger.Regex)
				if err != nil {
					msg := fmt.Sprintf("Disabling '%s', couldn't compile trigger regular expression '%s': %v", task.name, trigger.Regex, err)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue LoadLoop
				} else {
					trigger.re = re
				}
			}
			for i := range job.Arguments {
				argument := &job.Arguments[i]
				label := argument.Label
				if stockRepliesRe.MatchString(label) {
					msg := fmt.Sprintf("Disabling '%s', invalid regex label '%s' starts with capital letter", task.name, label)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue LoadLoop
				}
				regex := `^\s*` + argument.Regex + `\s*$`
				re, err := regexp.Compile(regex)
				if err != nil {
					msg := fmt.Sprintf("Disabling '%s', couldn't compile argument regular expression '%s': %v", task.name, regex, err)
					Log(robot.Error, msg)
					task.Disabled = true
					task.reason = msg
					continue LoadLoop
				} else {
					argument.Regex = regex
					argument.re = re
				}
			}
		}
		for i := range task.ReplyMatchers {
			reply := &task.ReplyMatchers[i]
			label := reply.Label
			if stockRepliesRe.MatchString(label) {
				msg := fmt.Sprintf("Disabling '%s', invalid regex label '%s' starts with capital letter", task.name, label)
				Log(robot.Error, msg)
				task.Disabled = true
				task.reason = msg
				continue LoadLoop
			}
			re, err := regexp.Compile(`^\s*` + reply.Regex + `\s*$`)
			if err != nil {
				msg := fmt.Sprintf("Skipping %s, couldn't compile reply regular expression '%s': %v", task.name, reply.Regex, err)
				Log(robot.Error, msg)
				task.Disabled = true
				task.reason = msg
				continue LoadLoop
			} else {
				reply.re = re
			}
		}

		// Make sure all security-related command lists resolve to actual
		// commands to guard against typos.
		if isPlugin {
			cmdlist := []struct {
				ctype string
				clist []string
			}{
				{"elevated", plugin.ElevatedCommands},
				{"elevate immediate", plugin.ElevateImmediateCommands},
				{"authorized", plugin.AuthorizedCommands},
				{"admin", plugin.AdminCommands},
			}
			for _, cmd := range cmdlist {
				if len(cmd.clist) > 0 {
					for _, i := range cmd.clist {
						cmdfound := false
						for _, j := range plugin.CommandMatchers {
							if i == j.Command {
								cmdfound = true
								break
							}
						}
						if !cmdfound {
							for _, j := range plugin.MessageMatchers {
								if i == j.Command {
									cmdfound = true
									break
								}
							}
						}
						if !cmdfound {
							msg := fmt.Sprintf("Disabling %s, %s command %s didn't match a command from CommandMatchers or MessageMatchers", task.name, cmd.ctype, i)
							Log(robot.Error, msg)
							task.Disabled = true
							task.reason = msg
							continue LoadLoop
						}
					}
				}
			}
			// For Go plugins, use the provided empty config struct to go ahead
			// and unmarshall Config. The GetTaskConfig call just sets a pointer
			// without unmshalling again.
			if plugin.taskType == taskGo {
				// Copy the pointer to the empty config struct / empty struct (when no config)
				// pluginHandlers[name].Config is an empty struct for unmarshalling provided
				// in RegisterPlugin.
				pt := reflect.ValueOf(pluginHandlers[task.name].Config)
				if pt.Kind() == reflect.Ptr {
					if task.Config != nil {
						// reflect magic: create a pointer to a new empty config struct for the plugin
						task.config = reflect.New(reflect.Indirect(pt).Type()).Interface()
						if err := json.Unmarshal(task.Config, task.config); err != nil {
							msg := fmt.Sprintf("Unmarshalling plugin config json to config, disabling: %v", err)
							Log(robot.Error, msg)
							task.Disabled = true
							task.reason = msg
							continue
						}
					} else {
						// Providing custom config not required (should it be?)
						Log(robot.Warn, "Plugin '%s' has custom config, but none is configured", task.name)
					}
				} else {
					if task.Config != nil {
						msg := fmt.Sprintf("Custom configuration data provided for Go plugin '%s', but no config struct was registered; disabling", task.name)
						Log(robot.Error, msg)
						task.Disabled = true
						task.reason = msg
					} else {
						Log(robot.Debug, "Config interface isn't a pointer, skipping unmarshal for Go plugin '%s'", task.name)
					}
				}
			}
		}

		Log(robot.Debug, "Configured task '%s'", task.name)
	}
	// End of configuration loading. All invalid tasks are disabled.

	return newList, nil
}
</file_content file: gopherbot-main/bot/taskconf.go>
<preamble file: gopherbot-main/bot/tasks.go>

</preamble>
<file_content file: gopherbot-main/bot/tasks.go>
package bot

import (
	"encoding/json"
	"log"
	"regexp"
	"runtime"
	"sync"

	"github.com/lnxjedi/gopherbot/robot"
)

// Regex for task/job/plugin/NameSpace names. NOTE: if this changes,
// command regexes in jobbuiltins.go will need to be changed.
// Identifiers can be letters, numbers & underscores only, mainly so
// brain functions can use ':' as a separator.
const identifierRegex = `[A-Za-z][\w-]*`

var identifierRe = regexp.MustCompile(identifierRegex)

// Global persistent map of task/namespace name to unique ID
// TODO: rename this when errors are cleared
var taskNameIDmap = struct {
	m map[string]string
	sync.Mutex
}{
	make(map[string]string),
	sync.Mutex{},
}

type taskList struct {
	t []interface{}
	// nameMap - map of every task, job, plugin and namespace to t[] index;
	// namespaces are all idx==0
	nameMap map[string]int
	idMap   map[string]int // task ID to task number
	// map of namespace name to NameSpace, updated on every load
	nameSpaces map[string]ParameterSet
	// map of parameterset name to NameSpace (re-using identical data structure)
	parameterSets map[string]ParameterSet
}

func getTask(t interface{}) (*Task, *Plugin, *Job) {
	p, ok := t.(*Plugin)
	if ok {
		return p.Task, p, nil
	}
	j, ok := t.(*Job)
	if ok {
		return j.Task, nil, j
	}
	return t.(*Task), nil, nil
}

func (tl *taskList) getTaskByName(name string) interface{} {
	if len(name) == 0 {
		_, file, line, _ := runtime.Caller(1)
		Log(robot.Error, "Invalid 0-length task from caller: %s, line %d", file, line)
	}
	ti, ok := tl.nameMap[name]
	if !ok {
		Log(robot.Error, "Task '%s' not found calling getTaskByName", name)
		return nil
	}
	if ti == 0 {
		Log(robot.Error, "'%s' refers to a namespace in getTaskByName", name)
		return nil
	}
	task := tl.t[ti]
	return task
}

// true if name refers to a NameSpace, false if not or doesn't exist
func (tl *taskList) isNamespace(name string) (ok bool) {
	_, ok = tl.nameSpaces[name]
	return
}

// TaskSpec is the structure for ScheduledJobs (robot.yaml) and AddTask (robot method)
type TaskSpec struct {
	Name      string // name of the job or plugin
	Command   string // plugins only
	Arguments []string
	task      interface{} // populated in AddTask
}

// TaskSettings struct used for configuration of: ExternalPlugins, ExternalJobs,
// ExternalTasks, GoPlugins, GoJobs, GoTasks and NameSpaces in robot.yaml.
// Not every field is used in every case.
type TaskSettings struct {
	Name, Path, Description, NameSpace string
	ParameterSets                      []string
	Disabled                           bool
	Homed                              bool
	Privileged                         *bool
	Parameters                         []robot.Parameter
}

// LoadableModule struct for loading external modules.
type LoadableModule struct {
	Name, Path, Description string
	Disabled                bool
}

// ScheduledTask items defined in robot.yaml, mostly for scheduled jobs
type ScheduledTask struct {
	Schedule string // timespec for https://godoc.org/github.com/robfig/cron
	TaskSpec
}

// PluginHelp specifies keywords and help text for the 'bot help system
type PluginHelp struct {
	Keywords []string // match words for 'help XXX'
	Helptext []string // help string to give for the keywords, conventionally starting with (bot) for commands or (hear) when the bot needn't be addressed directly
}

// InputMatcher specifies the command or message to match for a plugin
type InputMatcher struct {
	Regex       string         // The regular expression string to match - bot adds ^\w* & \w*$
	Command     string         // The name of the command to pass to the plugin with it's arguments
	Label       string         // ReplyMatchers use "Label" instead of "Command"
	ChannelOnly bool           // Whether this matcher only applies in the main channel (not a thread)
	Contexts    []string       // label the contexts corresponding to capture groups, for supporting "it" & optional args
	re          *regexp.Regexp // The compiled regular expression. If the regex doesn't compile, the 'bot will log an error
}

// JobTrigger specifies a user and message to trigger a job
type JobTrigger struct {
	Regex   string         // The regular expression string to match - bot adds ^\w* & \w*$
	User    string         // required user to trigger this job, normally git-activated webhook or integration
	Channel string         // required channel for the trigger
	re      *regexp.Regexp // The compiled regular expression. If the regex doesn't compile, the 'bot will log an error
}

// ParameterSet just stores a name, description, and parameters - they cannot be run.
type ParameterSet struct {
	name        string            // name of the shared namespace
	Description string            // optional description of the shared namespace
	Parameters  []robot.Parameter // Parameters for the shared namespace
}

// Task configuration is common to tasks, plugins or jobs. Any task, plugin or job can call bot methods. Note that tasks are only defined
// in robot.yaml, and no external configuration is read in.
type Task struct {
	name          string            // name of job or plugin; unique by type, but job & plugin can share
	taskType      taskType          // taskGo or taskExternal
	Path          string            // Path to the external executable for external scripts
	NameSpace     string            // callers that share namespace share long-term memories and environment vars; defaults to name if not otherwise set
	Parameters    []robot.Parameter // Fixed parameters for a given job; many jobs will use the same script with differing parameters
	ParameterSets []string          //
	Description   string            // description of job or plugin
	AllowDirect   bool              // Set this true if this plugin can be accessed via direct message
	DirectOnly    bool              // Set this true if this plugin ONLY accepts direct messages
	Channel       string            // channel where a job can be interracted with, channel where a scheduled task (job or plugin) runs
	Channels      []string          // plugins only; Channels where the plugin is available - rifraf like "memes" should probably only be in random, but it's configurable. If empty uses DefaultChannels
	AllChannels   bool              // If the Channels list is empty and AllChannels is true, the plugin should be active in all the channels the bot is in
	RequireAdmin  bool              // Set to only allow administrators to access a plugin / run job
	Users         []string          // If non-empty, list of all the users with access to this plugin
	Elevator      string            // Use an elevator other than the DefaultElevator
	Authorizer    string            // a plugin to call for authorizing users, should handle groups, etc.
	AuthRequire   string            // an optional group/role name to be passed to the Authorizer plugin, for group/role-based authorization determination
	// taskID        string            // 32-char random ID for identifying plugins/jobs
	ReplyMatchers []InputMatcher  // store this here for prompt*reply methods
	Config        json.RawMessage // Arbitrary Plugin configuration, will be stored and provided in a thread-safe manner via GetTaskConfig()
	config        interface{}     // A pointer to an empty struct that the bot can Unmarshal custom configuration into
	Disabled      bool
	reason        string // why this job/plugin is disabled
	// Privileged jobs/plugins run with the privileged UID, privileged tasks
	// require privileged pipelines.
	Privileged bool
	// Homed for jobs/plugins starts the pipeline with c.basePath = ".", Homed tasks
	// always run in ".", e.g. "ssh-init"
	Homed bool
}

// Job - configuration only applicable to jobs. Read in from conf/jobs/<job>.yaml, which can also include anything from a Task.
type Job struct {
	Quiet     bool           // whether to quash "job started/ended" messages
	KeepLogs  int            // how many runs of this job/plugin to keep history for
	Triggers  []JobTrigger   // user/regex that triggers a job, e.g. a git-activated webhook or integration
	Arguments []InputMatcher // list of arguments to prompt the user for
	*Task
}

// Plugin specifies the structure of a plugin configuration - plugins should include an example / default config. Custom plugin configuration
// will be loaded from conf/plugins/<plugin>.yaml, which can also include anything from a Task.
type Plugin struct {
	AdminCommands            []string       // A list of commands only a bot admin can use
	ElevatedCommands         []string       // Commands that require elevation, usually via 2fa
	ElevateImmediateCommands []string       // Commands that always require elevation promting, regardless of timeouts
	AuthorizedCommands       []string       // Which commands to authorize
	AllowedHiddenCommands    []string       // which commands are allowed to be hidden
	AuthorizeAllCommands     bool           // when ALL commands need to be authorized
	Help                     []PluginHelp   // All the keyword sets / help texts for this plugin
	CommandMatchers          []InputMatcher // Input matchers for messages that need to be directed to the 'bot
	MessageMatchers          []InputMatcher // Input matchers for messages the 'bot hears even when it's not being spoken to
	AmbientMatchCommand      bool           // Whether message matchers should also match when isCommand is true
	CatchAll                 bool           // Whenever the robot is spoken to, but no plugin matches, plugins with CatchAll=true get called with command="catchall" and argument=<full text of message to robot>
	MatchUnlisted            bool           // Set to true if ambient messages matches should be checked for users not listed in the UserRoster
	*Task
}

var pluginHandlers = make(map[string]robot.PluginHandler)
var jobHandlers = make(map[string]robot.JobHandler)
var taskHandlers = make(map[string]robot.TaskHandler)

// stopRegistrations is set "true" when the bot is created to prevent registration outside of init functions
var stopRegistrations = false

// initialize sends the "init" command to every plugin
func initializePlugins() {
	currentCfg.RLock()
	cfg := currentCfg.configuration
	tasks := currentCfg.taskList
	protocol := currentCfg.protocol
	currentCfg.RUnlock()
	state.Lock()
	if !state.shuttingDown {
		state.Unlock()
		for _, t := range tasks.t[1:] {
			task, plugin, _ := getTask(t)
			if plugin == nil {
				continue
			}
			if task.Disabled {
				continue
			}
			w := &worker{
				cfg:           cfg,
				tasks:         tasks,
				Protocol:      getProtocol(protocol),
				Incoming:      &robot.ConnectorMessage{},
				automaticTask: true,
				id:            getWorkerID(),
			}
			Log(robot.Info, "Initializing plugin: %s", task.name)
			go w.startPipeline(nil, t, plugCommand, "init")
		}
	} else {
		state.Unlock()
	}
}

// registerTask centralizes the sanity checking logic for RegisterPlugin,
// RegisterJob and RegisterTask
func registerTask(name string) *Task {
	if stopRegistrations {
		return nil
	}
	if !identifierRe.MatchString(name) {
		log.Fatalf("Name '%s' doesn't match name regex '%s'", name, identifierRe.String())
	}
	if name == "bot" {
		log.Fatalf("Illegal name registration for 'bot'")
	}
	if _, ok := currentCfg.nameMap[name]; ok {
		log.Fatalf("Go task '%s' name collision with other task/job/plugin/namespace", name)
	}
	task := &Task{
		name:     name,
		taskType: taskGo,
	}
	return task
}

// addTask adds the registered task to the global list
func (tl *taskList) addTask(t interface{}) {
	task, _, _ := getTask(t)
	idx := len(tl.t)
	tl.t = append(tl.t, t)
	tl.nameMap[task.name] = idx
	tl.idMap[task.name] = idx
}

// RegisterPlugin allows Go plugins to register a PluginHandler in a func init().
// Also called for new plugins loaded with a loadable module.
// When the bot initializes, it will call each plugin's handler with a command
// "init", empty channel, the bot's username, and no arguments, so the plugin
// can store this information for, e.g., scheduled jobs.
// See robot/structs.go for the pluginHandlers definition.
func RegisterPlugin(name string, plug robot.PluginHandler) {
	task := registerTask(name)
	if task == nil {
		return
	}
	plugin := &Plugin{
		Task: task,
	}
	currentCfg.addTask(plugin)
	pluginHandlers[name] = plug
}

// RegisterJob registers a Go job
func RegisterJob(name string, gojob robot.JobHandler) {
	task := registerTask(name)
	if task == nil {
		return
	}
	job := &Job{
		Task: task,
	}
	currentCfg.addTask(job)
	jobHandlers[name] = gojob
}

// RegisterTask registers a Go task. If prevRequired is set, the task can
// only be added to a privileged pipeline.
func RegisterTask(name string, privRequired bool, gotask robot.TaskHandler) {
	task := registerTask(name)
	if task == nil {
		return
	}
	task.Privileged = privRequired
	currentCfg.addTask(task)
	taskHandlers[name] = gotask
}
</file_content file: gopherbot-main/bot/tasks.go>
<preamble file: gopherbot-main/bot/tasktype_string.go>

</preamble>
<file_content file: gopherbot-main/bot/tasktype_string.go>
// Code generated by "stringer -type=taskType constants.go"; DO NOT EDIT.

package bot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[taskGo-0]
	_ = x[taskExternal-1]
}

const _taskType_name = "taskGotaskExternal"

var _taskType_index = [...]uint8{0, 6, 18}

func (i taskType) String() string {
	if i < 0 || i >= taskType(len(_taskType_index)-1) {
		return "taskType(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _taskType_name[_taskType_index[i]:_taskType_index[i+1]]
}
</file_content file: gopherbot-main/bot/tasktype_string.go>
<preamble file: gopherbot-main/bot/term_connector.go>

</preamble>
<file_content file: gopherbot-main/bot/term_connector.go>
package bot

import (
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/lnxjedi/readline"
)

func init() {
	RegisterConnector("terminal", Initialize)
}

const termBotID = "u0000"
const threadIDMax = 65536
const terminalConnectorHelpLine = "Terminal connector: Type '|c?' to list channels, '|u?' to list users, '|t?' for thread help\n"

// Global persistent map of user name to user index
var userIDMap = make(map[string]int)
var userMap = make(map[string]int)

type termUser struct {
	Name                                        string // username / handle
	InternalID                                  string // connector internal identifier
	Email, FullName, FirstName, LastName, Phone string
}

type termconfig struct {
	StartChannel     string // the initial channel
	StartUser        string // the initial userid
	EOF              string // command to send on EOF (ctrl-D), default ";quit"
	Abort            string // command to send on ctrl-c
	BotName          string // the bot's name, required for the robot to hear it's own messages
	Users            []termUser
	Channels         []string
	GenerateNewlines bool // whether to replace the \n sequence with an actual newline
}

// termConnector holds all the relevant data about a connection
type termConnector struct {
	currentChannel   string             // The current channel for the user
	currentUser      string             // The current userid
	currentThread    string             // Active threadID if typingInThread is true
	lastThread       string             // last thread heard from the robot, used with join
	threadCounter    int                // Incrementing integer for assigning thread IDs
	typingInThread   bool               // Tracks whether input is coming from a thread
	generateNewlines bool               // see above
	botName          string             // see above
	eof              string             // command to send on ctrl-d (EOF)
	abort            string             // command to send on ctrl-c (interrupt)
	running          bool               // set on call to Run
	width            int                // width of terminal
	users            []termUser         // configured users
	channels         []string           // the channels the robot is in
	heard            chan string        // when the user speaks
	reader           *readline.Instance // readline for speaking
	robot.Handler                       // bot API for connectors
	sync.RWMutex                        // shared mutex for locking connector data structures
}

var exit = struct {
	kbquit, robotexit bool
	waitchan          chan struct{}
	sync.Mutex
}{
	false, false,
	make(chan struct{}),
	sync.Mutex{},
}

var quitTimeout = 4 * time.Second

var lock sync.Mutex // package var lock
var started bool    // set when connector is started

// Initialize sets up the connector and returns a connector object
func Initialize(handler robot.Handler, l *log.Logger) robot.Connector {
	lock.Lock()
	if started {
		lock.Unlock()
		return nil
	}
	started = true
	lock.Unlock()

	var c termconfig

	err := handler.GetProtocolConfig(&c)
	if err != nil {
		handler.Log(robot.Fatal, "Unable to retrieve protocol configuration: %v", err)
	}
	eof := ";quit"
	abort := ";abort"
	if len(c.EOF) > 0 {
		eof = c.EOF
	}
	if len(c.Abort) > 0 {
		abort = c.Abort
	}
	found := false
	for i, u := range c.Users {
		userMap[u.Name] = i
		userIDMap[u.InternalID] = i
		if c.StartUser == u.Name {
			found = true
		}
	}
	if !found {
		handler.Log(robot.Fatal, "Start user \"%s\" not listed in Users array", c.StartUser)
	}
	if _, ok := userIDMap[termBotID]; !ok {
		firstRunes := []rune(c.BotName)
		firstRunes[0] = unicode.ToUpper(firstRunes[0])
		botUser := termUser{
			Name:       c.BotName,
			InternalID: termBotID,
			Email:      c.BotName + "@example.com",
			FullName:   string(firstRunes) + " Gopherbot",
			FirstName:  string(firstRunes),
			LastName:   "Gopherbot",
			Phone:      "(555)765-0000",
		}
		c.Users = append(c.Users, botUser)
		idx := len(c.Users) - 1
		userMap[c.BotName] = idx
		userIDMap[termBotID] = idx
	}

	found = false
	for _, ch := range c.Channels {
		if c.StartChannel == ch {
			found = true
		}
	}
	if !found {
		handler.Log(robot.Fatal, "Start channel \"%s\" not listed in Channels array", c.StartChannel)
	}

	var histfile string
	home := os.Getenv("HOME")
	if len(home) == 0 {
		home = os.Getenv("USERPROFILE")
	}
	if len(home) > 0 {
		histfile = path.Join(home, ".gopherbot_history")
	}

	rl, err := readline.NewEx(&readline.Config{
		Prompt:            fmt.Sprintf("c:%s/u:%s -> ", c.StartChannel, c.StartUser),
		HistoryFile:       histfile,
		HistorySearchFold: true,
		InterruptPrompt:   "abort",
		EOFPrompt:         "exit",
	})
	if err != nil {
		panic(err)
	}

	tc := &termConnector{
		currentChannel:   c.StartChannel,
		currentUser:      c.StartUser,
		generateNewlines: c.GenerateNewlines,
		botName:          c.BotName,
		eof:              eof,
		abort:            abort,
		channels:         c.Channels,
		running:          false,
		width:            readline.GetScreenWidth(),
		users:            c.Users,
		heard:            make(chan string),
		reader:           rl,
	}

	tc.Handler = handler
	tc.SetTerminalWriter(tc.reader)
	return robot.Connector(tc)
}

func (tc *termConnector) Run(stop <-chan struct{}) {
	tc.Lock()
	// This should never happen, just a bit of defensive coding
	if tc.running {
		tc.Unlock()
		return
	}
	tc.running = true
	tc.Unlock()
	defer func() {
	}()

	// listen loop
	go func(tc *termConnector) {
	readloop:
		for {
			line, err := tc.reader.Readline()
			exit.Lock()
			robotexit := exit.robotexit
			if robotexit {
				exit.Unlock()
				tc.heard <- ""
				break readloop
			}
			kbquit := false
			if err == io.EOF {
				tc.heard <- tc.eof
				kbquit = true
			} else if err == readline.ErrInterrupt {
				tc.heard <- tc.abort
				kbquit = true
			} else if err == nil {
				line = strings.TrimSpace(line)
				if len(line) == 0 {
					tc.reader.Write([]byte(terminalConnectorHelpLine))
				} else {
					if line == "help" {
						tc.reader.Write([]byte(terminalConnectorHelpLine))
					}
					tc.heard <- line
					if line == tc.eof || line == tc.abort {
						kbquit = true
					}
				}
			}
			if kbquit {
				exit.kbquit = true
				exit.Unlock()
				select {
				case <-exit.waitchan:
					break readloop
				case <-time.After(quitTimeout):
					exit.Lock()
					exit.kbquit = false
					exit.Unlock()
					tc.reader.Write([]byte("(timed out waiting for robot to exit; check terminal connector settings 'EOF' and 'Abort')\n"))
				}
			} else {
				exit.Unlock()
			}
		}
	}(tc)

	tc.reader.Write([]byte("Terminal connector running; Type '|c?' to list channels, '|u?' to list users\n"))

	kbquit := false

loop:
	// Main loop and prompting
	for {
		select {
		case <-stop:
			tc.Log(robot.Info, "Received stop in connector")
			exit.Lock()
			kbquit = exit.kbquit
			exit.robotexit = true
			exit.Unlock()
			if kbquit {
				exit.waitchan <- struct{}{}
			} else {
				tc.reader.Write([]byte("Exiting (press <enter> ...)\n"))
			}
			break loop
		case input := <-tc.heard:
			if len(input) == 0 {
				evs := tc.GetEventStrings()
				if len(*evs) > 0 {
					tc.reader.Write([]byte(fmt.Sprintf("Events gathered: %s\n", strings.Join(*evs, ", "))))
				}
				continue
			}
			if input[0] == '|' {
				if len(input) == 1 {
					continue
				}
				switch input[1] {
				case 'C', 'c':
					exists := false
					newchan := input[2:]
					newchan = strings.TrimLeft(newchan, " ")
					if newchan == "?" {
						tc.reader.Write([]byte("Available channels:\n"))
						tc.reader.Write([]byte("(direct message); type: '|c'\n"))
						for _, channel := range tc.channels {
							tc.reader.Write([]byte(fmt.Sprintf("'%s'; type: '|c%s'\n", channel, channel)))
						}
						continue
					}
					tc.Lock()
					if newchan == "" {
						tc.currentChannel = ""
						tc.reader.SetPrompt(fmt.Sprintf("c:(direct)/u:%s -> ", tc.currentUser))
						tc.reader.Write([]byte("Changed current channel to: direct message\n"))
						tc.typingInThread = false
					} else {
						for _, ch := range tc.channels {
							if ch == newchan {
								exists = true
								break
							}
						}
						if exists {
							tc.currentChannel = newchan
							tc.typingInThread = false
							tc.reader.SetPrompt(fmt.Sprintf("c:%s/u:%s -> ", tc.currentChannel, tc.currentUser))
							tc.reader.Write([]byte(fmt.Sprintf("Changed current channel to: %s\n", newchan)))
						} else {
							tc.reader.Write([]byte("Invalid channel\n"))
						}
					}
					tc.Unlock()
				case 'J', 'j':
					tc.RLock()
					lastThread := tc.lastThread
					tc.RUnlock()
					if len(lastThread) == 0 {
						tc.reader.Write([]byte("(sorry, I don't see a thread to join)\n"))
						continue
					}
					tc.Lock()
					tc.typingInThread = true
					tc.currentThread = lastThread
					tc.reader.SetPrompt(fmt.Sprintf("c:%s(%s)/u:%s -> ", tc.currentChannel, tc.currentThread, tc.currentUser))
					tc.reader.Write([]byte(fmt.Sprintf("(now typing in thread: %s)\n", tc.currentThread)))
					tc.Unlock()
				case 'T', 't':
					setThread := input[2:]
					setThread = strings.TrimLeft(setThread, " ")
					if setThread == "?" {
						tc.reader.Write([]byte("Use '|t' to toggle typing in a thread, '|t<string>' to set the current thread ID, or '|j' to join the robot's thread\n"))
						continue
					}
					tc.Lock()
					if len(setThread) == 0 {
						tc.typingInThread = !tc.typingInThread
						if tc.typingInThread {
							tc.currentThread = fmt.Sprintf("%04x", tc.threadCounter%threadIDMax)
						}
					} else {
						tc.typingInThread = true
						tc.currentThread = setThread
					}
					if tc.typingInThread {
						tc.reader.SetPrompt(fmt.Sprintf("c:%s(%s)/u:%s -> ", tc.currentChannel, tc.currentThread, tc.currentUser))
						tc.reader.Write([]byte(fmt.Sprintf("(now typing in thread: %s)\n", tc.currentThread)))
					} else {
						tc.reader.SetPrompt(fmt.Sprintf("c:%s/u:%s -> ", tc.currentChannel, tc.currentUser))
						tc.reader.Write([]byte("(typing in channel now)\n"))
					}
					tc.Unlock()
				case 'U', 'u':
					exists := false
					newuser := input[2:]
					newuser = strings.TrimLeft(newuser, " ")
					if newuser == "?" {
						tc.reader.Write([]byte("Available users:\n"))
						for _, user := range tc.users {
							tc.reader.Write([]byte(fmt.Sprintf("'%s'; type: '|u%s'\n", user.Name, user.Name)))
						}
						continue
					}
					tc.Lock()
					if newuser == "" {
						tc.reader.Write([]byte("Invalid 0-length user\n"))
					} else {
						for _, u := range tc.users {
							if u.Name == newuser {
								exists = true
							}
						}
						if exists {
							tc.currentUser = newuser
							tc.reader.SetPrompt(fmt.Sprintf("c:%s/u:%s -> ", tc.currentChannel, tc.currentUser))
							tc.reader.Write([]byte(fmt.Sprintf("Changed current user to: %s\n", newuser)))
						} else {
							tc.reader.Write([]byte("Invalid user\n"))
						}
					}
					tc.Unlock()
				default:
					tc.reader.Write([]byte("Invalid terminal connector command\n"))
				}
			} else {
				var channelID string
				direct := false
				if len(tc.currentChannel) > 0 {
					channelID = "#" + tc.currentChannel
				} else {
					direct = true
				}
				i := userMap[tc.currentUser]
				ui := tc.users[i]
				var threadID, messageID string
				tc.Lock()
				tc.threadCounter++
				messageNumber := tc.threadCounter
				tc.Unlock()
				if tc.typingInThread {
					messageID = fmt.Sprintf("%04x", messageNumber%threadIDMax)
					threadID = tc.currentThread
				} else {
					threadID = fmt.Sprintf("%04x", messageNumber%threadIDMax)
					messageID = threadID
				}
				if tc.generateNewlines {
					input = strings.ReplaceAll(input, `\n`, "\n")
				}
				botMsg := &robot.ConnectorMessage{
					Protocol:        "terminal",
					UserName:        tc.currentUser,
					UserID:          ui.InternalID,
					ChannelName:     tc.currentChannel,
					ChannelID:       channelID,
					MessageID:       messageID,
					ThreadedMessage: tc.typingInThread,
					ThreadID:        threadID,
					MessageText:     input,
					DirectMessage:   direct,
				}
				tc.RLock()
				tc.IncomingMessage(botMsg)
				tc.RUnlock()
			}
		}
	}
	if !kbquit {
		<-tc.heard
	}
	tc.reader.Write([]byte("Terminal connector finished\n"))
	tc.reader.Close()
}

func (tc *termConnector) MessageHeard(u, c string) {
	return
}

func (tc *termConnector) getUserInfo(u string) (*termUser, bool) {
	var i int
	var exists bool
	if id, ok := tc.ExtractID(u); ok {
		i, exists = userIDMap[id]
	} else {
		i, exists = userMap[u]
	}
	if exists {
		return &tc.users[i], true
	}
	return nil, false
}

func (tc *termConnector) getChannel(c string) string {
	if ch, ok := tc.ExtractID(c); ok {
		return strings.TrimPrefix(ch, "#")
	}
	return c
}

func (tc *termConnector) checkSendSelf(ch, thr, msg string, f robot.MessageFormat) {
	var threadID, messageID string
	var threadedMessage bool
	tc.Lock()
	tc.threadCounter++
	messageNumber := tc.threadCounter
	tc.Unlock()
	if len(thr) > 0 {
		threadedMessage = true
		messageID = fmt.Sprintf("%04x", messageNumber%threadIDMax)
		threadID = thr
	} else {
		threadID = fmt.Sprintf("%04x", messageNumber%threadIDMax)
		messageID = threadID
	}
	tc.Log(robot.Debug, "Forwarding message id '%s' from the robot %s/%s", messageID, tc.botName, termBotID)
	botMsg := &robot.ConnectorMessage{
		Protocol:        "terminal",
		UserName:        tc.botName,
		UserID:          termBotID,
		ChannelName:     ch,
		ChannelID:       "#" + ch,
		MessageID:       messageID,
		ThreadedMessage: threadedMessage,
		SelfMessage:     true,
		ThreadID:        threadID,
		MessageText:     msg,
	}
	tc.RLock()
	tc.IncomingMessage(botMsg)
	tc.RUnlock()
}

// SetUserMap lets Gopherbot provide a mapping of usernames to user IDs
func (tc *termConnector) SetUserMap(map[string]string) {
	return
}

// GetUserAttribute returns a string attribute or nil if slack doesn't
// have that information
func (tc *termConnector) GetProtocolUserAttribute(u, attr string) (value string, ret robot.RetVal) {
	var user *termUser
	var exists bool
	if user, exists = tc.getUserInfo(u); !exists {
		return "", robot.UserNotFound
	}
	switch attr {
	case "email":
		return user.Email, robot.Ok
	case "internalid":
		return user.InternalID, robot.Ok
	case "realname", "fullname", "real name", "full name":
		return user.FullName, robot.Ok
	case "firstname", "first name":
		return user.FirstName, robot.Ok
	case "lastname", "last name":
		return user.LastName, robot.Ok
	case "phone":
		return user.Phone, robot.Ok
	// that's all the attributes we can currently get from slack
	default:
		return "", robot.AttributeNotFound
	}
}

// SendProtocolChannelThreadMessage sends a message to a channel
func (tc *termConnector) SendProtocolChannelThreadMessage(ch, thr, msg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	channel := tc.getChannel(ch)
	return tc.sendMessage(channel, thr, msg, f)
}

// SendProtocolChannelMessage sends a message to a channel
func (tc *termConnector) SendProtocolUserChannelThreadMessage(uid, uname, ch, thr, msg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	channel := tc.getChannel(ch)
	msg = "@" + uname + " " + msg
	return tc.sendMessage(channel, thr, msg, f)
}

// SendProtocolUserMessage sends a direct message to a user
func (tc *termConnector) SendProtocolUserMessage(u string, msg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	var user *termUser
	var exists bool
	if user, exists = tc.getUserInfo(u); !exists {
		return robot.UserNotFound
	}
	return tc.sendMessage(fmt.Sprintf("(dm:%s)", user.Name), "", msg, f)
}

// JoinChannel joins a channel given it's human-readable name, e.g. "general"
// Only useful for connectors that require it, a noop otherwise
func (tc *termConnector) JoinChannel(c string) (ret robot.RetVal) {
	return robot.Ok
}

// FormatHelp returns a helpline formatted for the terminal connector.
func (tc *termConnector) FormatHelp(input string) string {
	arr := strings.SplitN(input, " - ", 2)
	if len(arr) != 2 {
		return "*" + input + "*"
	}
	return "*" + arr[0] + "* - " + arr[1]
}

// DefaultHelp returns an empty array (no override)
func (tc *termConnector) DefaultHelp() []string {
	return []string{}
}
</file_content file: gopherbot-main/bot/term_connector.go>
<preamble file: gopherbot-main/bot/term_sendmessage.go>

</preamble>
<file_content file: gopherbot-main/bot/term_sendmessage.go>
//go:build !test
// +build !test

package bot

import (
	"fmt"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

func (tc *termConnector) sendMessage(ch, thr, msg string, f robot.MessageFormat) (ret robot.RetVal) {
	tc.checkSendSelf(ch, thr, msg, f)
	found := false
	tc.RLock()
	if strings.HasPrefix(ch, "(dm:") {
		found = true
	} else {
		for _, channel := range tc.channels {
			if channel == ch {
				found = true
				break
			}
		}
	}
	tc.RUnlock()
	if !found {
		tc.Log(robot.Error, "Channel not found:", ch)
		return robot.ChannelNotFound
	}
	threadID := ""
	if len(thr) > 0 {
		threadID = fmt.Sprintf("(%s)", thr)
		tc.Lock()
		tc.lastThread = thr
		tc.Unlock()
	}
	output := fmt.Sprintf("%s%s: %s\n", ch, threadID, msg)
	if f != robot.Fixed {
		output = Wrap(output, tc.width)
		tc.reader.Write([]byte(output)[0 : len(output)-1])
	} else {
		tc.reader.Write([]byte(output))
	}
	return robot.Ok
}
</file_content file: gopherbot-main/bot/term_sendmessage.go>
<preamble file: gopherbot-main/bot/term_sendmessage_tbot.go>

</preamble>
<file_content file: gopherbot-main/bot/term_sendmessage_tbot.go>
//go:build test
// +build test

package bot

import (
	"fmt"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

func (tc *termConnector) sendMessage(ch, thr, msg string, f robot.MessageFormat) (ret robot.RetVal) {
	tc.checkSendSelf(ch, thr, msg, f)
	found := false
	tc.RLock()
	if strings.HasPrefix(ch, "(dm:") {
		found = true
	} else {
		for _, channel := range tc.channels {
			if channel == ch {
				found = true
				break
			}
		}
	}
	tc.RUnlock()
	if !found {
		tc.Log(robot.Error, "Channel not found:", ch)
		return robot.ChannelNotFound
	}
	threadID := ""
	if len(thr) > 0 {
		threadID = fmt.Sprintf("(%s)", thr)
		tc.Lock()
		tc.lastThread = thr
		tc.Unlock()
	}
	switch f {
	case robot.Fixed:
		msg = strings.ToUpper(msg)
	case robot.Variable:
		msg = strings.ToLower(msg)
	}
	tc.reader.Write([]byte(fmt.Sprintf("%s%s: %s\n", ch, threadID, msg)))
	return robot.Ok
}
</file_content file: gopherbot-main/bot/term_sendmessage_tbot.go>
<preamble file: gopherbot-main/bot/util.go>

</preamble>
<file_content file: gopherbot-main/bot/util.go>
package bot

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	godebug "runtime/debug"
	"strings"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

var idRegex = regexp.MustCompile(`^<(.*)>$`)

// ExtractID is a utility function to check a user/channel string against
// the pattern '<internalID>' and if it matches return the internalID,true;
// otherwise return the unmodified string,false.
func (h handler) ExtractID(u string) (string, bool) {
	matches := idRegex.FindStringSubmatch(u)
	if len(matches) > 0 {
		return matches[1], true
	}
	return u, false
}

var hostName, binDirectory string

func init() {
	var err error
	// Installpath is where the default config and stock external
	// plugins are.
	ex, err := os.Executable()
	if err != nil {
		panic(err)
	}
	binDirectory, err = filepath.Abs(filepath.Dir(ex))
	if err != nil {
		panic(err)
	}
}

func bracket(s string) string {
	return "<" + s + ">"
}

func checkPanic(w *worker, s string) {
	if rcv := recover(); rcv != nil {
		Log(robot.Error, "PANIC from '%s': %s\nStack trace:%s", s, rcv, godebug.Stack())
		w.Reply("OUCH! It looks like you found a bug - please ask an admin to check the log and give them this string: '%s'", s)
		time.Sleep(2 * time.Second)
		os.Exit(1)
	}
}

func checkDirectory(cpath string) (string, bool) {
	if len(cpath) == 0 {
		return "", true
	}
	var filePath string
	if filepath.IsAbs(cpath) {
		filePath = filepath.Clean(cpath)
	} else {
		filePath = cpath
	}
	ds, err := os.Stat(filePath)
	if err != nil {
		Log(robot.Debug, "Checking os.Stat for dir '%s' from wd '%s': %v", cpath, homePath, err)
		return "", false
	}
	if ds.Mode().IsDir() {
		return filePath, true
	}
	Log(robot.Debug, "IsDir() for dir '%s' from wd '%s' returned false", cpath, homePath)
	return "", false
}

// getObjectPath looks for an object first in the custom config dir, then
// the install dir.
func getObjectPath(path string) (opath string, info fs.FileInfo, err error) {
	if filepath.IsAbs(path) {
		opath = path
		info, err = os.Stat(opath)
		if err == nil {
			Log(robot.Debug, "Using fully specified path to object: %s", opath)
			return opath, info, nil
		}
		err = fmt.Errorf("Invalid path for object: %s (%v)", opath, err)
		Log(robot.Error, err.Error())
		return "", nil, err
	}
	if len(configPath) > 0 {
		opath = filepath.Join(configPath, path)
		info, err = os.Stat(opath)
		if err == nil {
			Log(robot.Debug, "Loading object from configPath: %s", opath)
			return opath, info, nil
		}
	}
	opath = filepath.Join(installPath, path)
	if info, err = os.Stat(opath); err == nil {
		Log(robot.Debug, "Loading object from installPath: %s", opath)
		return opath, info, nil
	}
	return "", nil, err
}

func setFormat(format string) robot.MessageFormat {
	format = strings.ToLower(format)
	switch format {
	case "fixed":
		return robot.Fixed
	case "variable":
		return robot.Variable
	case "raw":
		return robot.Raw
	default:
		Log(robot.Error, "Unknown message format '%s', defaulting to 'raw'", format)
		return robot.Raw
	}
}

// getProtocol takes a string name of the protocol and returns the constant and
// the name of the loadable module, if any.
func getProtocol(proto string) robot.Protocol {
	proto = strings.ToLower(proto)
	switch proto {
	case "slack":
		return robot.Slack
	case "term", "terminal":
		return robot.Terminal
	case "nullconn":
		return robot.Null
	case "rocket":
		return robot.Rocket
	default:
		return robot.Test
	}
}
</file_content file: gopherbot-main/bot/util.go>
<preamble file: gopherbot-main/bot/wrap.go>

</preamble>
<file_content file: gopherbot-main/bot/wrap.go>
package bot

/*
MIT License

Copyright (c) 2017 Ben Brooks

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import (
	"strings"
	"unicode/utf8"
)

const (
	defaultBreakpoints = " -"
	defaultNewline     = "\n"
)

// Wrapper contains settings for customisable word-wrapping.
type Wrapper struct {
	// Breakpoints defines which characters should be able to break a line.
	// By default, this follows the usual English rules of spaces, and hyphens.
	// Default: " -"
	Breakpoints string

	// Newline defines which characters should be used to split and create new lines.
	// Default: "\n"
	Newline string

	// OutputLinePrefix is prepended to any output lines. This can be useful
	// for wrapping code-comments and prefixing new lines with "// ".
	// Default: ""
	OutputLinePrefix string

	// OutputLineSuffix is appended to any output lines.
	// Default: ""
	OutputLineSuffix string

	// LimitIncludesPrefixSuffix can be set to false if you don't want prefixes
	// and suffixes to be included in the length limits.
	// Default: true
	LimitIncludesPrefixSuffix bool

	// TrimPrefix can be set to remove a prefix on each input line.
	// This can be paired up with OutputPrefix to create a block of C-style
	// comments (/* * */ ) from a long single-line comment.
	// Default: ""
	TrimInputPrefix string

	// TrimSuffix can be set to remove a suffix on each input line.
	// Default: ""
	TrimInputSuffix string

	// StripTrailingNewline can be set to true if you want the trailing
	// newline to be removed from the return vailue.
	// Default: false
	StripTrailingNewline bool
}

// NewWrapper returns a new instance of a Wrapper initialised with defaults.
func NewWrapper() Wrapper {
	return Wrapper{
		Breakpoints:               defaultBreakpoints,
		Newline:                   defaultNewline,
		LimitIncludesPrefixSuffix: true,
	}
}

// Wrap is shorthand for declaring a new default Wrapper calling its Wrap method
func Wrap(s string, limit int) string {
	return NewWrapper().Wrap(s, limit)
}

// Wrap will wrap one or more lines of text at the given length.
// If limit is less than 1, the string remains unwrapped.
func (w Wrapper) Wrap(s string, limit int) string {

	// Subtract the length of the prefix and suffix from the limit
	// so we don't break length limits when using them.
	if w.LimitIncludesPrefixSuffix {
		limit -= utf8.RuneCountInString(w.OutputLinePrefix) + utf8.RuneCountInString(w.OutputLineSuffix)
	}

	var ret string
	for _, str := range strings.Split(s, w.Newline) {
		str = strings.TrimPrefix(str, w.TrimInputPrefix)
		str = strings.TrimSuffix(str, w.TrimInputSuffix)
		ret += w.line(str, limit) + w.Newline
	}

	if w.StripTrailingNewline {
		return strings.TrimSuffix(ret, w.Newline)
	}
	return ret
}

// line will wrap a single line of text at the given length.
// If limit is less than 1, the string remains unwrapped.
func (w Wrapper) line(s string, limit int) string {
	if limit < 1 || utf8.RuneCountInString(s) < limit+1 {
		return w.OutputLinePrefix + s + w.OutputLineSuffix
	}

	// Find the index of the last breakpoint within the limit.
	i := strings.LastIndexAny(s[:limit+1], w.Breakpoints)

	// Can't wrap within the limit, wrap at the next breakpoint instead.
	if i < 0 {
		i = strings.IndexAny(s, w.Breakpoints)
		// Nothing left to do!
		if i < 0 {
			return w.OutputLinePrefix + s + w.OutputLineSuffix
		}
	}

	// Recurse until we have nothing left to do.
	return w.OutputLinePrefix + s[:i] + w.OutputLineSuffix + w.Newline + w.line(s[i+1:], limit)
}
</file_content file: gopherbot-main/bot/wrap.go>
<preamble file: gopherbot-main/brains/dynamodb/dynamobrain.go>

</preamble>
<file_content file: gopherbot-main/brains/dynamodb/dynamobrain.go>
// Package dynamobrain is a simple AWS DynamoDB implementation of the bot.SimpleBrain
// interface, which gives the robot a place to permanently store it's memories.
package dynamobrain

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/lnxjedi/gopherbot/robot"
)

var handler robot.Handler
var svc *dynamodb.DynamoDB

type brainConfig struct {
	TableName, Region, AccessKeyID, SecretAccessKey string
}

type dynaMemory struct {
	Memory  string
	Content []byte
}

var dynamocfg brainConfig

func (db *brainConfig) Store(k string, b *[]byte) error {
	input := &dynamodb.PutItemInput{
		Item: map[string]*dynamodb.AttributeValue{
			"Memory": {
				S: aws.String(k),
			},
			"Content": {
				B: *b,
			},
		},
		TableName: aws.String(dynamocfg.TableName),
	}

	_, err := svc.PutItem(input)
	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case dynamodb.ErrCodeConditionalCheckFailedException:
				handler.Log(robot.Error, "Error storing memory: %v, %v", dynamodb.ErrCodeConditionalCheckFailedException, aerr.Error())
			case dynamodb.ErrCodeProvisionedThroughputExceededException:
				handler.Log(robot.Error, "Error storing memory: %v, %v", dynamodb.ErrCodeProvisionedThroughputExceededException, aerr.Error())
			case dynamodb.ErrCodeResourceNotFoundException:
				handler.Log(robot.Error, "Error storing memory: %v, %v", dynamodb.ErrCodeResourceNotFoundException, aerr.Error())
			case dynamodb.ErrCodeItemCollectionSizeLimitExceededException:
				handler.Log(robot.Error, "Error storing memory: %v, %v", dynamodb.ErrCodeItemCollectionSizeLimitExceededException, aerr.Error())
			case dynamodb.ErrCodeInternalServerError:
				handler.Log(robot.Error, "Error storing memory: %v, %v", dynamodb.ErrCodeInternalServerError, aerr.Error())
			default:
				handler.Log(robot.Error, "Error storing memory: %v", aerr.Error())
			}
			return aerr
		}
		// Print the error, cast err to awserr.Error to get the Code and
		// Message from an error.
		handler.Log(robot.Error, "Error storing memory: %v", err.Error())
		return err
	}

	return nil
}

func (db *brainConfig) Retrieve(k string) (datum *[]byte, exists bool, err error) {
	consistent := true
	result, err := svc.GetItem(&dynamodb.GetItemInput{
		TableName: aws.String(dynamocfg.TableName),
		Key: map[string]*dynamodb.AttributeValue{
			"Memory": {
				S: aws.String(k),
			},
		},
		ConsistentRead: &consistent,
	})

	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case dynamodb.ErrCodeProvisionedThroughputExceededException:
				handler.Log(robot.Error, "Error retrieving memory: %v, %v", dynamodb.ErrCodeProvisionedThroughputExceededException, aerr.Error())
			case dynamodb.ErrCodeResourceNotFoundException:
				handler.Log(robot.Error, "Error retrieving memory: %v, %v", dynamodb.ErrCodeResourceNotFoundException, aerr.Error())
			case dynamodb.ErrCodeInternalServerError:
				handler.Log(robot.Error, "Error retrieving memory: %v, %v", dynamodb.ErrCodeInternalServerError, aerr.Error())
			default:
				handler.Log(robot.Error, "Error retrieving memory: %v", aerr.Error())
			}
			return nil, false, aerr
		}
		handler.Log(robot.Error, "Error retrieving memory: %v", err.Error())
		return nil, false, err
	}

	m := dynaMemory{}

	err = dynamodbattribute.UnmarshalMap(result.Item, &m)

	if err != nil {
		handler.Log(robot.Error, "Failed to unmarshal Record, %v", err)
		return nil, false, err
	}

	if m.Memory == "" {
		return nil, false, nil
	}

	return &m.Content, true, nil
}

func (db *brainConfig) Delete(key string) error {
	delete := &dynamodb.DeleteItemInput{
		Key: map[string]*dynamodb.AttributeValue{
			"Memory": {
				S: aws.String(key),
			},
		},
		TableName: aws.String(dynamocfg.TableName),
	}
	_, err := svc.DeleteItem(delete)
	return err
}

func (db *brainConfig) List() ([]string, error) {
	keys := make([]string, 0)
	keyName := "Memory"
	scan := &dynamodb.ScanInput{
		ProjectionExpression: &keyName,
		TableName:            aws.String(dynamocfg.TableName),
	}
	res, err := svc.Scan(scan)
	if err != nil {
		return keys, err
	}
	for _, av := range res.Items {
		for _, item := range av {
			var m string
			err := dynamodbattribute.Unmarshal(item, &m)
			if err != nil {
				return keys, err
			}
			keys = append(keys, m)
		}
	}
	return keys, nil
}

func provider(r robot.Handler) robot.SimpleBrain {
	handler = r
	handler.GetBrainConfig(&dynamocfg)
	var sess *session.Session
	var err error
	AccessKeyID := dynamocfg.AccessKeyID
	SecretAccessKey := dynamocfg.SecretAccessKey
	// ec2 provided credentials
	if len(AccessKeyID) == 0 {
		sess, err = session.NewSession(&aws.Config{
			Region: aws.String(dynamocfg.Region),
		})
		if err != nil {
			handler.Log(robot.Fatal, "Unable to establish AWS session: %v", err)
		}
	} else {
		sess, err = session.NewSession(&aws.Config{
			Region:      aws.String(dynamocfg.Region),
			Credentials: credentials.NewStaticCredentials(AccessKeyID, SecretAccessKey, ""),
		})
		if err != nil {
			handler.Log(robot.Fatal, "Unable to establish AWS session: %v", err)
		}
	}
	// Create DynamoDB client
	svc = dynamodb.New(sess)
	input := &dynamodb.DescribeTableInput{
		TableName: aws.String(dynamocfg.TableName),
	}
	_, err = svc.DescribeTable(input)
	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case dynamodb.ErrCodeResourceNotFoundException:
				handler.Log(robot.Fatal, "Error describing table '%s': %v, %v", dynamocfg.TableName, dynamodb.ErrCodeResourceNotFoundException, aerr.Error())
			case dynamodb.ErrCodeInternalServerError:
				handler.Log(robot.Fatal, "Error describing table '%s': %v, %v", dynamocfg.TableName, dynamodb.ErrCodeInternalServerError, aerr.Error())
			default:
				handler.Log(robot.Fatal, "Error describing table '%s': %v", dynamocfg.TableName, aerr.Error())
			}
		} else {
			handler.Log(robot.Fatal, "Error describing table '%s': %v", dynamocfg.TableName, err.Error())
		}
	}

	return &dynamocfg
}
</file_content file: gopherbot-main/brains/dynamodb/dynamobrain.go>
<preamble file: gopherbot-main/brains/dynamodb/static.go>

</preamble>
<file_content file: gopherbot-main/brains/dynamodb/static.go>
package dynamobrain

import "github.com/lnxjedi/gopherbot/v2/bot"

func init() {
	bot.RegisterSimpleBrain("dynamo", provider)
}
</file_content file: gopherbot-main/brains/dynamodb/static.go>
<preamble file: gopherbot-main/cbot.sh>

</preamble>
<file_content file: gopherbot-main/cbot.sh>
#!/bin/bash -e

# cbot.sh - Script to simplify running Gopherbot containers

IMAGE_NAME="ghcr.io/lnxjedi/gopherbot"
IMAGE_TAG="latest"

usage() {
    cat <<EOF
Usage: ./cbot.sh <command> (options...) (arguments...)
Use './cbot.sh <command> -h' for help on a given command.
Commands:
- preview: launch the preview for a terminal interface to the default robot
- profile <robotname> <fullname> <email>: generate a robot development profile
- pull: pull the latest docker images
- start <robot.env>: start a development (or production) robot container
- stop <robot.env>: stop a robot container
- remove <robot.env>: stop and remove a robot container
- terminal <robot.env>: shell in to the robot's container
- update: download the latest version of this script from github
- list: generate a list of robot containers
EOF
}

if [ $# -lt 1 ]
then
    usage
    exit 0
fi

COMMAND="$1"
shift

get_access() {
    echo "http://localhost:7777/?workspace=/home/bot/gopherbot.code-workspace&tkn=$RANDOM_TOKEN"
}

show_access() {
    local ENV_TYPE="dev"
    if [ "$1" == "-p" ]
    then
        ENV_TYPE="preview"
        shift
    fi
    GENERATED=$(get_access)
    local ACCESS_URL=${1:-$GENERATED}
    echo "Access your $ENV_TYPE environment at: $ACCESS_URL"
}

check_profile() {
    if [ ! "$GOPHER_PROFILE" ]
    then
        echo "Missing profile argument"
        exit 1
    fi

    if [ ! -e "$GOPHER_PROFILE" ]
    then
        # Check for ${GOPHER_PROFILE}.env file
        if [ -e "${GOPHER_PROFILE}.env" ]
        then
            GOPHER_PROFILE="${GOPHER_PROFILE}.env"
        else
            echo "No profile found for ${GOPHER_PROFILE}"
            exit 1
        fi
    fi
}

read_profile() {
    for CFG_VAR in CONTAINERNAME SSH_KEY_PATH FORWARD_SSH
    do
        RAW=$(grep "^#|$CFG_VAR" $GOPHER_PROFILE)
        echo "${CFG_VAR}=${RAW#*=}"
    done
}

wait_for_container() {
    # Give it a minute to start running
    for TRY in {1..60}
    do
        if [ "`docker inspect -f {{.State.Running}} $CONTAINERNAME`"=="true" ]
        then
            SUCCESS="true"
            break
        fi
        sleep 1
    done
}

copy_ssh() {
    echo "Copying $SSH_KEY_PATH to $CONTAINERNAME:/home/bot/.ssh/id_ssh ..."
    docker cp "$SSH_KEY_PATH" $CONTAINERNAME:/home/bot/.ssh/id_ssh
    docker exec -it -u root $CONTAINERNAME /bin/bash -c "chown bot:bot /home/bot/.ssh/id_ssh; chmod 0600 /home/bot/.ssh/id_ssh"
}

update_container_uid() {
    EXTERNAL_UID=$(id -u)
    EXTERNAL_GID=$(id -g)
    echo "Updating the container for forwarding the local ssh-agent ..."
    docker exec -u root $CONTAINERNAME /bin/sh -c "sed -i 's/^bot:x:[0-9]*:[0-9]*:/bot:x:$EXTERNAL_UID:$EXTERNAL_GID:/' /etc/passwd"
    docker exec -u root $CONTAINERNAME /bin/sh -c "sed -i 's/^bot:x:[0-9]*:/bot:x:$EXTERNAL_GID:/' /etc/group"
    docker exec -u root $CONTAINERNAME chown -R $EXTERNAL_UID:$EXTERNAL_GID /home/bot /opt
}

case $COMMAND in
profile )
    while getopts ":hfk:" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Generate a profile for working with a gopherbot robot container:
./cbot.sh profile (-k path/to/ssh/private/key) <container-name> "<full name>" <email>
 -k (path) - Load an ssh private key when using this profile
 -f        - Forward the local ssh-agent when using this profile

Example:
$ ./cbot.sh profile -k ~/.ssh/id_rsa bishop "David Parsley" parsley@linuxjedi.org | tee bishop.env
## Lines starting with #| are used by the cbot.sh script
GIT_AUTHOR_NAME="David Parsley"
GIT_AUTHOR_EMAIL=parsley@linuxjedi.org
GIT_COMMITTER_NAME="David Parsley"
GIT_COMMITTER_EMAIL=parsley@linuxjedi.org
#|CONTAINERNAME=bishop
#|SSH_KEY_PATH=/home/david/.ssh/id_rsa
## Items needed for bootstrapping an existing robot
#GOPHER_ENCRYPTION_KEY=<key>
#GOPHER_CUSTOM_REPOSITORY=<git@...> # ssh URL for repo
#GOPHER_PROTOCOL=slack              # if you need to override
#GOPHER_DEPLOY_KEY=<key>
EOF
            exit 0
            ;;
        k )
            SSH_KEY_PATH="$OPTARG"
            ;;
        f )
            FORWARD_SSH="true"
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    shift $((OPTIND -1))
    if [ $# -ne 3 ]
    then
        echo "Wrong number of arguments"
        usage
        exit 1
    fi
    CONTAINERNAME="$1"
    GIT_USER="$2"
    GIT_EMAIL="$3"
    cat <<EOF
## Lines starting with #| are used by the cbot.sh script
GIT_AUTHOR_NAME="${GIT_USER}"
GIT_AUTHOR_EMAIL=${GIT_EMAIL}
GIT_COMMITTER_NAME="${GIT_USER}"
GIT_COMMITTER_EMAIL=${GIT_EMAIL}
#|CONTAINERNAME=${CONTAINERNAME}
## Items needed for bootstrapping an existing robot
#GOPHER_ENCRYPTION_KEY=<key>
#GOPHER_CUSTOM_REPOSITORY=<git@...> # ssh URL for repo
#GOPHER_PROTOCOL=slack              # if you need to override
#GOPHER_DEPLOY_KEY=<key>
EOF
    if [ "$SSH_KEY_PATH" ]
    then
        echo "#|SSH_KEY_PATH=${SSH_KEY_PATH}"
    fi
    if [ "$FORWARD_SSH" ]
    then
        echo "#|FORWARD_SSH=true"
    fi
    exit 0
    ;;
list | ls )
    while getopts ":h" OPT; do
        case $OPT in
        h ) cat <<"EOF"
List all robot containers:
./cbot.sh list

Example:
$ ./cbot.sh list
CONTAINER ID   STATUS             NAMES        environment         access
0f50a4ce6b2a   Up 37 seconds      bishop-dev   robot/development   http://localhost:7777/?workspace=/home/bot/gopherbot.code-workspace&tkn=XXXXXXX
1c470fd80c31   Up About an hour   clu          robot/production
EOF
            exit 0
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    docker ps -a --filter "label=type=gopherbot/robot" --format "table {{.ID}}\t{{.Status}}\t{{.Names}}\t{{.Label \"environment\"}}\t{{.Label \"access\"}}"
    ;;
remove | rm )
    while getopts ":hp" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Stop and remove a container:
./cbot.sh remove (path/to/profile)
 -p - remove a production robot

Example:
$ ./cbot.sh remove bishop.env
EOF
            exit 0
            ;;
        p )
            PROD="true"
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    shift $((OPTIND -1))
    GOPHER_PROFILE=$1
    check_profile
    eval `read_profile`
    if [ ! "$PROD" ]
    then
        CONTAINERNAME="$CONTAINERNAME-dev"
    fi
    docker stop $CONTAINERNAME >/dev/null && docker rm $CONTAINERNAME >/dev/null
    echo "Removed"
    exit 0
    ;;
stop )
    while getopts ":hp" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Stop a robot container:
./cbot.sh stop (-p) (path/to/profile)
 -p - stop a production robot

Example:
$ ./cbot.sh stop bishop.env
EOF
            exit 0
            ;;
        p )
            PROD="true"
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    shift $((OPTIND -1))
    GOPHER_PROFILE=$1
    check_profile
    eval `read_profile`
    if [ ! "$PROD" ]
    then
        CONTAINERNAME="$CONTAINERNAME-dev"
    fi
    docker stop $CONTAINERNAME >/dev/null
    echo "Stopped"
    exit 0
    ;;
term | terminal )
    while getopts ":hrp" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Shell in to a robot container:
./cbot.sh term (-p) (-r) (path/to/profile)
 -p - look for a production container
 -r - connect as the "root" user

Example:
$ ./cbot.sh term -r bishop.env
EOF
            exit 0
            ;;
        p )
            PROD="true"
            ;;
        r )
            DOCKUSER="-u root"
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    shift $((OPTIND -1))
    GOPHER_PROFILE=$1
    check_profile
    eval `read_profile`
    if [ ! "$PROD" ]
    then
        CONTAINERNAME="$CONTAINERNAME-dev"
    fi
    echo "Starting shell session in the $CONTAINERNAME container ..."
    exec docker exec -it $DOCKUSER $CONTAINERNAME /bin/bash
    ;;
pull )
    while getopts ":h" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Pull the most recent development and production gopherbot containers:
./cbot.sh pull

Example:
$ ./cbot.sh pull
latest: Pulling from lnxjedi/gopherbot-dev
...
EOF
            exit 0
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    docker pull ${IMAGE_NAME}-dev:${IMAGE_TAG}
    docker pull ${IMAGE_NAME}:${IMAGE_TAG}
    exit 0
    ;;
update )
    while getopts ":h" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Download the latest version of the cbot.sh script, replacing the current version:
./cbot.sh update

Example:
$ ./cbot.sh update
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 12443  100 12443    0     0   276k      0 --:--:-- --:--:-- --:--:--  282k
EOF
            exit 0
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    ## Thanks, OpenAI text-davinci-003!
    # This wasn't added by OpenAI, but it seemed like a good idea to me
    unlink ${BASH_SOURCE[0]}
    # Download the new version of the script directly to the script path
    curl -L "https://raw.githubusercontent.com/lnxjedi/gopherbot/main/cbot.sh" -o ${BASH_SOURCE[0]}

    # Make the script executable
    chmod +x ${BASH_SOURCE[0]}
    exit 0
    ;;
preview )
    CONTAINERNAME='floyd-gopherbot-preview'
    while getopts ":hru" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Preview the Gopherbot IDE and Floyd, the default robot:
./cbot.sh preview (-u) (-r)
 -u - pull the latest container version first
 -r - stop and remove the preview container
(Note: you'll need to connect to the localhost interface, open a terminal,
and run 'gopherbot')
EOF
            exit 0
            ;;
        r )
            docker stop $CONTAINERNAME >/dev/null && docker rm $CONTAINERNAME >/dev/null
            echo "Removed"
            exit 0
            ;;
        u )
            PULL="true"
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done

    if STATUS=$(docker inspect -f {{.State.Status}} $CONTAINERNAME 2>/dev/null)
    then
        echo "(found existing container '$CONTAINERNAME', re-using)"
        if [ "$STATUS" == "exited" ]
        then
            echo "Starting '$CONTAINERNAME':"
            docker start $CONTAINERNAME
            wait_for_container
            if [ ! "$SUCCESS" ]
            then
                echo "Timed out waiting for container to start"
                exit 1
            fi
        fi
        ACCESS_URL=$(docker inspect --format='{{index .Config.Labels "access"}}' $CONTAINERNAME)
        RANDOM_TOKEN=${ACCESS_URL##*=}
        show_access $ACCESS_URL
        exit 0
    fi

    if [ "$PULL" ]
    then
        docker pull $IMAGE_SPEC
    fi

    echo "Running '$CONTAINERNAME':"

    IMAGE_NAME="$IMAGE_NAME-dev"
    IMAGE_SPEC="$IMAGE_NAME:$IMAGE_TAG"

    RANDOM_TOKEN="$(openssl rand -hex 21)"
    docker run -d \
        -p 127.0.0.1:7777:7777 \
        -l type=gopherbot/robot \
        -l environment=robot/preview \
        -l access=$(get_access) \
        --name $CONTAINERNAME $IMAGE_SPEC \
        --connection-token $RANDOM_TOKEN
    wait_for_container
    if [ ! "$SUCCESS" ]
    then
        echo "Timed out waiting for container to start"
        exit 1
    fi

    show_access -p
    ;;
start )
    while getopts ":hup" OPT; do
        case $OPT in
        h ) cat <<"EOF"
Start a robot container:
./cbot.sh start (-u) (-p) (path/to/profile)
 -u - pull the latest container version first
 -p - start a production robot (minimal image)

Example:
$ ./cbot.sh start bishop.env
Running 'bishop':
Unable to find image 'ghcr.io/lnxjedi/gopherbot-dev:latest' locally
latest: Pulling from lnxjedi/gopherbot-dev
...
Copying /home/david/.ssh/id_rsa to bishop:/home/bot/.ssh/id_ssh ...
Access your dev environment at: http://localhost:7777/?workspace=/home/bot/gopherbot.code-workspace&tkn=XXXXXXX
EOF
            exit 0
            ;;
        u )
            PULL="true"
            ;;
        p )
            PROD="true"
            ;;
        \?)
            [ "$OPT" != "h" ] && echo "Invalid option: $OPTARG"
            usage
            exit 0
            ;;
        esac
    done
    shift $((OPTIND -1))

    GOPHER_PROFILE=$1
    check_profile
    eval `read_profile`

    if [ ! "$PROD" ]
    then
        IMAGE_NAME="$IMAGE_NAME-dev"
        CONTAINERNAME="$CONTAINERNAME-dev"
    fi
    IMAGE_SPEC="$IMAGE_NAME:$IMAGE_TAG"

    if STATUS=$(docker inspect -f {{.State.Status}} $CONTAINERNAME 2>/dev/null)
    then
        echo "(found existing container '$CONTAINERNAME', re-using)"
        if [ "$STATUS" == "exited" ]
        then
            echo "Starting '$CONTAINERNAME':"
            docker start $CONTAINERNAME
            wait_for_container
            if [ ! "$SUCCESS" ]
            then
                echo "Timed out waiting for container to start"
                exit 1
            fi
        fi
        if [ "$PROD" ]
        then
            echo "... started"
        else
            if [ "$SSH_KEY_PATH" ]
            then
                copy_ssh
            fi
            ACCESS_URL=$(docker inspect --format='{{index .Config.Labels "access"}}' $CONTAINERNAME)
            RANDOM_TOKEN=${ACCESS_URL##*=}
            show_access $ACCESS_URL
        fi
        exit 0
    fi

    if [ "$PULL" ]
    then
        docker pull $IMAGE_SPEC
    fi

    echo "Running '$CONTAINERNAME':"

    if [ "$PROD" ]
    then
        docker run -d \
            --env-file $GOPHER_PROFILE \
            -l type=gopherbot/robot \
            -l environment=robot/production \
            --name $CONTAINERNAME $IMAGE_SPEC
    else
        RANDOM_TOKEN="$(openssl rand -hex 21)"
        if [ "$FORWARD_SSH" ]
        then
            EXTERNAL_UID=$(id -u)
            EXTERNAL_GID=$(id -g)
            SSH_FORWARDING="-u $EXTERNAL_UID:$EXTERNAL_GID -v $(readlink -f $SSH_AUTH_SOCK):/ssh-agent -e SSH_AUTH_SOCK=/ssh-agent"
        else
            CONTAINER_COMMAND=ssh-agent
        fi

        docker run -d $SSH_FORWARDING \
            -p 127.0.0.1:7777:7777 \
            -p 127.0.0.1:8888:8888 \
            --env-file $GOPHER_PROFILE \
            --entrypoint /usr/bin/tini \
            -e GOPHER_IDE="$CONTAINERNAME" \
            -l type=gopherbot/robot \
            -l environment=robot/development \
            -l access=$(get_access) \
            --name $CONTAINERNAME $IMAGE_SPEC \
            -- $CONTAINER_COMMAND /bin/sh -c \
            "exec \${OPENVSCODE_SERVER_ROOT}/bin/openvscode-server --host 0.0.0.0 --port 7777 --connection-token=$RANDOM_TOKEN"
    fi
    wait_for_container
    if [ ! "$SUCCESS" ]
    then
        echo "Timed out waiting for container to start"
        exit 1
    fi

    if [ ! "$PROD" ]
    then
        if [ "$SSH_KEY_PATH" ]
        then
            copy_ssh
        elif [ "$FORWARD_SSH" ]
        then
            update_container_uid
        fi
        show_access
    fi
    ;;
* )
    echo "Invalid command: $COMMAND"
    usage
    exit 1
esac
</file_content file: gopherbot-main/cbot.sh>
<preamble file: gopherbot-main/changelog.txt>

</preamble>
<file_content file: gopherbot-main/changelog.txt>
=== 1.1.0-snapshot ===
2018-03-18 David Parsley <parsley@linuxjedi.org>
  * Add terminal connector for local bot operation, testing and development

2018-03-21 David Parsley <parsley@linuxjedi.org>
  * Make local config directory optional, for quicker quick starts

=== 1.0.0-snapshot ===
2018-03-11 David Parsley <parsley@linuxjedi.org>
  * Switch to CircleCI after Travis broke
  * Added missing methods in script libraries

2018-02-28 David Parsley <parsley@linuxjedi.org>
  * Windows config dir search path is now only 'C:\ProgramData\Gopherbot'

2018-02-10 David Parsley <parsley@linuxjedi.org>
  * Started using Travis CI, deploying snapshot releases

2017-05-23 David Parsley <parsley@linuxjedi.org>
  * [Breaking] Fix WaitForReply - replace with Prompt(User)ForReply

    The old WaitForReply* methods had a fatal flaw - they couldn't deal
    with multiple simultaneous plugins doing WaitForReply at the same
    time. If you asked the robot to tell you a joke twice in quick
    succession, it would crash. After giving this lots of thought, I
    made the difficult decision to replace WaitForReply* with
    PromptForReply and PromptUserForReply.

    Now, The first plugin to call Prompt*ForReply will have it's
    prompt sent and reply returned; any other Prompt*ForReply won't
    have their prompts displayed, and will get RetryPrompt returned.
    The library will automatically retry three times, and will
    return Interrupted after 3 RetryPrompt - so plugins shouldn't
    check for that value.

  * [Breaking] Go plugins now return a TaskRetVal (integer), required

  * Added new type of plugin: Authorizer, for performing authorization
    decisions, using plugin return values

  * [Breaking] Elevators are now normal plugins, and configured with normal
    plugin "Config:" stanza. See Configuration.md for information on configuring
    elevators.

=== Released 0.9.0 ===

2017-05-01 David Parsley <parsley@linuxjedi.org>

  * Add links plugin, fix and improve lists plugin

  * Fixed scrolling in Slack by adding message sending pause; also added
  typing notifier

2017-04-21 David Parsley <parsley@linuxjedi.org>

  * The list of Users for a plugin can now contain globbing patterns

  * All libraries now use a 'gopherbot_vX.foo' name format, in preparation
  for future versions of plugin libraries

  * Add support for hearing app/bot users in Slack connector. Note that apps
  aren't guaranteed to have unique names, so the User value sent is
  "bot:<non-unique name>:<unique bot ID>"; e.g. "bot:AWS notifier:BFOOBARBAZ";
  this can be matched with a User of 'bot:*', or 'bot:AWS notifier:*', or
  'bot:AWS notifier:BFOOBARBAZ'
</file_content file: gopherbot-main/changelog.txt>
<preamble file: gopherbot-main/conf/README.md>

</preamble>
<file_content file: gopherbot-main/conf/README.md>
This directory contains default configuration for Gopherbot, and defines a **default robot**, *Floyd*. Your robot's custom configuration overrides configuration here.
</file_content file: gopherbot-main/conf/README.md>
<preamble file: gopherbot-main/conf/jobs/backup.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/backup.yaml>
---
RequireAdmin: true
AllowDirect: true
Quiet: true
KeepLogs: 2
</file_content file: gopherbot-main/conf/jobs/backup.yaml>
<preamble file: gopherbot-main/conf/jobs/changebranch.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/changebranch.yaml>
---
RequireAdmin: true
AllowDirect: true
KeepLogs: 2
Quiet: true
</file_content file: gopherbot-main/conf/jobs/changebranch.yaml>
<preamble file: gopherbot-main/conf/jobs/github-poller.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/github-poller.yaml>
---
Quiet: true
# You should keep a few logs at least in case there are errors
KeepLogs: 7
</file_content file: gopherbot-main/conf/jobs/github-poller.yaml>
<preamble file: gopherbot-main/conf/jobs/gopherci.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/gopherci.yaml>
---
# GopherCI will spawn a build job.
#Triggers:
## Github example
#- User: github
#  Channel: dev
#  Regex: 'new commit.*(github.com\/.*)\/tree\/(.*)\|'

# Arguments to be supplied with `run job`
Quiet: true
Arguments:
- Label: repository
  Regex: '[\w-.]+\/[\w-.]+\/[\w-.]+\/?'
- Label: branch
  Regex: '[\w-.]+'
</file_content file: gopherbot-main/conf/jobs/gopherci.yaml>
<preamble file: gopherbot-main/conf/jobs/localbuild.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/localbuild.yaml>
---
Quiet: true
KeepLogs: 7
</file_content file: gopherbot-main/conf/jobs/localbuild.yaml>
<preamble file: gopherbot-main/conf/jobs/pause-notifies.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/pause-notifies.yaml>
---
Quiet: true
</file_content file: gopherbot-main/conf/jobs/pause-notifies.yaml>
<preamble file: gopherbot-main/conf/jobs/restore.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/restore.yaml>
---
RequireAdmin: true
AllowDirect: true
Quiet: true
KeepLogs: 2
</file_content file: gopherbot-main/conf/jobs/restore.yaml>
<preamble file: gopherbot-main/conf/jobs/save.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/save.yaml>
---
RequireAdmin: true
AllowDirect: true
Quiet: true
KeepLogs: 2
</file_content file: gopherbot-main/conf/jobs/save.yaml>
<preamble file: gopherbot-main/conf/jobs/ssh-job.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/ssh-job.yaml>
Quiet: true
KeepLogs: 2
</file_content file: gopherbot-main/conf/jobs/ssh-job.yaml>
<preamble file: gopherbot-main/conf/jobs/theia.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/theia.yaml>
---
Quiet: true
RequireAdmin: true
</file_content file: gopherbot-main/conf/jobs/theia.yaml>
<preamble file: gopherbot-main/conf/jobs/updatecfg.yaml>

</preamble>
<file_content file: gopherbot-main/conf/jobs/updatecfg.yaml>
---
RequireAdmin: true
AllowDirect: true
KeepLogs: 2
Quiet: true
</file_content file: gopherbot-main/conf/jobs/updatecfg.yaml>
<preamble file: gopherbot-main/conf/nullconn.yaml>

</preamble>
<file_content file: gopherbot-main/conf/nullconn.yaml>
## nullconn.yaml - dummy values to squelch errors
AdminUsers: [ "alice" ]
DefaultChannels: [ "general", "random" ]

BotInfo:
  UserName: floyd
  FullName: Floyd Gopherbot

Alias: ;

DefaultJobChannel: general
</file_content file: gopherbot-main/conf/nullconn.yaml>
<preamble file: gopherbot-main/conf/plugins/admin.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/admin.yaml>
---
RequireAdmin: true
AllowDirect: true
AllChannels: true
Help:
- Keywords: [ "config", "configuration", "update" ]
  Helptext: [ "(alias) update (configuration) - perform a git clone/pull of custom configuration and reload" ]
- Keywords: [ "config", "configuration", "branch" ]
  Helptext: [ "(alias) switch-branch <branch> - switch branches in configuration repository" ]
- Keywords: [ "config", "configuration", "save", "admin", "manage" ]
  Helptext: [ "(alias) save (configuration) - git push custom repository" ]
- Keywords: [ "brain", "state", "restore", "admin", "manage" ]
  Helptext: [ "(alias) backup - git push state directory, pausing brain if needed" ]
- Keywords: [ "brain", "state", "restore", "admin", "manage" ]
  Helptext: [ "(alias) (force) restore - restore state directory from git" ]
CommandMatchers:
- Command: "update"
  Regex: '(?i:update(?:[ -]config(?:uration)?)?)'
- Command: "branch"
  Regex: '(?i:(?:switch|change)[ -]branch ([^\s]+))'
- Command: "save"
  Regex: '(?i:save(?:[ -]config(?:uration)?)?)'
- Command: "backup"
  Regex: '(?i:back ?up)'
- Command: "restore"
  Regex: '(?i:(force[ -])?restore)'
</file_content file: gopherbot-main/conf/plugins/admin.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-admin.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-admin.yaml>
---
AllChannels: true
AllowDirect: true
RequireAdmin: true
Help:
- Keywords: [ "reload" ]
  Helptext: [ "(alias) reload - have the robot reload configuration files" ]
- Keywords: [ "quit" ]
  Helptext: [ "(alias) quit - request a graceful shutdown, waiting for all plugins to finish" ]
- Keywords: [ "restart" ]
  Helptext: [ "(alias) restart - request a graceful shutdown and restart" ]
- Keywords: [ "abort" ]
  Helptext: [ "(alias) abort - request an immediate shutdown without waiting for plugins to finish" ]
- Keywords: [ "process", "processes", "ps", "pipeline", "pipelines" ]
  Helptext: [ "(alias) ps - list running pipelines" ]
- Keywords: [ "kill", "process", "job" ]
  Helptext: [ "(alias) kill-pipeline <wid> - kill the current process for the pipeline identified by <wid>"]
- Keywords: [ "pause", "job", "jobs" ]
  Helptext: [ "(alias) pause-job <job> - pause running of <job> as a scheduled task"]
- Keywords: [ "pause", "resume", "job", "jobs", "unpause", "un-pause" ]
  Helptext: [ "(alias) resume-job <job> - resume running of <job> as a scheduled task"]
- Keywords: [ "pause", "resume", "job", "jobs" ]
  Helptext: [ "(alias) paused-jobs - list the paused jobs"]
- Keywords: [ "debug", "log", "channel" ]
  Helptext:
  - "(alias) log-channel (channel) - start a log of the current or given channel"
  - "(alias) stop-channel-logging - stop all channel logging"
CommandMatchers:
- Command: reload
  Regex: '(?i:reload)'
- Command: quit
  Regex: '(?i:quit|exit)'
- Command: restart
  Regex: '(?i:restart)'
- Command: abort
  Regex: '(?i:abort)'
- Command: ps
  Regex: '(?i:ps)'
- Command: "kill"
  Regex: '(?i:kill(?:[- ](?:job|pipeline|process))? ([\d]+))'
- Command: "pause"
  Regex: '(?i:pause(?:[- ]job)? ([A-Za-z][\w-]*))'
- Command: "resume"
  Regex: '(?i:resume(?:[- ]job)? ([A-Za-z][\w-]*))'
- Command: pauselist
  Regex: '(?i:(list[- ])?paused[- ]jobs)'
- Command: "chanlog"
  Regex: '(?i:log[- ]channel(?: ([A-Za-z][\w-]*))?)'
- Command: "stopchanlog"
  Regex: '(?i:stop[- ]channel[- ]logging)'
</file_content file: gopherbot-main/conf/plugins/builtin-admin.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-dmadmin.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-dmadmin.yaml>
---
# builtin-dmadmin plugin configuration - commands only available to bot
# admins via DM
DirectOnly: true
RequireAdmin: true
Help:
- Keywords: [ "dump", "plugin" ]
  Helptext: [ "(alias) dump plugin (default) <plugname> - dump the current or default configuration for the plugin" ]
- Keywords: [ "list", "plugin", "plugins" ]
  Helptext: [ "(alias) list (disabled) plugins - list all known plugins, or list disabled plugins with the reason disabled" ]
- Keywords: [ "dump", "robot" ]
  Helptext: [ "(alias) dump robot - dump the current configuration for the robot" ]
CommandMatchers:
- Command: "listplugins"
  Regex: '(?i:list(?:[- ](disabled))?[- ]plugins?)'
- Command: "dumpplugdefault"
  Regex: '(?i:dump[- ]plugin[- ]default ([\d\w-.]+))'
- Command: "dumpplugin"
  Regex: '(?i:dump[- ]plugin ([\d\w-.]+))'
- Command: "dumprobot"
  Regex: "(?i:dump[- ]robot)"
</file_content file: gopherbot-main/conf/plugins/builtin-dmadmin.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-fallback.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-fallback.yaml>
---
# The default fallback catchall plugin, provides a slightly-helpful
# error message when a user speaks to the robot, but no other command
# matches. Other plugins can take over this function by setting
# CatchAll: true and providing specific channels, or for DMs by
# setting AllowDirect: false.
AllChannels: true
CatchAll: true
AllowDirect: true
AllowedHiddenCommands:
- catchall
</file_content file: gopherbot-main/conf/plugins/builtin-fallback.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-help.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-help.yaml>
---
AllChannels: true
Help:
- Keywords: [ "info", "information", "robot", "admin", "administrators" ]
  Helptext: [ "(alias) info | tell me about yourself - provide useful information for admins, or a list of admins" ]
- Keywords: [ "*", "help" ]
  Helptext:
  - "(alias) help <keyword> - find help for commands matching <keyword>"
  - "(alias) help - help for commands specific to this channel"
CommandMatchers:
- Command: help
  Regex: '(?i:help(?: ([^\s]+))?)'
- Command: help-all
  Regex: '(?i:help-all)'
- Command: info
  Regex: '(?i:info|tell me about yourself|about|information)'
AllowedHiddenCommands:
- help
- help-all
- info
</file_content file: gopherbot-main/conf/plugins/builtin-help.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-history.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-history.yaml>
---
AllChannels: true
AllowDirect: false
Help:
- Keywords: [ "history", "job", "mail", "email", "send", "log", "logs" ]
  Helptext:
  - "(alias) email-log <ref> (to (user foo|user@my.domain)) - email a log to the user given the log ref"
  - "(alias) tail-log <ref> - view the end of a log given the log ref"
  - "(alias) link-log <ref> - get a URL for a log"
- Keywords: [ "list", "job", "jobs", "log", "logs", "history", "joblogs" ]
  Helptext: [ "(alias) job-logs <jobname> - list logs for a given job" ]
- Keywords: [ "list", "log", "logs", "history", "build", "builds", "buildlogs" ]
  Helptext: [ "(alias) build-logs <repo> (branch) - list build logs matching a given repository / branch" ]
CommandMatchers:
- Command: maillog
  Regex: '(?i:(?:send|mail|email)[- ]?log ([A-Za-z0-9]+)(?: to (?:(?:user (.*))|([^@]+@[^@]+)))?)'
- Command: taillog
  Regex: '(?i:(?:tail|view|show)[- ]?log ([A-Za-z0-9]+))'
- Command: linklog
  Regex: '(?i:(?:link|get)[- ]?log ([A-Za-z0-9]+))'
- Command: joblogs
  Regex: '(?i:job[- ]?logs(?: ([A-Za-z][\w-]*)))'
- Command: buildlogs
  Regex: '(?i:build[- ]?logs(?: ([A-Za-z][\w-:./]*))(?: ([A-Za-z][\w-]*))?)'
</file_content file: gopherbot-main/conf/plugins/builtin-history.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-jobcmd.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-jobcmd.yaml>
---
AllChannels: true
AllowDirect: false
Help:
- Keywords: [ "jobs", "list", "job" ]
  Helptext: [ "(alias) list-jobs (all) - list the jobs you have access to, optionally in all channels" ]
- Keywords: [ "job", "jobs", "run" ]
  Helptext: [ "(alias) run-job <name> (args...) - manually start a job run" ]
- Keywords: [ "build", "builds", "list", "repository", "repositories" ]
  Helptext: [ "(alias) list-builds - list the buildable repositories" ]
CommandMatchers:
- Command: jobs
  Regex: '(?i:list (all )?jobs)'
- Command: jobs
  Regex: '(?i:list[- ]jobs( -?-?all)?)'
- Command: builds
  Regex: '(?i:list[- ](?:builds|repositories))'
</file_content file: gopherbot-main/conf/plugins/builtin-jobcmd.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-logging.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-logging.yaml>
---
DirectOnly: true
RequireAdmin: true
Help:
- Keywords: [ "log", "logs", "level" ]
  Helptext: [ "(alias) set-loglevel to <trace|debug|info|warning|error> - adjust the logging verbosity" ]
- Keywords: [ "show", "log", "logs" ]
  Helptext: [ "(alias) show-log (page X) - display the last or Xth previous page of log output" ]
- Keywords: [ "show", "log", "logs", "level" ]
  Helptext: [ "(alias) show-loglevel - show the current logging level" ]
- Keywords: [ "log", "page", "lines" ]
  Helptext: [ "(alias) set-loglines to <number> - set the number of lines returned by show log"]
CommandMatchers:
- Command: "level"
  Regex: '(?i:set[- ]log ?level(?: to)? (trace|debug|info|warn|error))'
- Command: "show"
  Regex: '(?i:show[- ]logs?(?: page (\d+))?)'
- Command: "showlevel"
  Regex: '(?i:show[- ](?:log[- ]?)?level)'
- Command: "setlines"
  Regex: '(?i:set[- ]log[- ]?lines(?: to)? (\d+))'
</file_content file: gopherbot-main/conf/plugins/builtin-logging.yaml>
<preamble file: gopherbot-main/conf/plugins/builtin-totp.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/builtin-totp.yaml>
---
Help:
- Keywords: [ "totp", "launch", "missiles" ]
  Helptext: [ "(alias) validate <code> - check that your TOTP codes are working" ]
CommandMatchers:
- Command: "check"
  Regex: '(?i:(?:validate|launch missiles:) (\d{6}))'
Config:
  # How long elevation lasts
  TimeoutSeconds: 7200
  # When 'idle', the timer resets on every elevated command
  TimeoutType: idle # or absolute
  ## Encrypted user codes (add to bot-specific config)
  # Users:
  # - User: "david"
  #   Secret: "<encrypted secret>" (generate with 'gopherbot gentotp david')
</file_content file: gopherbot-main/conf/plugins/builtin-totp.yaml>
<preamble file: gopherbot-main/conf/plugins/citools.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/citools.yaml>
---
# Plugin configuration for citools
Help:
- Keywords: [ "build" ]
  Helptext:
  - "(alias) build <repo> (branch) (pipeline) (args) - start a gopherci build for the given repo"
  - "(alias) help with build - give detailed help on the build command"
CommandMatchers:
- Command: 'build'
  Regex: '(?i:build ([^\s]+)(?: ([^\s]+))?(?: ([^\s]+))?(?: (.*))?)'
- Command: 'help'
  Regex: '(?i:help with build(?:ing)?)'
</file_content file: gopherbot-main/conf/plugins/citools.yaml>
<preamble file: gopherbot-main/conf/plugins/duo.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/duo.yaml>
---
## Default configuration for Duo two-factor authentication. If your organization
## uses Duo, you can obtain an IKey, SKey and Host for use with the auth api.
Config:
## How long elevation lasts
  TimeoutSeconds: 7200
## When 'idle', the timer resets on every elevated command
  TimeoutType: idle # or absolute
  DuoIKey: {{ env "GOPHER_DUO_IKEY" }} # or replace with encrypted string
  DuoSKey: {{ env "GOPHER_DUO_SKEY" }} # or replace with encrypted string
  DuoHost: {{ env "GOPHER_DUO_HOST" }} # or replace with encrypted string
  DuoUserString: emailUser
{{ if not (env "GOPHER_DUO_HOST") }}
Disabled: true
{{ end }}
</file_content file: gopherbot-main/conf/plugins/duo.yaml>
<preamble file: gopherbot-main/conf/plugins/groups.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/groups.yaml>
---
# For authorizing users by group
Help:
- Keywords: [ "group", "groups" ]
  Helptext: [ "(alias) help with groups - give general help for using groups"]
- Keywords: [ "group", "groups", "add" ]
  Helptext: [ "(alias) add <user> to the <groupname> group - add a user to a group" ]
- Keywords: [ "group", "groups", "remove" ]
  Helptext: [ "(alias) remove <user> from the <groupname> group - remove a dynamic user from a group" ]
- Keywords: [ "group", "groups", "empty" ]
  Helptext: [ "(alias) empty the <groupname> group - remove all dynamic users from a group" ]
- Keywords: [ "list", "group", "groups" ]
  Helptext: [ "(alias) list groups - give a list of all the groups the robot knows about (bot administrators only)" ]
- Keywords: [ "group", "groups", "show", "view" ]
  Helptext: [ "(alias) show the <groupname> group - show the members of a group" ]
CommandMatchers:
- Command: 'help'
  Regex: '(?i:help with groups?)'
- Command: 'add'
  Regex: '(?i:add ([\w-.:]+) to (?:the )?(?:([~\w-'' ]+) )?group)'
  Contexts: [ "user", "group" ]
- Command: 'list'
  Regex: '(?i:list groups)'
- Command: 'remove'
  Regex: '(?i:(?:remove|delete) ([\w-.:]+) from (?:the )?(?:([~\w-'' ]+) )?group)'
  Contexts: [ "user", "group" ]
- Command: 'empty'
  Regex: '(?i:(?:empty|clear) (?:the )?(?:([~\w-'' ]+) )?group)'
  Contexts: [ "group" ]
- Command: 'show'
  Regex: '(?i:show (?:the )?(?:([~\w-'' ]+) )?group)'
  Contexts: [ "group" ]
Disabled: true
## The groups authorizer plugin is disabled by default; you can use the example
## config below to configure your own robot.
##
## Generally no real point in configuring both administrators and users;
## administrators can add and remove users dynamically. If a user is listed here
## or stored in memory, they get access.
#
# Config:
#   Groups:
#     Helpdesk:
#       Administrators:
#       - carol
#       Users:
#       - bob
#     SysAdmins:
#       Users:
#       - david
#     NetAdmins:
#       Administrators:
#       - erin
#     Peons:
#       Administrators:
#       - carol
</file_content file: gopherbot-main/conf/plugins/groups.yaml>
<preamble file: gopherbot-main/conf/plugins/help.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/help.yaml>
---
Help:
- Keywords: [ "*", "help" ]
  Helptext: [ "(alias) help with robot - give general help on the help system and using the robot" ]
CommandMatchers:
- Command: help
  Regex: '(?i:help with (?:help|robot))'
MessageMatchers:
- Command: help
  Regex: '^(?i:help)$'
- Command: help
  Regex: '^(?i:help with (?:help|robot))$'
# Help is one of the few plugins where ambient messages (not directed at the
# robot) should match for unlisted users.
MatchUnlisted: true
AllChannels: true
</file_content file: gopherbot-main/conf/plugins/help.yaml>
<preamble file: gopherbot-main/conf/plugins/knock.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/knock.yaml>
---
# You can add your own Jokes, Openings, and "Phooey" lines (no response)
# by re-defining "Config" in your local knock.yaml file, with new entries
# in the arrays.
Help:
- Keywords: [ "knock", "joke" ]
  Helptext: [ "(bot), tell me a (knock-knock) joke" ]
CommandMatchers:
- Command: knock
  Regex: '(?i:tell me a(?:nother)?(?: knock[- ]knock)? joke)'
ReplyMatchers:
- Label: whosthere
  Regex: '(?i:who.?s there\??|who is there\??)'
- Label: who
  Regex: '(?i:[\w ]+ who\??)'
Config:
  Jokes:
  - { First: "Interrupting Cow", Second: "*cough*" }
  - { First: "To", Second: "\"To *whom*\"" }
  - { First: "Doctor", Second: "Man, I wish!" }
  - { First: "Eskimo", Second: "Eskimo questions, I tell no lies" }
  - { First: "Spell", Second: "W H O" }
  - { First: "Toby", Second: "Toby or not Toby - that is the question" }
  - { First: "Ya", Second: "Well, I'm happy to see you, too!" }
  - { First: "Keith", Second: "Keith me, my thweet preenthith!" }
  - { First: "Police", Second: "Police let me in, it's cold out here!" }
  - { First: "Isabel", Second: "Isabel working, or should I keep knocking?" }
  - { First: "Etch", Second: "Bless you!" }
  - { First: "Claire", Second: "Claire the way, I'm coming in!" }
  - { First: "Radio", Second: "Radio not, here I come!" }
  - { First: "Howard", Second: "Howard I know?" }
  - { First: "Cereal", Second: "Cereal pleasure to meet you!" }
  - { First: "Alpaca", Second: "Alpaca the suitcase if you'll loada the car!" }
  - { First: "Wooden shoe", Second: "Wooden shoe love to hear another knock-knock joke?" }
  - { First: "Nana", Second: "Nana yer business, open up!" }
  - { First: "Harry", Second: "Harry up and let me in!" }
  - { First: "Adolph", Second: "Adolph ball hit me in the mouf - dat why I talk dis way!" }
  - { First: "Omar", Second: "Omar goodness, wrong house!" }
  - { First: "Panther", Second: "Panther no panth, Im going thwimming!" }
  - { First: "Oswald", Second: "Oswald my bubble gum!" }
  - { First: "Olive", Second: "Olive you and I don't care who knows it!" }
  - { First: "Cargo", Second: "No, car go \"beep beep\"" }
  - { First: "Goliath", Second: "Goliath down, thou looketh tired" }
  - { First: "Wendy", Second: "Wendy bell works again, I'll stop knocking" }
  - { First: "Figs", Second: "Figs your dang doorbell already!" }
  - { First: "Moustache", Second: "Moustache you a question, but Ill shave it for later!" }
  - { First: "Broken pencil", Second: "Ah, forget it - it's pointless" }
  - { First: "Tank", Second: "You're welcome!" }
  - { First: "Al", Second: "Al give you a kiss if you'll open the door!" }
  - { First: "Weevil", Second: "Weevil weevil rock you" }
  - { First: "Frank", Second: "Frank you for being my friend!" }
  - { First: "Dishes", Second: "Dishes a nice place ya got here" }
  Openings:
  - "Ok, I know a good one!"
  - "Hrm... ok, this is one of my favorites..."
  - "I'll see if I can think of one..."
  - "Another robot told me this one, tell me if you think it's funny"
  - "I found this lame joke on the Internet ... but it's kinda funny when a robot tells it!"
  - "I'll ask Watson(tm) if he knows any good ones and get back to you in a jiffy..."
  - "Hang on while I Google that for you (just kidding ;-)"
  - "Sure - Siri told me this one, but I think it's kind of dumb"
  - "Ok, here's a funny one I found in Hillary's email..."
  - "Yeah! I LOVE telling jokes!"
  - "Alright - I'll see if I can make my voice sound funny"
  Phooey:
  - "Ah, you're no fun"
  - "What, don't you like a good knock-knock joke?"
  - "Ok, maybe another time"
</file_content file: gopherbot-main/conf/plugins/knock.yaml>
<preamble file: gopherbot-main/conf/plugins/links.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/links.yaml>
---
Help:
- Keywords: [ "link", "links", "add" ]
  Helptext: [ "(bot), link <word/phrase> to <http://...> - save a link with a single word/phrase key" ]
- Keywords: [ "link", "links", "save", "add" ]
  Helptext: [ "(bot), save link <http://...> - save a link and prompt for multiple word/phrase keys"]
- Keywords: [ "link", "links", "find", "lookup", "search" ]
  Helptext:
  - "(bot), (find|lookup) <keyword/phrase> - find links with keys containing a keyword or phrase"
  - "(bot), look <keyword/phrase> up"
- Keywords: [ "link", "links", "remove" ]
  Helptext: [ "(bot), remove <http://...> - remove a link" ]
- Keywords: [ "link", "links" ]
  Helptext: [ "(bot), help with links - give a description of the links plugin" ]
- Keywords: [ "link", "links", "list", "show" ]
  Helptext: [ "(bot), (list|show) links - list all the links the robot knows" ]
CommandMatchers:
- Command: 'help'
  Regex: '(?i:help with links?)'
- Command: 'add'
  Regex: '(?i:link ([-\w ,''!."+=?&@#()/]+) to ((?:http(?:s)?:\/\/)?(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b(?:[-a-zA-Z0-9@:%_\+.~#?&//=]*)))'
  Contexts: [ "item:it", "link" ]
- Command: 'add'
  Regex: '(?i:link ([-\w ,''!."+=?&@#()/]+) to (it))'
  Contexts: [ "item:it", "link:it" ]
- Command: 'save'
  Regex: '(?i:save (?:link )?((?:http(?:s)?:\/\/)?(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b(?:[-a-zA-Z0-9@:%_\+.~#?&//=]*)))'
  Contexts: [ "link" ]
- Command: 'remove'
  Regex: '(?i:(?:remove|delete) (?:link )?((?:http(?:s)?:\/\/)?(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b(?:[-a-zA-Z0-9@:%_\+.~#?&//=]*)))'
  Contexts: [ "link" ]
- Command: 'find'
  Regex: '(?i:(?:find|look ?up) ([-\w ,''!."+=?&@#()/]+))'
  Contexts: [ "item:it" ]
- Command: 'list'
  Regex: '(?i:(?:show|list) links)'
- Command: 'find'
  Regex: '(?i:look ([-\w ,''!."+=?&@#()/]+) up)'
  Contexts: [ "item:it" ]
ReplyMatchers:
- Regex: '([-\w ,''!."+=?&@#()/]+)'
  Label: "lookup"
Config:
  Scope: global # or "channel"
</file_content file: gopherbot-main/conf/plugins/links.yaml>
<preamble file: gopherbot-main/conf/plugins/lists.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/lists.yaml>
---
# For keeping simple shared lists of things
Help:
- Keywords: [ "list", "lists" ]
  Helptext: [ "(bot), help with lists - give general help for using lists"]
- Keywords: [ "list", "lists", "add" ]
  Helptext: [ "(bot), add <item> to the <type> list - add something to a list" ]
- Keywords: [ "list", "lists", "remove" ]
  Helptext: [ "(bot), remove <item> from the <type> list - remove something from a list" ]
- Keywords: [ "list", "lists", "empty" ]
  Helptext: [ "(bot), empty the <type> list - remove all items from a list" ]
- Keywords: [ "list", "lists", "delete" ]
  Helptext: [ "(bot), delete the <type> list - remove the list altogether" ]
- Keywords: [ "list", "lists" ]
  Helptext: [ "(bot), list lists - give a list of all the lists the robot knows about" ]
- Keywords: [ "list", "lists", "email", "send" ]
  Helptext: [ "(bot), send me the <type> list - send a copy of the list by email" ]
- Keywords: [ "list", "lists", "show", "view" ]
  Helptext: [ "(bot), show the <type> list - show the contents of a list" ]
- Keywords: [ "pick", "random", "lists", "list" ]
  Helptext: [ "(bot), pick a random item from the <type> list"]
CommandMatchers:
- Command: 'help'
  Regex: '(?i:help with lists?)'
- Command: 'add'
  Regex: '(?i:add ([-\w .,!?:\/''"]+) to (?:the )?(?:([-\w .,!?:\/''"]+) )?list)'
  Contexts: [ "item:it", "list" ]
- Command: 'list'
  Regex: '(?i:list lists)'
- Command: 'remove'
  Regex: '(?i:(?:remove|delete) ([-\w .,!?:\/''"]+) from (?:the )?(?:([-\w .,!?:\/''"]+) )?list)'
  Contexts: [ "item:it", "list" ]
- Command: 'empty'
  Regex: '(?i:(?:empty|clear) (?:the )?(?:([-\w .,!?:\/''"]+) )?list)'
  Contexts: [ "list" ]
- Command: 'delete'
  Regex: '(?i:delete (?:the )?(?:([-\w .,!?:\/''"]+) )?list)'
  Contexts: [ "list" ]
- Command: 'show'
  Regex: '(?i:show (?:the )?(?:([-\w .,!?:\/''"]+) )?list)'
  Contexts: [ "list" ]
- Command: 'pick'
  Regex: '(?i:(?:pick )(?:an? )?random (?:item )?(?:from )(?:the )?([-\w .,!?:\/''"]+)?(?: list))'
  Contexts: [ "list" ]
- Command: 'send'
  Regex: '(?i:(?:send me|email) (?:the )?(?:([-\w .,!?:\/''"]+) )?list)'
  Contexts: [ "list" ]
Config:
  Scope: global # or "channel" if lists aren't shared globally
</file_content file: gopherbot-main/conf/plugins/lists.yaml>
<preamble file: gopherbot-main/conf/plugins/memes.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/memes.yaml>
---
# You need an imgflip username and password to enable this plugin. There are
# three primary ways to enable this plugin:
# 1. Put values for GOPHER_MEMES_USER and GOPHER_MEMES_PASSWORD in '.env'
#    with the connector credentials
# 2. Create memes.yaml in custom/conf/plugins, supplying the Username, and
#    get the robot to encrypt the password with a direct message
#    'encrypt xxx', then use decrypt in the template for the Password
#
# To add your own memes, create conf/plugins/memes.yaml in the custom
# configuration repository, with new entries for "Help:" and "CommandMatchers:"
# following the format shown, where the "Command" is the template ID.
# See: https://api.imgflip.com/
# For stock memes template ID: https://imgflip.com/memetemplate/<name>
Config:
  Username: {{ env "GOPHER_MEMES_USER" }}
  Password: {{ env "GOPHER_MEMES_PASSWORD" }} # or 'store task parameter memes PASSWORD=xxx'
# This just checks whether either value is defined.
{{ if not (env "GOPHER_MEMES_USER" | default (env "GOPHER_MEMES_PASSWORD")) }}
Disabled: true
{{ end }}
Help:
- Keywords: [ "meme", "picard", "omg" ]
  Helptext: [ "(bot), picard omg <something>(/<something>) - Picard facepalm" ]
- Keywords: [ "meme", "picard", "wth", "wtf" ]
  Helptext: [ "(bot), picard wth <something>(/<something>) - Picard WTH" ]
- Keywords: [ "meme", "farnsworth", "news" ]
  Helptext:
  - "(bot), Good news everyone (<something>) - let Professor Farnsworth deliver the good news"
  - "(bot), farnsworth <something>/<something> - Professor Farnsworth expounds"
- Keywords: [ "meme", "roy", "phone" ]
  Helptext: [ "(bot), roy phone <something>(/<something>) - Roy provides phone support" ]
- Keywords: [ "meme", "gosh" ]
  Helptext: [ "(bot), <something>, gosh! - Let Napoleon Dynamite express your indignation" ]
- Keywords: [ "meme", "best", "worst" ]
  Helptext: [ "(bot), this is pretty much the best/worst <something> - Napoleon expresses his opinion" ]
- Keywords: [ "meme", "skill", "skills" ]
  Helptext: [ "(bot), <something> skill(s) with <something> - Hear about Napoleon's incredible skills" ]
- Keywords: [ "meme", "simply" ]
  Helptext: [ "(bot), one does not simply <do something> - Summon Boromir to make your point" ]
- Keywords: [ "meme", "prepare" ]
  Helptext: [ "(bot), you <did something>, prepare to die - Let Inigo threaten your friends" ]
- Keywords: [ "meme", "brace" ]
  Helptext: [ "(bot), brace yourselves, <something> - Boromir warns your" ]
- Keywords: [ "meme" ]
  Helptext: [ "(bot), Y U no <something> - express your angst" ]
- Keywords: [ "meme", "matrix" ]
  Helptext: [ "(bot), What if I told you <something> - let Morpheus blow their minds" ]
- Keywords: [ "meme", "matrix" ]
  Helptext: [ "(bot), morpheus <something>/<something>" ]

CommandMatchers:
- Command: "1509839"
  Regex: '(?i:picard omg ([^/]+)(?:/([^/]+))?)'
- Command: "245898"
  Regex: '(?i:picard wt[hf] ([^/]+)(?:/([^/]+))?)'
- Command: "29106534"
  Regex: '(?i:roy phone ([^/]+)(?:/([^/]+))?)'
- Command: "7163250"
  Regex: '(?i:((?:good|great) news,? (?:everyone|everybody)),? (.+))'
- Command: "7163250"
  Regex: '(?i:farnsworth ([^/]+)(?:/([^/]+))?)'
- Command: "18304105"
  Regex: '(?i:(.+,?) (gosh!?))'
- Command: "8070362"
  Regex: '(?i:(.+ pretty much the) ((?:best|worst) .+))'
- Command: "20509936"
  Regex: '(?i:(.+ skills?) ((?:with|in) .+))'
- Command: "61579"
  Regex: '(?i:(one does not simply) (.+))'
- Command: "47779539"
  Regex: '(?i:(you .+) (prepare to die!?))'
- Command: "61546"
  Regex: '(?i:(brace yourselves,?) (.+))'
- Command: "61527"
  Regex: '(?i:(y u no) (.+))'
- Command: "33301480"
  Regex: '(?i:(what if I told you) (.+))'
- Command: "33301480"
  Regex: '(?i:morpheus ([^/]+)(?:/([^/]+))?)'
</file_content file: gopherbot-main/conf/plugins/memes.yaml>
<preamble file: gopherbot-main/conf/plugins/ping.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/ping.yaml>
---
# These are used to see if the robot is alive, so should answer in every channel
AllChannels: true
AllowedHiddenCommands:
- ping
- whoami
Help:
- Keywords: [ "ping" ]
  Helptext: [ "(alias) ping - see if the bot is alive" ]
- Keywords: [ "ignore" ]
  Helptext: [ "(alias) i(gnore) <anything> - ignore a chat message, useful in channels that match all messages"]
- Keywords: [ "thread" ]
  Helptext: [ "(alias) new thread (topic) - start a new thread with the robot; informational topic optional" ]
- Keywords: [ "rules" ]
  Helptext: [ "(bot), what are the rules? - Be sure the robot knows how to conduct his/herself." ]
- Keywords: [ "whoami", "user", "identity", "handle", "username" ]
  Helptext: [ "(bot), whoami - Get the robot to tell you a little bit about yourself." ]
CommandMatchers:
- Command: "ping"
  Regex: "(?i:ping)"
- Command: "ignore"
  # NOTE: We don't match 'I <something>' - otherwise users couldn't say
  # "Floyd, I love you" (or "Floyd, I think you're a nimrod")
  Regex: '(?s:(?:i(?:gnore)?|Ignore|I:)[ :].*)'
- Command: "thanks"
  Regex: "(?i:thanks?( you)?!?)"
- Command: "rules"
  Regex: '(?i:(?:what are )?the rules\??)'
- Command: "thread"
  Regex: "(?:(?i:(?:(?:new|start|create)[ -])?thread)(?: .*)?)"
- Command: "whoami"
  Regex: "(?i:whoami)"
- Command: "hello"
  Regex: "(?i:(?:hi|hello|howdy)[.!]?)"
# These can be supplemented by adding a Config: section to conf/plugins/ping.yaml
Config:
  Welcome:
  - "You're welcome!"
  - "Don't mention it"
  - "De nada"
  - "Sure thing"
  - "No problem!"
  - "No problemo!"
  - "Happy to help"
  - "T'was nothing"
  Thread:
  - "Here you go, a shiny new thread!"
  - "Cool! Let's get some work done, eh?"
  - "Alrighty, let's keep this junk out of the main channel"
  - "That's very kind of you - keeping your silly cruft tucked away in a thread like this"
</file_content file: gopherbot-main/conf/plugins/ping.yaml>
<preamble file: gopherbot-main/conf/plugins/slackutil.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/slackutil.yaml>
---
Help:
- Keywords: [ "identify", "id", "slack", "whois" ]
  Helptext: [ "(alias) slack id <@user> - get the slack internal ID for @user" ]
CommandMatchers:
- Command: "identify"
  Regex: '(?i:slack id ([@\w]+))'
</file_content file: gopherbot-main/conf/plugins/slackutil.yaml>
<preamble file: gopherbot-main/conf/plugins/theia-plugin.yaml>

</preamble>
<file_content file: gopherbot-main/conf/plugins/theia-plugin.yaml>
---
RequireAdmin: true
AllowDirect: true
AllChannels: true
Help:
- Keywords: [ "theia", "code", "ide", "gopherbot" ]
  Helptext: [ "(alias) start-ide - start theia IDE (requires gopherbot-theia image)" ]
CommandMatchers:
- Command: "theia"
  Regex: '(?i:start-(?:theia|ide))'
</file_content file: gopherbot-main/conf/plugins/theia-plugin.yaml>
<preamble file: gopherbot-main/conf/robot.yaml>

</preamble>
<file_content file: gopherbot-main/conf/robot.yaml>

## This is a the default configuration for gopherbot. Values here can be
## overridden by values in the custom configuration. Primarily configuration
## required on initial load is defined here; most configuration, as well as
## locally defined job/task/plugin scripts, should come from a custom
## configuration repository.

## Template functions:
## default "value":
##   provide a default value if "" or unset is piped in
## env "ENV_VAR":
##   look a value up from the environment
## decrypt "<encrypted string>":
##   decrypt a value encrypted with the 'encrypt <string>' command
## .Include "<filename>":
##   Include and expand the contents of another file from the same
##   location (installed defaults or custom config)

## Port to listen on for http/JSON api calls, for external plugins.
## By default, automatically choose a port.
LocalPort: {{ env "GOPHER_PORT" | default "0" }}

{{ $proto := env "GOPHER_PROTOCOL" | default "nullconn" }}
Protocol: {{ $proto }}
## Trivial "terminal" connector config for a single admin user.
## This pulls in a basic default config for the terminal connector
## which can be overridden in custom if desired.
{{ if eq $proto "terminal" }}
{{ .Include "terminal.yaml" }}
{{ end }}
## Dummy connector for bootstrapping & autosetup
{{ if eq $proto "nullconn" }}
{{ .Include "nullconn.yaml" }}
{{ end }}

## Configure log level
LogLevel: {{ env "GOPHER_LOGLEVEL" | default "info" }}

## Configure a history provider
{{ $history := env "GOPHER_HISTORY_PROVIDER" | default "mem" }}
HistoryProvider: {{ $history }}

{{ if eq $history "mem" }}
HistoryConfig:
  BufferSize: 131072
  MaxLineLength: 16384
  Truncated: "<... truncated>"
{{ end }}
## End history config

TimeZone: {{ env "GOPHER_TIMEZONE" | default "America/New_York" }}

# Default shared namespaces to allow sharing of parameters between
# various administrative tasks/plugins/jobs
NameSpaces:
  # Needed to prevent dangling reference; parameters need to be in
  # custom config.
  "ssh":
  # github namespace for sharing memories
  "github":
  "manage":
    Parameters:
    - Name: GOPHER_CUSTOM_REPOSITORY
      Value: {{ env "GOPHER_CUSTOM_REPOSITORY" }}
    - Name: GOPHER_CUSTOM_BRANCH
      Value: {{ env "GOPHER_CUSTOM_BRANCH" | default "." }}
    - Name: GOPHER_STATE_REPOSITORY
      Value: {{ env "GOPHER_STATE_REPOSITORY" }}
    - Name: GOPHER_STATE_BRANCH
      Value: {{ env "GOPHER_STATE_BRANCH" }}
    # A default installed robot stores its brain in state/brain
    - Name: GOPHER_STATEDIR
      Value: {{ env "GOPHER_STATEDIR" | default "state" }}

ParameterSets:
  # Administrator needs to define a github-token parameterset with GITHUB_TOKEN set.
  "github-token":

{{ if env "GOPHER_UNCONFIGURED" | not }}
EncryptBrain: true
{{ end }}

## NOTE:
## External script jobs/tasks/plugins do NOT have direct access to
## environment variables, but instead get a combination of:
## - vars explicitly propagated such as $HOME
## - vars defined in "Parameters" (see below)

ExternalPlugins:
## Useful and/or entertaining plugins; disable by setting 'Disabled: true' in
## custom configuration.
  "admin":
    Description: A plugin that triggers management jobs like update, save, backup, etc.
    Privileged: true
    Path: plugins/admin.sh
  {{- if env "GOPHER_CONTAINER" }}
  "theia-plugin":
    Description: A utility plugin for running the theia job, to start the container IDE
    Privileged: true
    Path: plugins/theia.sh
  {{- end }}
  "citools":
    Description: Tools for interacting with gopherci
    Privileged: true
    Path: plugins/citools.py
  "ssh-admin":
    Description: Administrative plugin for managing the robot's ssh keypair
    Path: plugins/ssh-admin.sh
    Privileged: true
    NameSpace: ssh
{{ if env "GOPHER_UNCONFIGURED" }}
  {{- if eq $proto "terminal" }}
  "welcome":
    Description: The welcome plugin provides a greeting when unconfigured
    Privileged: true
    Path: plugins/welcome.sh
  {{- end }}
  "autosetup":
    Description: Setup plugin for creating a new robot from an answerfile
    Privileged: true
    Homed: true
    NameSpace: manage
    Path: plugins/autosetup.sh
    Parameters:
    - Name: GOPHER_ENCRYPTION_INITIALIZED
      Value: {{ env "GOPHER_ENCRYPTION_INITIALIZED" }}
    - Name: GOPHER_CONTAINER
      Value: {{ env "GOPHER_CONTAINER" }}
    {{- if env "GOPHER_CONTAINER" }}
    # pass-through all ANS_ vars...
    - Name: ANS_PROTOCOL
      Value: '{{ env "ANS_PROTOCOL" }}'
    - Name: ANS_ENCRYPTION_KEY
      Value: '{{ env "ANS_ENCRYPTION_KEY" }}'
    - Name: ANS_SLACK_TOKEN
      Value: '{{ env "ANS_SLACK_TOKEN" }}'
    - Name: ANS_ROBOT_NAME
      Value: '{{ env "ANS_ROBOT_NAME" }}'
    - Name: ANS_ROBOT_ALIAS
      Value: '{{ env "ANS_ROBOT_ALIAS" }}'
    - Name: ANS_JOB_CHANNEL
      Value: '{{ env "ANS_JOB_CHANNEL" }}'
    - Name: ANS_ROBOT_EMAIL
      Value: '{{ env "ANS_ROBOT_EMAIL" }}'
    - Name: ANS_SSH_PHRASE
      Value: '{{ env "ANS_SSH_PHRASE" }}'
    - Name: ANS_KEY_TYPE
      Value: '{{ env "ANS_KEY_TYPE" }}'
    - Name: ANS_ROBOT_REPOSITORY
      Value: '{{ env "ANS_ROBOT_REPOSITORY" }}'
    - Name: ANS_ADMIN_SECRET
      Value: '{{ env "ANS_ADMIN_SECRET" }}'
    {{ end }}
{{ else }}
  "bootstrap":
    Description: A plugin to bootstrap an existing robot to a new container/directory
    Privileged: true
    Homed: true
    NameSpace: manage
    Path: plugins/bootstrap.py
    Parameters:
    - Name: GOPHER_DEPLOY_KEY
    # Deployment key with "tr '\n' ':'" - yaml parsing will fail if not quoted
      Value: "{{ env "GOPHER_DEPLOY_KEY" }}"
{{ end }}

## ExternalJobs describe configurable jobs the robot knows about. Requires
## config in conf/jobs/<jobname>.yaml (see sample files in dist)
ExternalJobs:
  "updatecfg":
    Description: A job that updates the robot's configuration from git
    Homed: true
    NameSpace: manage
    Path: jobs/updatecfg.py
  "changebranch":
    Description: A job that lets the robot switch branches for development
    Homed: true
    NameSpace: manage
    Path: jobs/changebranch.py
  "save":
    Description: A job for saving up the robot's configuration
    Homed: true
    NameSpace: manage
    Path: jobs/save.sh
  "install-libs":
    Description: A job for installing ruby gems and python packages
    Homed: true
    Path: jobs/install-libs.sh
  "github-poller":
    Description: "Job that polls github repositories and builds new/updated tags and branches"
    Disabled: true
    NameSpace: "github"
    ParameterSets:
    - github-token
    Path: jobs/github-poller.py
  {{- if env "GOPHER_CONTAINER"}}
  "theia":
    Description: "Start theia interface; WARNING: UNAUTHENTICATED"
    Path: jobs/theia.sh
    Parameters:
    # Allow "gopherbot encrypt/decrypt" to work
    - Name: "GOPHER_ENCRYPTION_KEY"
      Value: "{{ env "GOPHER_ENCRYPTION_KEY" }}"
    - Name: GOPHER_CUSTOM_REPOSITORY
      Value: "{{ env "GOPHER_CUSTOM_REPOSITORY" }}"
    - Name: DEV_PRIVATE_KEY
      Value: "{{ env "DEV_PRIVATE_KEY" }}"
    - Name: DEV_KEY_NAME
      Value: {{ env "DEV_KEY_NAME" }}
  {{- end}}
  "backup":
    Description: A job for backing up the robot's state, normally just a file-based brain
    Homed: true
    NameSpace: manage
    Path: jobs/backup.sh
  "restore":
    Description: A job for restoring the robot's state from git
    Homed: true
    NameSpace: manage
    Path: jobs/restore.sh
  "logrotate":
    Description: Log rotation for file logging, schedule daily
    Path: jobs/logrotate.sh
  "ssh-job":
    Description: Wrapper for ssh jobs.
    Path: jobs/ssh-job.sh
  "gopherci":
    Description: A job for dispatching build jobs, triggered by commit notifications
    Path: jobs/gopherci.py
  "localbuild":
    Description: Build job run by gopherci to just clone a repo locally and run .gopherci/pipeline.(sh|py|rb)
    Path: jobs/localbuild.py

## ExternalTasks enumerate external executables that can be added to pipelines
## with AddTask <name>. Note the e.g. the update plugin requires ssh,
## ssh-agent, and git.
ExternalTasks:
  "notify":
    Description: Send a message to a user in the job channel, generally as a FailTask
    Path: tasks/notify.sh
  "dmnotify":
    Description: Send a DM to a user, generally as a FailTask
    Path: tasks/dmnotify.sh
  "status":
    Decription: Trivial task that can be used to send status updates in a pipeline
    Path: tasks/status.sh
  "say":
    Description: Convenience synonym for 'status'
    Path: tasks/status.sh
  "reply":
    Description: Trivial task to reply to the user with a message
    Path: tasks/reply.sh
  "git-init":
    Description: >
      Check for and initialize ssh for a repository if needed, check for
      GOPHER_CONFIGDIR/git/config and set XDG_CONFIG_HOME
    Path: tasks/git-init.py
    Homed: true
    Privileged: true
  "ssh-init":
    Description: "Pipeline job for setting up ssh-agent for the 'bot"
    Path: tasks/ssh-init.sh
    Homed: true
    Privileged: true
    NameSpace: ssh
  "ssh-task":
    Description: Wrapper for ssh tasks
    Path: jobs/ssh-job.sh
    Privileged: true
  "exec":
    Description: Simple utility for running scripts in a repository
    Path: tasks/exec.sh
  "remote":
    Description: Utility for running scripts and commands on a remote host
    Path: tasks/remote-exec.sh
  "start-build":
    Description: GopherCI utility task for telling the user a build started
    Path: tasks/startbuild.sh
  "finish-build":
    Description: GopherCI utility task for telling the user a build finished
    Path: tasks/finishbuild.sh
  "run-pipeline":
    Description: Detect one of pipeline.sh|py|rb and add to the pipeline
    Path: tasks/runpipeline.sh
  "setworkdir":
    Description: Update working directory as a step in a pipeline
    Path: tasks/setworkdir.sh
  "ansible-playbook":
    Description: Ansible playbook (ansible-playbook) runner with vault passphrase helper
    Path: tasks/ansible-playbook.sh
  "ssh-scan":
    Description: Helper script for adding ssh host keys to known_hosts
    Homed: true
    Path: tasks/ssh-scan.sh
  "git-clone":
    Description: Simple script to clone a repository and optionally set the working directory
    Path: tasks/git-clone.sh
  "cleanup":
    Description: Task for cleaning a working directory before starting a job/build
    Privileged: true
    Path: tasks/cleanup.sh
  "run-theia":
    Description: "Set up environment required for theia and run"
    Path: tasks/run-theia.sh
    Privileged: true
</file_content file: gopherbot-main/conf/robot.yaml>
<preamble file: gopherbot-main/conf/terminal.yaml>

</preamble>
<file_content file: gopherbot-main/conf/terminal.yaml>
## terminal.yaml - stock configuration for the terminal connector
{{ $botname := env "GOPHER_BOTNAME" | default "floyd" }}
{{ $botfullname := env "GOPHER_BOTFULLNAME" | default "Floyd Gopherbot"}}
{{ $botalias := env "GOPHER_ALIAS" | default ";"}}

AdminUsers: [ "alice" ]
DefaultChannels: [ "general", "random" ]

BotInfo:
  UserName: {{ $botname }}
  FullName: {{ $botfullname }}

Alias: {{ $botalias }}

ProtocolConfig:
  StartChannel: general
  StartUser: alice
  HearSelf: false # Needs to be enabled for individual robots
  BotID: "u0000"
  BotName: {{ $botname }}
  Channels:
  - random
  - general
  - deadzone
  Users:
  ## User "u0000" is auto-generated by the terminal connector
  ## If you want to override, use AppendUsers (or override Users entirely)
  ## in your robot's terminal.yaml. InternalID MUST be 'u0000'.
  # - Name: {{ $botname }}
  #   Email: "{{ $botname }}@example.com"
  #   InternalID: "u0000"
  #   FullName: {{ $botfullname }}
  #   FirstName: {{ $botname }}
  #   LastName: "Gopherbot"
  #   Phone: "(555)765-0000"
  - Name: "alice"
    Email: "alice@example.com"
    InternalID: "u0001"
    FullName: "Alice User"
    FirstName: "Alice"
    LastName: "User"
    Phone: "(555)765-0001"
  - Name: "bob"
    Email: "bob@example.com"
    InternalID: "u0002"
    FullName: "Bob User"
    FirstName: "Robert"
    LastName: "User"
    Phone: "(555)765-0002"
  - Name: "carol"
    Email: "@example.com"
    InternalID: "u0003"
    FullName: "Carol User"
    FirstName: "Carol"
    LastName: "User"
    Phone: "(555)765-0003"
  - Name: "david"
    Email: "david@example.com"
    InternalID: "u0004"
    FullName: "David User"
    FirstName: "David"
    LastName: "User"
    Phone: "(555)765-0004"
  - Name: "erin"
    Email: "erin@example.com"
    InternalID: "u0005"
    FullName: "Erin User"
    FirstName: "Erin"
    LastName: "User"
    Phone: "(555)765-0005"
  
UserRoster:
- UserName: "alice"
  UserID: "u0001"
- UserName: "bob"
  UserID: "u0002"
- UserName: "carol"
  UserID: "u0003"
- UserName: "david"
  UserID: "u0004"
- UserName: "erin"
  UserID: "u0005"

{{ $defaultjobchannel := "general" }}
DefaultJobChannel: {{ env "GOPHER_JOBCHANNEL" | default $defaultjobchannel }}
</file_content file: gopherbot-main/conf/terminal.yaml>
<preamble file: gopherbot-main/connectors/slack/connect.go>

</preamble>
<file_content file: gopherbot-main/connectors/slack/connect.go>
// Package slack uses Norberto Lopes' slack library to implement the bot.Connector
// interface.
package slack

import (
	"fmt"
	"log"
	"strings"
	"sync"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
	"github.com/slack-go/slack/socketmode"
)

type config struct {
	SlackToken         string // the 'bot token for connecting to Slack using RTM
	AppToken, BotToken string // tokens used for connecting to Slack using the new SocketMode
	MaxMessageSplit    int    // the maximum # of ~4000 byte messages to split a large message into
	Debug              bool   // Explicitly turn on Slack protocol debug output
}

var lock sync.Mutex        // package var lock
var started bool           // set when connector is started
var socketmodeEnabled bool // set when using socketmode to connect, duh
var slackDebug bool        // set to enable debugging output in slack lib

// Initialize starts the connection, sets up and returns the connector object
func Initialize(r robot.Handler, l *log.Logger) robot.Connector {
	lock.Lock()
	if started {
		lock.Unlock()
		return nil
	}
	started = true
	lock.Unlock()

	var c config
	var tok string

	slackOpts := []slack.Option{
		slack.OptionLog(l),
	}

	err := r.GetProtocolConfig(&c)
	if err != nil {
		r.Log(robot.Fatal, "Unable to retrieve slack protocol configuration: %v", err)
	}
	// This spits out a lot of extra stuff, so we only enable it when tracing or
	// explicitly configured.
	if c.Debug || r.GetLogLevel() == robot.Trace {
		slackOpts = append(slackOpts, slack.OptionDebug(true))
		slackDebug = true
	}

	if c.MaxMessageSplit == 0 {
		c.MaxMessageSplit = 1
	}

	if len(c.BotToken) > 0 && len(c.AppToken) > 0 {
		if !strings.HasPrefix(c.BotToken, "xoxb-") {
			r.Log(robot.Fatal, "BotToken must have the prefix \"xoxb-\".")
		}
		if !strings.HasPrefix(c.AppToken, "xapp-") {
			r.Log(robot.Fatal, "AppToken must have the prefix \"xapp-\".")
		}
		tok = c.BotToken
		socketmodeEnabled = true
		slackOpts = append(slackOpts, slack.OptionAppLevelToken(c.AppToken))
	} else {
		if len(c.SlackToken) == 0 {
			r.Log(robot.Fatal, "No slack token or bot/app tokens found in config")
		} else {
			if !strings.HasPrefix(c.SlackToken, "xoxb-") {
				r.Log(robot.Fatal, "BotToken must have the prefix \"xoxb-\".")
			}
			r.Log(robot.Warn, "Using deprecated legacy RTM mode for connection")
			tok = c.SlackToken
		}
	}

	api := slack.New(tok, slackOpts...)

	var sc *slackConnector

	if socketmodeEnabled {
		sockOpts := []socketmode.Option{
			socketmode.OptionLog(l),
			socketmode.OptionDebug(slackDebug),
		}
		sc = &slackConnector{
			api:             api,
			sock:            socketmode.New(api, sockOpts...),
			maxMessageSplit: c.MaxMessageSplit,
			name:            "slack",
		}
		go sc.sock.Run()
	} else {
		sc = &slackConnector{
			api:             api,
			conn:            api.NewRTM(),
			maxMessageSplit: c.MaxMessageSplit,
			name:            "slack",
		}
		go sc.conn.ManageConnection()
	}

	sc.Handler = r

	if socketmodeEnabled {
	SOCKInitLoop:
		for evt := range sc.sock.Events {
			switch evt.Type {
			case socketmode.EventTypeConnected:
				connectEvent, ok := evt.Data.(*socketmode.ConnectedEvent)
				if !ok {
					r.Log(robot.Warn, "Ignoring %+v", evt)
				} else {
					r.Log(robot.Debug, "Socket mode connected to '%s', count: %d",
						connectEvent.Info.URL,
						connectEvent.ConnectionCount)
				}
			case socketmode.EventTypeHello:
				r.Log(robot.Debug, "Received hello event for app_id '%s', slack host '%s', build number: %d",
					evt.Request.ConnectionInfo.AppID,
					evt.Request.DebugInfo.Host,
					evt.Request.DebugInfo.BuildNumber)
				sc.appID = evt.Request.ConnectionInfo.AppID
				break SOCKInitLoop
			case socketmode.EventTypeInvalidAuth:
				r.Log(robot.Fatal, "Invalid credentials")
			default:
				if evt.Request == nil {
					r.Log(robot.Debug, "Unhandled event type '%s' (nil request)", evt.Type)
				} else {
					r.Log(robot.Debug, "Unhandled event type '%s':\n%v", evt.Type, evt.Request)
				}
			}
		}
	} else {
	RTMInitLoop:
		for msg := range sc.conn.IncomingEvents {
			switch ev := msg.Data.(type) {

			case *slack.ConnectedEvent:
				r.Log(robot.Debug, "Slack infos: %T %v\n", ev, *ev.Info.User)
				r.Log(robot.Debug, "Slack connection counter: %d", ev.ConnectionCount)
				break RTMInitLoop
			case *slack.InvalidAuthEvent:
				r.Log(robot.Fatal, "Invalid credentials")
			}
		}
	}

	info, err := api.AuthTest()
	if err != nil {
		r.Log(robot.Fatal, "Error getting auth info: %v", err)
	}
	r.Log(robot.Debug, "Retrieved auth info:\n%+v", info)
	sc.botUserID = info.UserID
	r.Log(robot.Info, "Slack setting bot internal ID to: %s", sc.botUserID)
	r.SetBotID(sc.botUserID)
	sc.botID = info.BotID
	sc.botName = info.User
	sc.teamID = info.TeamID
	r.Log(robot.Info, "Set team ID to %s", sc.teamID)
	botInfo, err := api.GetBotInfo(sc.botID)
	if err != nil {
		r.Log(robot.Fatal, "Error getting bot info: %v", err)
	}
	sc.botFullName = botInfo.Name

	sc.updateChannelMaps("")
	// This should trigger from the engine calling SetUserMap
	// sc.updateUserList("")

	go sc.startSendLoop()

	return robot.Connector(sc)
}

func (sc *slackConnector) Run(stop <-chan struct{}) {
	sc.Lock()
	// This should never happen, just a bit of defensive coding
	if sc.running {
		sc.Unlock()
		return
	}
	sc.running = true
	sc.Unlock()
	if socketmodeEnabled {
	SOCKRunLoop:
		for {
			select {
			case <-stop:
				sc.Log(robot.Debug, "Received stop in connector")
				break SOCKRunLoop
			case evt := <-sc.sock.Events:
				switch evt.Type {
				case socketmode.EventTypeEventsAPI:
					eventsAPIEvent, ok := evt.Data.(slackevents.EventsAPIEvent)
					if !ok {
						sc.Log(robot.Warn, "Ignored %+v", evt)
						continue
					}
					sc.Log(robot.Trace, "Event received: %+v", eventsAPIEvent)
					sc.sock.Ack(*evt.Request)

					switch eventsAPIEvent.Type {
					case slackevents.CallbackEvent:
						innerEvent := eventsAPIEvent.InnerEvent
						switch innerEvent.Type {
						case "channel_archive", "channel_unarchive",
							"channel_created", "channel_deleted",
							"channel_rename", "channel_id_changed",
							"group_archive", "group_deleted",
							"group_open", "group_rename",
							"im_created", "im_open",
							"im_close":
							sc.updateChannelMaps("")
						case "message":
							mevt := innerEvent.Data.(*slackevents.MessageEvent)
							go sc.processMessageSocketMode(mevt)
						default:
							sc.Log(robot.Debug, "Ignored CallbackEvent type: %s", innerEvent.Type)
						}
					default:
						sc.Log(robot.Debug, "Unhandled Events API event received, type: %s", eventsAPIEvent.Type)
					}
				case socketmode.EventTypeSlashCommand:
					cmd, ok := evt.Data.(slack.SlashCommand)
					if !ok {
						fmt.Printf("Ignored %+v\n", evt)
						continue
					}
					sc.sock.Ack(*evt.Request)
					go sc.processSlashCmdSocketMode(&cmd)
				case socketmode.EventTypeInteractive:
					sc.sock.Ack(*evt.Request)
				default:
					sc.Log(robot.Debug, "Ignoring event type: %s", evt.Type)
				}
			}
		}
	} else {
	RTMRunLoop:
		for {
			select {
			case <-stop:
				sc.Log(robot.Debug, "Received stop in connector")
				break RTMRunLoop
			case msg := <-sc.conn.IncomingEvents:
				sc.Log(robot.Trace, "Event Received (msg, data, type): %v; %v; %T", msg, msg.Data, msg.Data)
				switch ev := msg.Data.(type) {
				case *slack.ChannelArchiveEvent, *slack.ChannelUnarchiveEvent,
					*slack.ChannelCreatedEvent, *slack.ChannelDeletedEvent,
					*slack.ChannelRenameEvent, *slack.GroupArchiveEvent,
					*slack.GroupUnarchiveEvent, *slack.GroupCreatedEvent,
					*slack.GroupRenameEvent, *slack.IMCloseEvent,
					*slack.IMCreatedEvent, *slack.IMOpenEvent:
					sc.updateChannelMaps("")

				case *slack.MessageEvent:
					// Message processing is done concurrently
					go sc.processMessageRTM(ev)

				case *slack.LatencyReport:
					sc.Log(robot.Debug, "Current latency: %v", ev.Value)

				case *slack.RTMError:
					sc.Log(robot.Debug, "Error: %s\n", ev.Error())

				default:

					// Ignore other events..
					// robot.Debug(fmt.Sprintf("Unexpected: %v\n", msg.Data)
				}
			}
		}
	}
}
</file_content file: gopherbot-main/connectors/slack/connect.go>
<preamble file: gopherbot-main/connectors/slack/connectorMethods.go>

</preamble>
<file_content file: gopherbot-main/connectors/slack/connectorMethods.go>
package slack

import (
	"strings"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/slack-go/slack"
)

const typingDelay = 200 * time.Millisecond

// Message send delay; slack has problems with scrolling if messages fly out
// too fast.
const msgDelay = 1 * time.Second

// Bursting constants; we allow the robot to send a maximum of `burstMessages`
// in a `burstWindow` window; above the burst limit we slow messages down to
// 1 / sec.
const burstMessages = 14            // maximum burst
const burstWindow = 4 * time.Second // window in which to allow the burst
const coolDown = 21 * time.Second   // cooldown time after bursting

// GetProtocolUserAttribute returns a string attribute or "" if slack doesn't
// have that information
func (s *slackConnector) GetProtocolUserAttribute(u, attr string) (value string, ret robot.RetVal) {
	var userID string
	var ok bool
	var user *slack.User
	if userID, ok = s.ExtractID(u); !ok {
		userID, ok = s.userID(u, false)
	}
	if ok {
		s.RLock()
		user, ok = s.userIDInfo[userID]
		s.RUnlock()
	}
	if !ok {
		return "", robot.UserNotFound
	}
	switch attr {
	case "email":
		return user.Profile.Email, robot.Ok
	case "internalid":
		return user.ID, robot.Ok
	case "realname", "fullname", "real name", "full name":
		return user.RealName, robot.Ok
	case "firstname", "first name":
		return user.Profile.FirstName, robot.Ok
	case "lastname", "last name":
		return user.Profile.LastName, robot.Ok
	case "phone":
		return user.Profile.Phone, robot.Ok
	// that's all the attributes we can currently get from slack
	default:
		return "", robot.AttributeNotFound
	}
}

type sendMessage struct {
	message, user, channel, thread string
	format                         robot.MessageFormat
	mtype                          msgType
}

var messages = make(chan *sendMessage)

// Send a typing notifier letting the user know the message has been heard by
// the robot.
func (s *slackConnector) MessageHeard(user, channel string) {
	var chanID string
	var ok bool
	if chanID, ok = s.ExtractID(channel); ok {
		if socketmodeEnabled {
			// TODO someday - socketmode doesn't support typing notifications :-(
			// Two problems with what's below:
			// - doesn't show up in thread
			// - never disappears
			// if userID, ok := s.ExtractID(user); ok {
			// 	opts := []slack.MsgOption{
			// 		slack.MsgOptionText(":speech_balloon:", false),
			// 		slack.MsgOptionAsUser(true),
			// 		slack.MsgOptionDisableLinkUnfurl(),
			// 	}
			// 	s.api.PostEphemeral(chanID, userID, opts...)
			// }
		} else {
			s.conn.SendMessage(s.conn.NewTypingMessage(chanID))
		}
	}
}

func (s *slackConnector) startSendLoop() {
	// See bursting constants above.
	var burstTime time.Time
	mtimes := make([]time.Time, burstMessages)
	current := 0 // index of the current message send time
	for {
		send := <-messages
		msgTime := time.Now()
		mtimes[current] = msgTime
		windowStartMsg := current + 1
		if windowStartMsg == (burstMessages - 1) {
			windowStartMsg = 0
		}
		current++
		if current == (burstMessages - 1) {
			current = 0
		}
		opts := []slack.MsgOption{
			slack.MsgOptionText(send.message, false),
			slack.MsgOptionAsUser(true),
			slack.MsgOptionDisableLinkUnfurl(),
		}
		// Slash commands are hidden, so we respond with an ephemeral message
		if len(send.user) > 0 && send.mtype == msgSlashCmd {
			opts = append(opts, slack.MsgOptionPostEphemeral(send.user))
		}
		if len(send.thread) > 0 {
			opts = append(opts, slack.MsgOptionTS(send.thread))
		}
		if send.format == robot.Variable {
			opts = append(opts, slack.MsgOptionDisableMarkdown(), slack.MsgOptionParse(false))
		}
		s.Log(robot.Trace, "Bot message in slack send loop for channel %s, size: %d", send.channel, len(send.message))
		time.Sleep(typingDelay)
		sent := false
		for p := range []int{1, 2, 4} {
			_, _, err := s.api.PostMessage(send.channel, opts...)
			if err != nil && p == 1 {
				s.Log(robot.Warn, "Sending slack message '%s' initiating backoff: %v", send.message, err)
			}
			if err != nil {
				time.Sleep(time.Second * time.Duration(p))
			} else {
				sent = true
				break
			}
		}
		if !sent {
			if socketmodeEnabled {
				s.Log(robot.Error, "Failed sending slack message '%s' to channel '%s' after 3 tries", send.message, send.channel)
				// There doesn't appear to be a fallback available with socket mode
			} else {
				s.Log(robot.Error, "Failed sending slack message '%s' to channel '%s' after 3 tries, attempting fallback to RTM", send.message, send.channel)
				s.conn.SendMessage(s.conn.NewOutgoingMessage(send.message, send.channel))
			}
		}
		timeSinceBurst := msgTime.Sub(burstTime)
		if msgTime.Sub(mtimes[windowStartMsg]) < burstWindow || timeSinceBurst < coolDown {
			if timeSinceBurst > coolDown {
				burstTime = msgTime
			}
			s.Log(robot.Debug, "Slack burst limit exceeded, delaying next message by %v", msgDelay)
			// if we've sent `burstMessages` messages in less than the `burstWindow`
			// window, delay the next message by `msgDelay`.
			time.Sleep(msgDelay)
		}
	}
}

func (s *slackConnector) sendMessages(msgs []string, userID, chanID, threadID string, f robot.MessageFormat, msgObject *robot.ConnectorMessage) {
	mtype := getMsgType(msgObject)
	// NOTE: slash command replies are ALWAYS sent back to the user that sent the original message.
	if mtype == msgSlashCmd {
		slashCmd := msgObject.MessageObject.(*slack.SlashCommand)
		userID = slashCmd.UserID
		chanID = slashCmd.ChannelID
		threadID = ""
	}
	for _, msg := range msgs {
		messages <- &sendMessage{
			message: msg,
			user:    userID,
			channel: chanID,
			thread:  threadID,
			format:  f,
			mtype:   mtype,
		}
	}
}

// SetUserMap takes a map of username to userID mappings, built from the UserRoster
// of robot.yaml
func (s *slackConnector) SetUserMap(umap map[string]string) {
	s.Lock()
	s.botUserMap = umap
	s.Unlock()
	s.updateUserList("")
}

// SendProtocolChannelMessage sends a message to a channel
func (s *slackConnector) SendProtocolChannelThreadMessage(ch, thr, msg string, f robot.MessageFormat, msgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	msgs := s.slackifyMessage("", msg, f, msgObject)
	if chanID, ok := s.ExtractID(ch); ok {
		s.sendMessages(msgs, "", chanID, thr, f, msgObject)
		return
	}
	if chanID, ok := s.chanID(ch); ok {
		s.sendMessages(msgs, "", chanID, thr, f, msgObject)
		return
	}
	s.Log(robot.Error, "Slack channel ID not found for: %s", ch)
	return robot.ChannelNotFound
}

// SendProtocolChannelMessage sends a message to a channel
func (s *slackConnector) SendProtocolUserChannelThreadMessage(uid, u, ch, thr, msg string, f robot.MessageFormat, msgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	var userID, chanID string
	var ok bool
	if chanID, ok = s.ExtractID(ch); !ok {
		chanID, ok = s.chanID(ch)
	}
	if !ok {
		s.Log(robot.Error, "Slack channel ID not found for: %s", ch)
		return robot.ChannelNotFound
	}
	if userID, ok = s.ExtractID(uid); !ok {
		userID, ok = s.userID(u, false)
	}
	if !ok {
		s.Log(robot.Error, "Slack user ID not found for: %s", uid)
		return robot.UserNotFound
	}
	// This gets converted to <@userID> in slackifyMessage
	prefix := "<@" + userID + ">: "
	msgs := s.slackifyMessage(prefix, msg, f, msgObject)
	s.sendMessages(msgs, userID, chanID, thr, f, msgObject)
	return
}

// SendProtocolUserMessage sends a direct message to a user
func (s *slackConnector) SendProtocolUserMessage(u string, msg string, f robot.MessageFormat, msgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	var userID string
	var ok bool
	if userID, ok = s.ExtractID(u); !ok {
		userID, ok = s.userID(u, false)
	}
	if !ok {
		s.Log(robot.Error, "No slack user ID found for user: %s", u)
		ret = robot.UserNotFound
	}
	var userIMchanstr string
	var userIMchan *slack.Channel
	var err error
	userIMchanstr, ok = s.userIMID(userID)
	if !ok {
		s.Log(robot.Warn, "No slack IM channel found for user: %s, ID: %s trying to open IM", u, userID)
		ocParam := slack.OpenConversationParameters{
			ChannelID: "",
			ReturnIM:  false,
			Users:     []string{userID},
		}
		userIMchan, _, _, err = s.api.OpenConversation(&ocParam)
		userIMchanstr = userIMchan.Conversation.ID

		if err != nil {
			s.Log(robot.Error, "Unable to open a slack IM channel to user: %s, ID: %s", u, userID)
			ret = robot.FailedMessageSend
		}
	}
	if ret != robot.Ok {
		return
	}
	msgs := s.slackifyMessage("", msg, f, msgObject)
	s.sendMessages(msgs, "", userIMchanstr, "", f, msgObject)
	return robot.Ok
}

// JoinChannel joins a channel given it's human-readable name, e.g. "general"
func (s *slackConnector) JoinChannel(c string) (ret robot.RetVal) {
	chanID, ok := s.chanID(c)
	if !ok {
		s.Log(robot.Error, "Slack channel ID not found for: %s", c)
		return robot.ChannelNotFound
	}
	if socketmodeEnabled {
		_, _, _, err := s.api.JoinConversation(chanID)
		if err != nil {
			s.Log(robot.Error, "Joining channel '%s': %v", c, err)
		} else {
			s.Log(robot.Debug, "Joined channel %s/%s", c, chanID)
		}
	} else {
		s.Log(robot.Debug, "Slack RTM robots can't join channels, skipping join for %s/%s", c, chanID)
	}
	return robot.Ok
}

// FormatHelp returns a helpline formatted for the terminal connector.
func (s *slackConnector) FormatHelp(input string) string {
	arr := strings.SplitN(input, " - ", 2)
	if len(arr) != 2 {
		return "`" + input + "`"
	}
	return "`" + arr[0] + "` - " + arr[1]
}

func (s *slackConnector) DefaultHelp() []string {
	return []string{
		"/(bot) help <keyword> - get help for the provided <keyword>",
		"/(bot) help-all - help for all commands available in this channel, including global commands",
	}
}
</file_content file: gopherbot-main/connectors/slack/connectorMethods.go>
<preamble file: gopherbot-main/connectors/slack/incomingMsgs.go>

</preamble>
<file_content file: gopherbot-main/connectors/slack/incomingMsgs.go>
package slack

import (
	"time"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
)

// processMessageSocketMode examines incoming messages, removes extra slack cruft, and
// routes them to the appropriate bot method.
func (s *slackConnector) processMessageSocketMode(msg *slackevents.MessageEvent) {
	s.Log(robot.Trace, "Message received: %v", msg)

	// Channel is always part of the root message; if subtype is
	// message_changed, text and user are part of the submessage
	chanID := msg.Channel
	var userID string
	timestamp := time.Now()
	var message slackevents.MessageEvent
	ci, ok := s.getChannelInfo(chanID)
	if !ok {
		s.Log(robot.Error, "Couldn't find channel info for channel ID", chanID)
		return
	}
	if msg.SubType == "message_changed" {
		message = *msg.Message
		userID = message.User
		if userID == "" {
			if message.BotID != "" {
				userID = message.BotID
			}
		}
		lastlookup := userlast{userID, chanID}
		lastmsgtime.Lock()
		msgtime, exists := lastmsgtime.m[lastlookup]
		lastmsgtime.Unlock()
		if exists && timestamp.Sub(msgtime) < ignorewindow {
			s.Log(robot.Debug, "Ignoring edited message \"%s\" arriving within the ignorewindow: %v", msg.Message.Text, ignorewindow)
			return
		}
		s.Log(robot.Debug, "SubMessage (edited message) received: %v", message)
	} else if msg.SubType == "message_deleted" {
		s.Log(robot.Debug, "Ignoring deleted message in channel '%s'", chanID)
		return
	} else if len(msg.SubType) > 0 && !validSubtype(msg.SubType) {
		s.Log(robot.Warn, "Ignoring message with unknown/unhandled subtype '%s'", msg.SubType)
		return
	} else {
		message = *msg
		userID = message.User
		if len(userID) == 0 {
			if message.BotID != "" {
				userID = message.BotID
			} else if ci.IsIM {
				userID, _ = s.imUserID(chanID)
			}
		}
		lastlookup := userlast{userID, chanID}
		lastmsgtime.Lock()
		lastmsgtime.m[lastlookup] = timestamp
		lastmsgtime.Unlock()
	}
	if len(userID) == 0 {
		s.Log(robot.Debug, "Zero-length userID, ignoring message")
		return
	}
	text := message.Text
	messageID := message.TimeStamp
	ts := message.TimeStamp
	tts := message.ThreadTimeStamp
	threadID := tts
	threadedMessage := false
	if len(tts) == 0 {
		threadID = ts
	} else {
		threadedMessage = true
	}
	// some bot messages don't have any text, so check for a fallback
	if text == "" && len(msg.Attachments) > 0 {
		text = msg.Attachments[0].Fallback
	}
	text = s.processText(text)
	botMsg := &robot.ConnectorMessage{
		Protocol:        "slack",
		UserID:          userID,
		ChannelID:       chanID,
		MessageID:       messageID,
		ThreadID:        threadID,
		ThreadedMessage: threadedMessage,
		DirectMessage:   ci.IsIM,
		BotMessage:      false,
		MessageText:     text,
		MessageObject:   msg,
		Client:          s.api,
	}
	userName, ok := s.userName(userID)
	if !ok {
		s.Log(robot.Debug, "Couldn't find user name for user ID", userID)
	} else {
		botMsg.UserName = userName
	}
	if !ci.IsIM {
		botMsg.ChannelName = ci.Name
	}
	if userID == s.botUserID {
		botMsg.SelfMessage = true
		s.Log(robot.Trace, "Forwarding slack return message '%s' from the robot %s/%s", messageID, userName, userID)
	}
	s.IncomingMessage(botMsg)
}

// processSlashCmdSocketMode examines incoming /<foo> messages routed to the robot,
// removes extra slack cruft, and routes them to the appropriate bot method.
func (s *slackConnector) processSlashCmdSocketMode(cmd *slack.SlashCommand) {
	s.Log(robot.Trace, "Slash command received: %+v", cmd)
	chanID := cmd.ChannelID
	userID := cmd.UserID
	ci, ok := s.getChannelInfo(chanID)
	if !ok {
		s.Log(robot.Error, "Couldn't find channel info for channel ID", chanID)
		return
	}
	text := s.processText(cmd.Text)
	botMsg := &robot.ConnectorMessage{
		Protocol:  "slack",
		UserID:    userID,
		ChannelID: chanID,
		// ThreadID should be empty, and ThreadedMessage always false
		DirectMessage: ci.IsIM,
		BotMessage:    true,
		HiddenMessage: true,
		MessageText:   text,
		MessageObject: cmd,
		Client:        s.api,
	}
	userName, ok := s.userName(userID)
	if !ok {
		s.Log(robot.Debug, "Couldn't find user name for user ID", userID)
	} else {
		botMsg.UserName = userName
	}
	if !ci.IsIM {
		botMsg.ChannelName = ci.Name
	}
	s.IncomingMessage(botMsg)
}

// processMessageRTM examines incoming messages, removes extra slack cruft, and
// routes them to the appropriate bot method.
func (s *slackConnector) processMessageRTM(msg *slack.MessageEvent) {
	s.Log(robot.Trace, "Message received: %v", msg.Msg)

	// Channel is always part of the root message; if subtype is
	// message_changed, text and user are part of the submessage
	chanID := msg.Channel
	var userID string
	timestamp := time.Now()
	var message slack.Msg
	ci, ok := s.getChannelInfo(chanID)
	if !ok {
		s.Log(robot.Error, "Couldn't find channel info for channel ID", chanID)
		return
	}
	if msg.Msg.SubType == "message_changed" {
		message = *msg.SubMessage
		userID = message.User
		if userID == "" {
			if message.BotID != "" {
				userID = message.BotID
			}
		}
		lastlookup := userlast{userID, chanID}
		lastmsgtime.Lock()
		msgtime, exists := lastmsgtime.m[lastlookup]
		lastmsgtime.Unlock()
		if exists && timestamp.Sub(msgtime) < ignorewindow {
			s.Log(robot.Debug, "Ignoring edited message \"%s\" arriving within the ignorewindow: %v", msg.SubMessage.Text, ignorewindow)
			return
		}
		s.Log(robot.Debug, "SubMessage (edited message) received: %v", message)
	} else if msg.Msg.SubType == "message_deleted" {
		s.Log(robot.Debug, "Ignoring deleted message in channel '%s'", chanID)
		return
	} else {
		message = msg.Msg
		userID = message.User
		if len(userID) == 0 {
			if message.BotID != "" {
				userID = message.BotID
			} else if ci.IsIM {
				userID, _ = s.imUserID(chanID)
			}
		}
		lastlookup := userlast{userID, chanID}
		lastmsgtime.Lock()
		lastmsgtime.m[lastlookup] = timestamp
		lastmsgtime.Unlock()
	}
	if len(userID) == 0 {
		s.Log(robot.Debug, "Zero-length userID, ignoring message")
		return
	}
	messageID := msg.Timestamp
	text := message.Text
	// some bot messages don't have any text, so check for a fallback
	if text == "" && len(msg.Attachments) > 0 {
		text = msg.Attachments[0].Fallback
	}
	text = s.processText(text)
	ts := msg.Timestamp
	tts := msg.ThreadTimestamp
	threadID := tts
	threadedMessage := false
	if len(tts) == 0 {
		threadID = ts
	} else {
		threadedMessage = true
	}
	botMsg := &robot.ConnectorMessage{
		Protocol:        "slack",
		UserID:          userID,
		ChannelID:       chanID,
		MessageID:       messageID,
		ThreadID:        threadID,
		ThreadedMessage: threadedMessage,
		DirectMessage:   ci.IsIM,
		BotMessage:      false,
		MessageText:     text,
		MessageObject:   msg,
		Client:          s.api,
	}
	userName, ok := s.userName(userID)
	if !ok {
		s.Log(robot.Debug, "Couldn't find user name for user ID", userID)
	} else {
		botMsg.UserName = userName
	}
	if !ci.IsIM {
		botMsg.ChannelName = ci.Name
	}
	if userID == s.botUserID {
		botMsg.SelfMessage = true
		s.Log(robot.Trace, "Forwarding slack return message '%s' from the robot %s/%s", messageID, userName, userID)
	}
	s.IncomingMessage(botMsg)
}
</file_content file: gopherbot-main/connectors/slack/incomingMsgs.go>
<preamble file: gopherbot-main/connectors/slack/messages.go>

</preamble>
<file_content file: gopherbot-main/connectors/slack/messages.go>
package slack

/* util has most of the struct, type, and const definitions, as well as
most of the internal methods. */

import (
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/slack-go/slack"
)

// Soft hyphen. *shrug*
const escapePad = "\u00AD"

type userlast struct {
	user, channel string
}

var lastmsgtime = struct {
	m map[userlast]time.Time
	sync.Mutex
}{
	make(map[userlast]time.Time),
	sync.Mutex{},
}

// If we get back an edited message from a user in a channel within the
// ignorewindow ... well, we ignore it. The problem is, the Slack service will
// on occasion edit a user message, and the robot was seeing this as the user
// sending the same command twice in short order.
const ignorewindow = 3 * time.Second

var mentionMatch = `[0-9A-Za-z](?:[-_0-9A-Za-z.]{0,19}[_0-9A-Za-z])?`
var mentionRe = regexp.MustCompile(`@` + mentionMatch + `\b`)
var usernameRe = regexp.MustCompile(`^` + mentionMatch + `$`)

func (s *slackConnector) replaceMentions(msg string) string {
	return mentionRe.ReplaceAllStringFunc(msg, func(mentioned string) string {
		mentioned = mentioned[1:]
		switch mentioned {
		case "here", "channel", "everyone":
			return "<!" + mentioned + ">"
		}
		replace, ok := s.userID(mentioned, true)
		if ok {
			return "<@" + replace + ">"
		}
		return mentioned
	})
}

// normalizeBackticks adds leading and trailing newlines to triple backticks (```)
// If the leading or trailing newline is already present, it doesn't duplicate it.
func normalizeBackticks(input string) string {
	// Regular expression that matches a triple backtick with any character (or none) on either side
	re := regexp.MustCompile(".{0,1}```.{0,1}")

	// Replace function adds newlines before and after every triple backtick
	// If the newline is already present, it doesn't duplicate it
	return re.ReplaceAllStringFunc(input, func(s string) string {
		if s == "\n```\n" {
			return s
		}
		if strings.Count(s, "`") != 3 {
			return s
		}
		leading := string(s[0])
		trailing := string(s[len(s)-1])
		if leading == "`" {
			leading = ""
		} else if leading != "\n" {
			leading = leading + "\n"
		}
		if trailing == "`" {
			trailing = ""
		} else if trailing != "\n" {
			trailing = "\n" + trailing
		}
		return leading + "```" + trailing
	})
}

func optAddBlockDelimeters(inside_block bool, chunk string) (bool, string) {
	delimeters := strings.Count(chunk, "```")
	if inside_block {
		if strings.HasPrefix(chunk, "\n") {
			chunk = "```" + chunk
		} else {
			chunk = "```\n" + chunk
		}
	}
	if delimeters%2 == 1 {
		inside_block = !inside_block
	}
	if inside_block {
		if strings.HasSuffix(chunk, "\n") {
			chunk = chunk + "```"
		} else {
			chunk = chunk + "\n```"
		}
	}
	return inside_block, chunk
}

func (s *slackConnector) processRawMessage(msg string) string {
	var result strings.Builder
	inside_block := false
	chunks := strings.Split(msg, "```")
	num_chunks := len(chunks)

	for i, chunk := range chunks {
		if !inside_block {
			chunk = s.replaceMentions(chunk)
		}
		result.WriteString(chunk)
		// If there are more chunks, write the delimeter and flip the bool
		if i != num_chunks-1 {
			result.WriteString("```")
			inside_block = !inside_block
		}
	}

	if inside_block {
		result.WriteString("\n```")
	}

	return result.String()
}

// slackifyMessage replaces @username with the slack-internal representation, handles escaping,
// takes care of formatting, and segments the message if needed.
func (s *slackConnector) slackifyMessage(prefix, msg string, f robot.MessageFormat, msgObject *robot.ConnectorMessage) []string {
	maxSize := slack.MaxMessageTextLength - 490

	if f == robot.Raw {
		msg = normalizeBackticks(msg)
		msg = s.processRawMessage(msg)
	} else {
		msg = strings.Replace(msg, "&", "&amp;", -1)
		msg = strings.Replace(msg, "<", "&lt;", -1)
		msg = strings.Replace(msg, ">", "&gt;", -1)
	}
	if f == robot.Variable {
		// 'escape' special chars that aren't covered by disabling markdown.
		for _, padChar := range []string{"`", "*", "_", ":"} {
			paddedString := escapePad + padChar
			msg = strings.Replace(msg, padChar, paddedString, -1)
		}
	}
	mtype := getMsgType(msgObject)
	if len(prefix) > 0 && mtype != msgSlashCmd {
		msg = prefix + msg
	}
	if f == robot.Fixed {
		f_prefix := "```\n"
		if strings.HasPrefix(msg, "\n") {
			f_prefix = "```"
		}
		f_suffix := "\n```"
		if strings.HasSuffix(msg, "\n") {
			f_suffix = "```"
		}
		msg = f_prefix + msg + f_suffix
	}

	msgLen := len(msg)
	if msgLen <= maxSize {
		return []string{msg}
	}
	// It's too big, gotta chop it up. We will send at most maxMessageSplit
	// messages, plus "(message truncated)".
	msgs := make([]string, 0, s.maxMessageSplit+1)
	s.Log(robot.Info, "Message too long, segmenting: %d bytes", msgLen)
	// Chop it up into <=maxSize pieces
	var chunk string
	inside_block := false
	for len(msg) > maxSize && len(msgs) < s.maxMessageSplit {
		lineEnd := strings.LastIndexByte(msg[:maxSize], '\n')
		if lineEnd == -1 { // no newline in this chunk
			chunk = msg[:maxSize]
			msg = msg[maxSize:]
		} else {
			chunk = msg[:lineEnd]
			msg = msg[lineEnd+1:] // skip over the newline
		}
		inside_block, chunk = optAddBlockDelimeters(inside_block, chunk)
		msgs = append(msgs, chunk)
	}
	if len(msgs) == s.maxMessageSplit { // we've maxed out
		if len(msg) > 0 { // if there's anything left, we've truncated
			msgs = append(msgs, "(message too long, truncated)")
		}
	} else { // the last chunk fits
		_, chunk = optAddBlockDelimeters(inside_block, msg)
		msgs = append(msgs, chunk)
	}
	return msgs
}

var reAddedLinks = regexp.MustCompile(`<https?://[\w-./]+\|([\w-./]+)>`) // match a slack-inserted link
var reLinks = regexp.MustCompile(`<(https?://[.\w-:/?=~]+)>`)            // match a link where slack added <>
var reUser = regexp.MustCompile(`<@U[A-Z0-9]{7,21}>`)                    // match a @user mention
var reMailToLink = regexp.MustCompile(`<mailto:[^|]+\|([\w-./@]+)>`)     // match mailto links

// I don't love this: if the message text is '<foo>', the robot sees '&lt;foo&gt;'. HOWEVER,
// if the message text is '&lt;foo&gt;', the robot STILL sees '&lt;foo&gt;'. Still, '<' and '>'
// are more useful than '&lt;' and '&gt;', so we always send the angle brackets.
var reLeftAngle = regexp.MustCompile(`&lt;`)
var reRightAngle = regexp.MustCompile(`&gt;`)

func (s *slackConnector) processText(text string) string {
	// Remove auto-links - chatbots don't want those
	text = reAddedLinks.ReplaceAllString(text, "$1")
	text = reLinks.ReplaceAllString(text, "$1")
	text = reMailToLink.ReplaceAllString(text, "$1")
	// Convert '&lt;' and '&gt;' to angle brackets.
	text = reLeftAngle.ReplaceAllString(text, "<")
	text = reRightAngle.ReplaceAllString(text, ">")

	mentions := reUser.FindAllString(text, -1)
	if len(mentions) != 0 {
		mset := make(map[string]bool)
		for _, mention := range mentions {
			mset[mention] = true
		}
		for mention := range mset {
			mID := mention[2 : len(mention)-1]
			replace, ok := s.userName(mID)
			if !ok {
				s.Log(robot.Warn, "Couldn't find username for mentioned", mID)
				continue
			}
			text = strings.Replace(text, mention, "@"+replace, -1)
		}
	}
	return text
}

func validSubtype(st string) bool {
	switch st {
	case "bot_message", "message_replied", "file_share":
		return true
	default:
		return false
	}
}
</file_content file: gopherbot-main/connectors/slack/messages.go>
<preamble file: gopherbot-main/connectors/slack/plug.go>

</preamble>
<file_content file: gopherbot-main/connectors/slack/plug.go>
package slack

import (
	"regexp"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
)

var idre = regexp.MustCompile(`slack id <@(.*)>`)

var slackspec = robot.PluginSpec{
	Name:    "slackutil",
	Handler: slackplugin,
}

// Define the handler function
func slackutil(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	m := r.GetMessage()
	switch command {
	// This isn't really necessary
	case "init":
		// ignore
	case "identify":
		if m.Protocol != robot.Slack {
			r.Say("Sorry, that only works with Slack")
			return
		}
		var sid string
		switch msg := m.Incoming.MessageObject.(type) {
		case *slack.MessageEvent:
			sid = idre.FindStringSubmatch(msg.Text)[1]
		case *slackevents.MessageEvent:
			sid = idre.FindStringSubmatch(msg.Text)[1]
		}
		r.Say("User %s has Slack internal ID %s", args[0], sid)
	}
	return
}

var slackplugin = robot.PluginHandler{
	Handler: slackutil,
}
</file_content file: gopherbot-main/connectors/slack/plug.go>
<preamble file: gopherbot-main/connectors/slack/static.go>

</preamble>
<file_content file: gopherbot-main/connectors/slack/static.go>
package slack

import "github.com/lnxjedi/gopherbot/v2/bot"

func init() {
	bot.RegisterPlugin("slackutil", slackplugin)
	bot.RegisterConnector("slack", Initialize)
}
</file_content file: gopherbot-main/connectors/slack/static.go>
<preamble file: gopherbot-main/connectors/slack/util.go>

</preamble>
<file_content file: gopherbot-main/connectors/slack/util.go>
package slack

/* util has most of the struct, type, and const definitions, as well as
most of the internal methods. */

import (
	"strings"
	"sync"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
	"github.com/slack-go/slack/socketmode"
)

const optimeout = 1 * time.Minute

// slackConnector holds all the relevant data about a connection
type slackConnector struct {
	api             *slack.Client
	conn            *slack.RTM
	sock            *socketmode.Client
	maxMessageSplit int                       // The maximum # of ~4000 byte messages to send before truncating
	running         bool                      // set on call to Run
	botName         string                    // human-readable name of bot
	botFullName     string                    // human-readble full name of the bot
	botID           string                    // slack internal bot ID
	botUserID       string                    // slack internal user ID for bot
	appID           string                    // app ID for socketmode bots
	name            string                    // name for this connector
	teamID          string                    // Slack unique Team ID, for identifying team users
	robot.Handler                             // bot API for connectors
	sync.RWMutex                              // shared mutex for locking connector data structures
	channelInfo     map[string]*slack.Channel // info about all the channels the robot knows about
	channelToID     map[string]string         // map from channel names to channel IDs
	idToChannel     map[string]string         // map from channel ID to channel name
	userIDInfo      map[string]*slack.User    // map from user ID to slack.User - everything Slack knows about the user
	botUserMap      map[string]string         // gopherbot-engine provided mappings of username to userID
	userMap         map[string]string         // map from user name to user ID
	userIDMap       map[string]string         // map from user ID to engine-provided username, for resolving @foo
	userIDToIM      map[string]string         // map from user ID to IM channel ID
	imToUserID      map[string]string         // map from IM channel ID to user ID
}

type msgType int

const (
	msgNone msgType = iota
	msgRTM
	msgEvent
	msgSlashCmd
)

func getMsgType(msgObject *robot.ConnectorMessage) (mtype msgType) {
	switch msgObject.MessageObject.(type) {
	case *slackevents.MessageEvent:
		mtype = msgEvent
	case *slack.SlashCommand:
		mtype = msgSlashCmd
	case *slack.MessageEvent:
		mtype = msgRTM
	default:
		mtype = msgNone
	}
	return
}

// updateUserList gets an updated list of users from Slack and creates
// maps from userID to *slack.User and from user name to userID. It can also
// be called from userID and userName lookup functions; "u:ID" means return
// the user name for the given ID, "i:user" means return the ID for the given
// user name.
func (s *slackConnector) updateUserList(want string) (ret string) {
	deadline := time.Now().Add(optimeout)
	var (
		err      error
		userlist []slack.User
	)

	userMap := make(map[string]string)
	userIDMap := make(map[string]string)
	var botUserMap map[string]string
	s.RLock()
	if s.botUserMap != nil {
		botUserMap = s.botUserMap
	}
	s.RUnlock()
	// Mapping information provided by the engine is canonical;
	// we only take info from Slack if it's not already provided.
	for name, id := range botUserMap {
		userMap[name] = id
		userIDMap[id] = name
	}
	userIDInfo := make(map[string]*slack.User)
	for tries := uint(0); time.Now().Before(deadline); tries++ {
		// TODO: Check GetUsers - do we need to worry about paging?
		userlist, err = s.api.GetUsers()
		if err == nil {
			break
		}
	}
	if err != nil {
		s.Log(robot.Error, "Protocol timeout updating users: %v", err)
	}
	for i, user := range userlist {
		if user.TeamID == s.teamID {
			if match_id, ok := userMap[user.Name]; ok {
				if user.ID != match_id {
					s.Log(robot.Error, "Found Slack user '%s' with id '%s' duplicating user from roster with id '%s', ignoring!", user.Name, user.ID, match_id)
					continue
				}
			}
			userIDInfo[user.ID] = &userlist[i]
			if _, ok := userIDMap[user.ID]; !ok {
				if !usernameRe.MatchString(user.Name) {
					s.Log(robot.Warn, "Slack username '%s' doesn't match against the slack mentionMatch '%s'", user.Name, mentionMatch)
				}
				s.Log(robot.Debug, "UpdateUserList recorded user: %s/%s", user.Name, user.ID)
				userMap[user.Name] = user.ID
				userIDMap[user.ID] = user.Name
			}
		}
	}
	w := strings.Split(want, ":")
	t := w[0]
	switch t {
	case "i": // want user ID
		u := w[1]
		if r, ok := userMap[u]; ok {
			ret = r
		} else {
			return "" // see above
		}
	case "u": // want user name
		i := w[1]
		if name, ok := userIDMap[i]; ok {
			ret = name
		} else {
			// Don't update maps on failed lookup, to avoid thrashing
			// locks on repeated lookups of non-users
			return ""
		}
	}
	s.Lock()
	s.userIDInfo = userIDInfo
	s.userMap = userMap
	s.userIDMap = userIDMap
	s.Unlock()
	s.Log(robot.Info, "User maps updated, found %d users", len(userMap))
	return
}

func (s *slackConnector) userID(u string, isMention bool) (i string, ok bool) {
	s.RLock()
	userID, ok := s.userMap[u]
	s.RUnlock()
	if !ok {
		if isMention {
			s.Log(robot.Error, "Failed ID lookup for user '%s' (invalid @mention)", u)
		} else {
			i := s.updateUserList("i:" + u)
			if len(i) > 0 {
				return i, true
			}
			s.Log(robot.Error, "Failed ID lookup for user '%s' after updating userlist", u)
		}
		return "", false
	}
	return userID, ok
}

// Eventually Slack won't know what usernames are anymore - but
// this function will still be needed by processMessage to resolve
// mentions of the robot to @botname, since the connector should
// always know the robot's name.
func (s *slackConnector) userName(i string) (user string, found bool) {
	s.RLock()
	user, found = s.userIDMap[i]
	// NOTE: The slack-supplied bot name probably doesn't match what you want
	if !found && (i == s.botUserID) {
		name := s.botName
		s.RUnlock()
		return name, true
	}
	if strings.HasPrefix(i, "B") {
		s.RUnlock()
		return
	}
	s.RUnlock()
	if !found {
		u := s.updateUserList("u:" + i)
		if len(u) == 0 {
			s.Log(robot.Error, "Failed username lookup for ID '%s'", i)
			return "", false
		}
		user = u
		found = true
	}
	return
}

func (s *slackConnector) updateChannelMaps(want string) (ret string) {
	var (
		err    error
		cursor string
	)
	limit := 100

	deadline := time.Now().Add(optimeout)

	channelList := make([]slack.Channel, 0)
pageLoop:
	for {
		for tries := uint(0); time.Now().Before(deadline); tries++ {
			var cl []slack.Channel
			params := &slack.GetConversationsParameters{
				Cursor:          cursor,
				ExcludeArchived: true,
				Limit:           limit,
				Types: []string{
					"public_channel",
					"private_channel",
					"mpim",
					"im",
				},
			}
			cl, cursor, err = s.api.GetConversations(params)
			if len(cl) > 0 {
				channelList = append(channelList, cl...)
			}
			if err == nil && len(cursor) == 0 {
				break pageLoop
			}
			if len(cursor) > 0 {
				deadline = time.Now().Add(optimeout)
			}
		}
		if err != nil {
			s.Log(robot.Error, "Protocol timeout updating channels: %v", err)
			break
		}
	}
	userIMMap := make(map[string]string)
	userIMIDMap := make(map[string]string)
	chanMap := make(map[string]string)
	chanIDMap := make(map[string]string)
	chanInfo := make(map[string]*slack.Channel)
	for i, channel := range channelList {
		chanInfo[channel.ID] = &channelList[i]
		if channel.IsIM {
			s.Log(robot.Debug, "UpdateChannelMaps recorded DM channel for user: %s", channel.User)
			userIMMap[channel.User] = channel.ID
			userIMIDMap[channel.ID] = channel.User
		} else {
			s.Log(robot.Debug, "UpdateChannelMaps recorded channel: %s", channel.Name)
			chanMap[channel.Name] = channel.ID
			chanIDMap[channel.ID] = channel.Name
		}
	}
	w := strings.Split(want, ":")
	t := w[0]
	switch t {
	case "di":
		c := w[1]
		if r, ok := userIMIDMap[c]; ok {
			ret = r
		} else {
			// Don't update maps on failed lookup, to avoid thrashing
			// locks on repeated lookups of non-users
			return ""
		}
	case "dc":
		i := w[1]
		if r, ok := userIMMap[i]; ok {
			ret = r
		} else {
			return "" // see above
		}
	case "ci":
		c := w[1]
		if r, ok := chanMap[c]; ok {
			ret = r
		} else {
			return ""
		}
	case "cc":
		i := w[1]
		if r, ok := chanIDMap[i]; ok {
			ret = r
		} else {
			return ""
		}
	}
	s.Lock()
	s.channelInfo = chanInfo
	s.userIDToIM = userIMMap
	s.imToUserID = userIMIDMap
	s.channelToID = chanMap
	s.idToChannel = chanIDMap
	s.Unlock()
	s.Log(robot.Info, "Channel maps updated, recorded %d channels", len(chanMap))
	return
}

func (s *slackConnector) getChannelInfo(i string) (c *slack.Channel, ok bool) {
	s.RLock()
	c, ok = s.channelInfo[i]
	s.RUnlock()
	if !ok {
		s.updateChannelMaps("")
		s.RLock()
		c, ok = s.channelInfo[i]
		s.RUnlock()
		if !ok {
			s.Log(robot.Error, "Failed lookup of channel info from ID: %s", i)
			return nil, false
		}
	}
	return c, ok
}

// Get IM conversation from user ID
func (s *slackConnector) userIMID(i string) (c string, ok bool) {
	s.RLock()
	c, ok = s.userIDToIM[i]
	s.RUnlock()
	if !ok {
		c = s.updateChannelMaps("dc:" + i)
		if len(i) == 0 {
			s.Log(robot.Error, "Failed lookup of conversation from user ID: %s", i)
			return "", false
		}
	}
	return c, ok
}

// Get user ID from IM conversation
func (s *slackConnector) imUserID(c string) (i string, found bool) {
	s.RLock()
	i, found = s.imToUserID[c]
	s.RUnlock()
	if !found {
		i = s.updateChannelMaps("di:" + c)
		if len(i) == 0 {
			s.Log(robot.Error, "Failed lookup of user ID from IM: %s", c)
			return "", false
		}
		found = true
	}
	return
}

func (s *slackConnector) chanID(c string) (i string, ok bool) {
	s.RLock()
	i, ok = s.channelToID[c]
	s.RUnlock()
	if !ok {
		c = s.updateChannelMaps("ci:" + c)
		if len(i) == 0 {
			s.Log(robot.Error, "Failed lookup of channel ID for '%s'", c)
			return "", false
		}
	}
	return i, ok
}

func (s *slackConnector) channelName(i string) (c string, ok bool) {
	s.RLock()
	c, ok = s.idToChannel[i]
	s.RUnlock()
	if !ok {
		c = s.updateChannelMaps("cc:" + i)
		if len(i) == 0 {
			s.Log(robot.Error, "Failed lookup of channel name from ID: %s", i)
			return "", false
		}
	}
	return c, ok
}
</file_content file: gopherbot-main/connectors/slack/util.go>
<preamble file: gopherbot-main/connectors/test/connector.go>

</preamble>
<file_content file: gopherbot-main/connectors/test/connector.go>
// Package test implements a test connector for automated testing.

package test

import (
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/lnxjedi/gopherbot/robot"
)

// TestMessage is for sending messages to the robot
type TestMessage struct {
	User, Channel, Message string
}

// TestConnector holds all the relevant data about a connection
type TestConnector struct {
	botName       string            // human-readable name of bot
	botFullName   string            // human-readble full name of the bot
	botID         string            // slack internal bot ID
	users         []testUser        // configured users
	channels      []string          // the channels the robot is in
	listener      chan *TestMessage // input channel for test functions to send messages from a user
	speaking      chan *TestMessage // output channel for test functions to get messages from the bot
	test          *testing.T        // for the connector to log
	robot.Handler                   // bot API for connectors
	sync.RWMutex                    // shared mutex for locking connector data structures
}

// Run starts the main loop for the test connector
func (tc *TestConnector) Run(stop <-chan struct{}) {

loop:
	for {
		select {
		case <-stop:
			tc.Log(robot.Debug, "Received stop in connector")
			tc.test.Log("Received stop in connector")
			break loop
		case msg := <-tc.listener:
			var userName, channelID string
			i, exists := userIDMap[msg.User]
			if exists {
				userName = tc.users[i].Name
			}
			direct := false
			if len(msg.Channel) > 0 {
				channelID = "#" + msg.Channel
			} else {
				direct = true
			}
			botMsg := &robot.ConnectorMessage{
				Protocol:      "test",
				UserName:      userName,
				UserID:        msg.User,
				ChannelName:   msg.Channel,
				ChannelID:     channelID,
				DirectMessage: direct,
				MessageText:   msg.Message,
				MessageObject: msg,
				Client:        tc,
			}
			tc.IncomingMessage(botMsg)
		}
	}
}

// Public 'bot methods all call sendMessage to send a message to a user/channel
func (tc *TestConnector) sendMessage(msg *BotMessage) (ret robot.RetVal) {
	if msg.Channel == "" && msg.User == "" {
		tc.test.Errorf("Invalid empty user and channel")
		return robot.ChannelNotFound
	}
	if msg.Channel != "" { // direct message
		found := false
		tc.RLock()
		for _, channel := range tc.channels {
			if channel == msg.Channel {
				found = true
				break
			}
		}
		tc.RUnlock()
		if !found {
			tc.test.Errorf("Channel not found: %s", msg.Channel)
			return robot.ChannelNotFound
		}
	}
	if msg.User != "" { // speaking in channel, not talking to user
		found := false
		tc.RLock()
		for _, user := range tc.users {
			if user.Name == msg.User {
				found = true
				break
			}
		}
		tc.RUnlock()
		if !found {
			tc.test.Errorf("User not found: %s", msg.User)
			return robot.UserNotFound
		}
	}
	spoken := &TestMessage{
		User:    msg.User,
		Channel: msg.Channel,
	}
	switch msg.Format {
	case robot.Fixed:
		spoken.Message = strings.ToUpper(msg.Message)
	case robot.Variable:
		spoken.Message = strings.ToLower(msg.Message)
	case robot.Raw:
		spoken.Message = msg.Message
	}
	select {
	case tc.speaking <- spoken:
	case <-time.After(200 * time.Millisecond):
		return robot.TimeoutExpired
	}

	return robot.Ok
}
</file_content file: gopherbot-main/connectors/test/connector.go>
<preamble file: gopherbot-main/connectors/test/connectorMethods.go>

</preamble>
<file_content file: gopherbot-main/connectors/test/connectorMethods.go>
package test

import (
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

// BotMessage is for receiving messages from the robot
type BotMessage struct {
	User, Channel, Message string
	Format                 robot.MessageFormat
}

func (tc *TestConnector) getUserInfo(u string) (*testUser, bool) {
	var i int
	var exists bool
	if id, ok := tc.ExtractID(u); ok {
		i, exists = userIDMap[id]
	} else {
		i, exists = userMap[u]
	}
	if exists {
		return &tc.users[i], true
	}
	return nil, false
}

func (tc *TestConnector) getChannel(c string) string {
	if ch, ok := tc.ExtractID(c); ok {
		return strings.TrimPrefix(ch, "#")
	}
	return c
}

// MessageHeard indicates to the user a message was heard;
// for test/terminal it's a noop.
func (tc *TestConnector) MessageHeard(u, c string) {
	return
}

// SetUserMap lets Gopherbot provide a mapping of usernames to user IDs
func (tc *TestConnector) SetUserMap(map[string]string) {
	return
}

// GetProtocolUserAttribute returns a string attribute or nil if slack doesn't
// have that information
func (tc *TestConnector) GetProtocolUserAttribute(u, attr string) (value string, ret robot.RetVal) {
	var user *testUser
	var exists bool
	if user, exists = tc.getUserInfo(u); !exists {
		return "", robot.UserNotFound
	}
	switch attr {
	case "email":
		return user.Email, robot.Ok
	case "internalid":
		return user.InternalID, robot.Ok
	case "realname", "fullname", "real name", "full name":
		return user.FullName, robot.Ok
	case "firstname", "first name":
		return user.FirstName, robot.Ok
	case "lastname", "last name":
		return user.LastName, robot.Ok
	case "phone":
		return user.Phone, robot.Ok
	// that's all the attributes we can currently get from slack
	default:
		return "", robot.AttributeNotFound
	}
}

// SendProtocolChannelMessage sends a message to a channel
func (tc *TestConnector) SendProtocolChannelThreadMessage(ch, thr, mesg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	channel := tc.getChannel(ch)
	msg := &BotMessage{
		User:    "",
		Channel: channel,
		Message: mesg,
		Format:  f,
	}
	return tc.sendMessage(msg)
}

// SendProtocolUserChannelMessage sends a message to a user in a channel
func (tc *TestConnector) SendProtocolUserChannelThreadMessage(uid, uname, ch, thr, mesg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	channel := tc.getChannel(ch)
	msg := &BotMessage{
		User:    uname,
		Channel: channel,
		Message: mesg,
		Format:  f,
	}
	return tc.sendMessage(msg)
}

// SendProtocolUserMessage sends a direct message to a user
func (tc *TestConnector) SendProtocolUserMessage(u string, mesg string, f robot.MessageFormat, dummyMsgObject *robot.ConnectorMessage) (ret robot.RetVal) {
	var user *testUser
	var exists bool
	if user, exists = tc.getUserInfo(u); !exists {
		return robot.UserNotFound
	}
	msg := &BotMessage{
		User:    user.Name,
		Channel: "",
		Message: mesg,
		Format:  f,
	}
	return tc.sendMessage(msg)
}

// JoinChannel joins a channel given it's human-readable name, e.g. "general"
// Only useful for connectors that require it, a noop otherwise
func (tc *TestConnector) JoinChannel(c string) (ret robot.RetVal) {
	return robot.Ok
}

// FormatHelp returns a helpline formatted for the terminal connector.
func (tc *TestConnector) FormatHelp(input string) string {
	return input
}

func (tc *TestConnector) DefaultHelp() []string {
	return []string{}
}
</file_content file: gopherbot-main/connectors/test/connectorMethods.go>
<preamble file: gopherbot-main/connectors/test/init.go>

</preamble>
<file_content file: gopherbot-main/connectors/test/init.go>
package test

import (
	"log"
	"sync"
	"testing"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/lnxjedi/gopherbot/v2/bot"
)

// Global persistent map of user name to user index
var userIDMap = make(map[string]int)
var userMap = make(map[string]int)

// ExportTest lets bot_integration_test safely supply the *testing.T
var ExportTest = struct {
	Test *testing.T
	sync.Mutex
}{}

type testUser struct {
	Name                                        string // username / handle
	InternalID                                  string // connector internal identifier
	Email, FullName, FirstName, LastName, Phone string
}

type config struct {
	BotName     string // the short name used for addressing the robot
	BotFullName string // the full name of the bot
	Users       []testUser
	Channels    []string
}

func init() {
	bot.RegisterConnector("test", Initialize)
}

// Initialize sets up the connector and returns a connector object
func Initialize(handler robot.Handler, l *log.Logger) robot.Connector {
	var c config

	err := handler.GetProtocolConfig(&c)
	if err != nil {
		handler.Log(robot.Fatal, "Unable to retrieve protocol configuration: %v", err)
	}

	for i, u := range c.Users {
		userIDMap[u.InternalID] = i
		userMap[u.Name] = i
	}

	ExportTest.Lock()
	t := ExportTest.Test
	ExportTest.Unlock()

	tc := &TestConnector{
		botName:     c.BotName,
		botFullName: c.BotFullName,
		botID:       "deadbeef", // yes - hex in a string
		users:       c.Users,
		channels:    c.Channels,
		listener:    make(chan *TestMessage),
		speaking:    make(chan *TestMessage),
		test:        t,
	}

	tc.Handler = handler
	tc.SetBotID(tc.botID)
	tc.Log(robot.Info, "Set bot ID to", tc.botID)

	return robot.Connector(tc)
}
</file_content file: gopherbot-main/connectors/test/init.go>
<preamble file: gopherbot-main/connectors/test/testMethods.go>

</preamble>
<file_content file: gopherbot-main/connectors/test/testMethods.go>
package test

import (
	"errors"
	"time"
)

/* testMethods.go - methods specific to the test connector */

// SendBotMessage for tests to send messages to the 'bot
func (tc *TestConnector) SendBotMessage(msg *TestMessage) {
	tc.RLock()
	if msg.Channel != "" {
		exists := false
		for _, ch := range tc.channels {
			if ch == msg.Channel {
				exists = true
				break
			}
		}
		if !exists {
			tc.test.Errorf("Invalid channel: %s", msg.Channel)
		}
	}
	if msg.User == "" {
		tc.test.Errorf("Invalid 0-length user")
	} else {
		exists := false
		for _, u := range tc.users {
			if u.InternalID == msg.User {
				exists = true
			}
		}
		if !exists {
			tc.test.Errorf("Invalid user: %s", msg.User)
		}
	}
	tc.RUnlock()
	select {
	case tc.listener <- msg:
		tc.test.Logf("Message sent to robot: %v", msg)
	case <-time.After(200 * time.Millisecond):
		tc.test.Errorf("Timed out sending; user: \"%s\", channel: \"%s\", message: \"%s\"", msg.User, msg.Channel, msg.Message)
	}
}

// GetBotMessage for tests to get replies
func (tc *TestConnector) GetBotMessage() (*TestMessage, error) {
	select {
	case incoming := <-tc.speaking:
		message := incoming.Message
		if len(incoming.Message) > 16 {
			message = incoming.Message[0:16] + " ..."
		}
		tc.test.Logf("Reply received from robot: u:%s, c:%s, m:%s", incoming.User, incoming.Channel, message)
		time.Sleep(100 * time.Millisecond)
		return incoming, nil
	case <-time.After(4 * time.Second):
		return nil, errors.New("timeout waiting for reply from robot")
	}
}
</file_content file: gopherbot-main/connectors/test/testMethods.go>
<preamble file: gopherbot-main/gb-install-links>

</preamble>
<file_content file: gopherbot-main/gb-install-links>
#!/bin/bash -e

# Trivial EXECUTABLE to symlink gb-* EXECUTABLEs in to $PATH

DEST="$1"

if [ ! "$DEST" ]
then
    echo "Missing required <dest-dir>"
    exit 1
fi

if [ ! -d "$DEST" ]
then
    echo "Not a directory: $DEST"j
    exit 1
fi

if [ ! -w "$DEST" ]
then
    echo "Destination not writable: $DEST"
    exit 1
fi

EXECUTABLE_DIR=$(cd $(dirname "${BASH_SOURCE[0]}") && pwd)

for EXECUTABLE in gopherbot cbot.sh
do
    ln -snf "$EXECUTABLE_DIR/$EXECUTABLE" "$DEST"
done
echo "linked"
</file_content file: gopherbot-main/gb-install-links>
<preamble file: gopherbot-main/get-version.sh>

</preamble>
<file_content file: gopherbot-main/get-version.sh>
#!/bin/bash

# get-version.sh - used by the Makefile to inject the correct
# version in to the Go linker.

if VERSION=$(git describe --exact-match --tags HEAD 2>/dev/null)
then
    echo "-X main.Version=$VERSION"
fi
</file_content file: gopherbot-main/get-version.sh>
<preamble file: gopherbot-main/go.mod>

</preamble>
<file_content file: gopherbot-main/go.mod>
module github.com/lnxjedi/gopherbot/v2

go 1.19

replace github.com/lnxjedi/gopherbot/robot => ./robot

require (
	github.com/aws/aws-sdk-go v1.44.152
	github.com/duosecurity/duo_api_golang v0.0.0-20221117185402-091daa09e19d
	github.com/emersion/go-textwrapper v0.0.0-20200911093747-65d896831594
	github.com/ghodss/yaml v1.0.0
	github.com/joho/godotenv v1.4.0
	github.com/jordan-wright/email v0.0.0-20200121133829-a0b5c5b58bb6
	github.com/lnxjedi/gopherbot/robot v0.0.0-20221211204919-1966e9d9cfec
	github.com/lnxjedi/readline v0.0.0-20200213173224-cdfc6ee4b159
	github.com/pquerna/otp v1.3.0
	github.com/robfig/cron v1.2.0
	github.com/slack-go/slack v0.12.2
	golang.org/x/sys v0.3.0
)

require (
	github.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc // indirect
	github.com/chzyer/test v1.0.0 // indirect
	github.com/gorilla/websocket v1.5.0 // indirect
	github.com/jmespath/go-jmespath v0.4.0 // indirect
	github.com/kr/pretty v0.2.0 // indirect
	github.com/stretchr/testify v1.8.1 // indirect
	gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 // indirect
	gopkg.in/yaml.v2 v2.3.0 // indirect
)

// *** When using a fork - in this case, iaburton's safer-socketmode
replace github.com/slack-go/slack => github.com/lnxjedi/slack v0.1.2

// *** For local Slack lib dev - comment out any other replace for slack above
// replace github.com/slack-go/slack => ../slack
</file_content file: gopherbot-main/go.mod>
<preamble file: gopherbot-main/go.sum>

</preamble>
<file_content file: gopherbot-main/go.sum>
github.com/aws/aws-sdk-go v1.44.152 h1:L9aaepO8wHB67gwuGD8VgIYH/cmQDxieCt7FeLa0+fI=
github.com/aws/aws-sdk-go v1.44.152/go.mod h1:aVsgQcEevwlmQ7qHE9I3h+dtQgpqhFB+i8Phjh7fkwI=
github.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc h1:biVzkmvwrH8WK8raXaxBx6fRVTlJILwEwQGL1I/ByEI=
github.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=
github.com/chzyer/logex v1.2.1 h1:XHDu3E6q+gdHgsdTPH6ImJMIp436vR6MPtH8gP05QzM=
github.com/chzyer/logex v1.2.1/go.mod h1:JLbx6lG2kDbNRFnfkgvh4eRJRPX1QCoOIWomwysCBrQ=
github.com/chzyer/test v1.0.0 h1:p3BQDXSxOhOG0P9z6/hGnII4LGiEPOYBhs8asl/fC04=
github.com/chzyer/test v1.0.0/go.mod h1:2JlltgoNkt4TW/z9V/IzDdFaMTM2JPIi26O1pF38GC8=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/duosecurity/duo_api_golang v0.0.0-20221117185402-091daa09e19d h1:DdF2JKufY7l8IBJuGeanPFR5gVpWJfEh1LWJFM/zDas=
github.com/duosecurity/duo_api_golang v0.0.0-20221117185402-091daa09e19d/go.mod h1:jI+QUTOK3wqIOrUl0Cwnwlgc/P6vs6pZOuQY3aKggwg=
github.com/emersion/go-textwrapper v0.0.0-20200911093747-65d896831594 h1:IbFBtwoTQyw0fIM5xv1HF+Y+3ZijDR839WMulgxCcUY=
github.com/emersion/go-textwrapper v0.0.0-20200911093747-65d896831594/go.mod h1:aqO8z8wPrjkscevZJFVE1wXJrLpC5LtJG7fqLOsPb2U=
github.com/ghodss/yaml v1.0.0 h1:wQHKEahhL6wmXdzwWG11gIVCkOv05bNOh+Rxn0yngAk=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-test/deep v1.0.4 h1:u2CU3YKy9I2pmu9pX0eq50wCgjfGIt539SqR7FbHiho=
github.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=
github.com/google/go-cmp v0.5.7 h1:81/ik6ipDQS2aGcBfIN5dHDB36BwrStyeAQquSYCV4o=
github.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=
github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=
github.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=
github.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=
github.com/jmespath/go-jmespath/internal/testify v1.5.1 h1:shLQSRRSCCPj3f2gpwzGwWFoC7ycTf1rcQZHOlsJ6N8=
github.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=
github.com/joho/godotenv v1.4.0 h1:3l4+N6zfMWnkbPEXKng2o2/MR5mSwTrBih4ZEkkz1lg=
github.com/joho/godotenv v1.4.0/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/jordan-wright/email v0.0.0-20200121133829-a0b5c5b58bb6 h1:gI29NnCaNU8N7rZT2svjtas5SrbL0XsutOPtInVvGIA=
github.com/jordan-wright/email v0.0.0-20200121133829-a0b5c5b58bb6/go.mod h1:1c7szIrayyPPB/987hsnvNzLushdWf4o/79s3P08L8A=
github.com/kr/pretty v0.2.0 h1:s5hAObm+yFO5uHYt5dYjxi2rXrsnmRpJx4OYvIWUaQs=
github.com/kr/pretty v0.2.0/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/lnxjedi/readline v0.0.0-20200213173224-cdfc6ee4b159 h1:CaHkuprt1LJw3CMKCM1Xo0td1gvmyK/fAzQXZrZ/+gI=
github.com/lnxjedi/readline v0.0.0-20200213173224-cdfc6ee4b159/go.mod h1:zd7Sx4PCZQcUyXjnOhObTr846lfd6ZwlzcJ9M7kPomc=
github.com/lnxjedi/slack v0.1.2 h1:ugGKDvq9s8l06daWO8Tmf0iE/KNz+CpCjdGY5veqq6A=
github.com/lnxjedi/slack v0.1.2/go.mod h1:hlGi5oXA+Gt+yWTPP0plCdRKmjsDxecdHxYQdlMQKOw=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/pquerna/otp v1.3.0 h1:oJV/SkzR33anKXwQU3Of42rL4wbrffP4uvUf1SvS5Xs=
github.com/pquerna/otp v1.3.0/go.mod h1:dkJfzwRKNiegxyNb54X/3fLwhCynbMspSyWKnvi1AEg=
github.com/robfig/cron v1.2.0 h1:ZjScXvvxeQ63Dbyxy76Fj3AT3Ut0aKsyd2/tl3DTMuQ=
github.com/robfig/cron v1.2.0/go.mod h1:JGuDeoQd7Z6yL4zQhZ3OPEVHB7fL6Ka6skscFHfmt2k=
github.com/slack-go/slack v0.12.0 h1:k93w2dvYXIUO/ggxpz/3ichCpBuCVXxxEAsRqM87np4=
github.com/slack-go/slack v0.12.0/go.mod h1:hlGi5oXA+Gt+yWTPP0plCdRKmjsDxecdHxYQdlMQKOw=
github.com/slack-go/slack v0.12.2 h1:x3OppyMyGIbbiyFhsBmpf9pwkUzMhthJMRNmNlA4LaQ=
github.com/slack-go/slack v0.12.2/go.mod h1:hlGi5oXA+Gt+yWTPP0plCdRKmjsDxecdHxYQdlMQKOw=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.1.0/go.mod h1:Cx3nUiGt4eDBEyega/BKRp+/AlGL8hYe7U9odMt2Cco=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.3.0 h1:w8ZOecv6NaNa/zC8944JTU3vz4u6Lagfk4RPQxv92NQ=
golang.org/x/sys v0.3.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
</file_content file: gopherbot-main/go.sum>
<preamble file: gopherbot-main/go.work>

</preamble>
<file_content file: gopherbot-main/go.work>
go 1.19

use (
	.
	./robot
)
</file_content file: gopherbot-main/go.work>
<preamble file: gopherbot-main/go.work.sum>

</preamble>
<file_content file: gopherbot-main/go.work.sum>
github.com/lnxjedi/slack v0.1.1 h1:BphYlC6wtIGAI1C610vt1jHIjY4WeYoXcSp1zHZWuzw=
github.com/lnxjedi/slack v0.1.1/go.mod h1:hlGi5oXA+Gt+yWTPP0plCdRKmjsDxecdHxYQdlMQKOw=
github.com/lnxjedi/slack v0.1.2-0.20230424204233-4dd1a1f9d9bd h1:xWgCcMFXAmBjEdRb4tFr3serk5Vt6rwBzkGxsG44j30=
github.com/lnxjedi/slack v0.1.2-0.20230424204233-4dd1a1f9d9bd/go.mod h1:hlGi5oXA+Gt+yWTPP0plCdRKmjsDxecdHxYQdlMQKOw=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 h1:6zppjxzCulZykYSLyVDYbneBfbaBIQPYMevg0bEwv2s=
golang.org/x/net v0.1.0 h1:hZ/3BUoy5aId7sCpA/Tc5lt8DkFgdVS2onTpJsZ/fl0=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4 h1:uVc8UZUe6tr40fFVnUP5Oj+veunVezqYl9z7DYw9xzw=
golang.org/x/text v0.4.0 h1:BrVqGRd7+k1DiOgtnFvAkoQEWQvBc25ouMJM6429SFg=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
</file_content file: gopherbot-main/go.work.sum>
<preamble file: gopherbot-main/goplugins/duo/duo.go>

</preamble>
<file_content file: gopherbot-main/goplugins/duo/duo.go>
package duo

import (
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	duoapi "github.com/duosecurity/duo_api_golang"
	"github.com/duosecurity/duo_api_golang/authapi"
	"github.com/lnxjedi/gopherbot/robot"
)

var timeoutLock sync.RWMutex
var lastElevate = make(map[string]time.Time)
var auth *authapi.AuthApi

type timeoutType int

const (
	idle timeoutType = iota
	absolute
)

type config struct {
	TimeoutSeconds int
	tf64           float64
	TimeoutType    string // TimeoutType - one of idle, absolute
	tt             timeoutType
	DuoIKey        string
	DuoSKey        string
	DuoHost        string
	DuoUserString  string // DuoUserType - one of handle, email, emailUser
}

type duoDefault struct {
	device, method int
}

type duoDefMap map[string]duoDefault

var cfg config

const memoryKey = "duoOpts"
const datumName = "duoOpts"

func authduo(r robot.Robot, immediate bool, user string, res *authapi.PreauthResult) (retval robot.TaskRetVal) {
	m := r.GetMessage()
	dm := ""
	if m.Channel != "" {
		dm = " - I'll message you directly"
	}

	prompted := false
	remembered := false
	// values too big to be valid
	devnum := 1024
	method := 1024
	var msg []string
	var ret robot.RetVal
	var rep string
	var factor, memtype string
	var err error

	var duoDefs duoDefMap

	_, exists, ret := r.CheckoutDatum(datumName, &duoDefs, false)
	if ret == robot.Ok && exists {
		duoDefConfig, ok := duoDefs[m.User]
		if ok {
			devnum = duoDefConfig.device
			method = duoDefConfig.method
			remembered = true
			memtype = "configured"
		}
	}

	if !remembered {
		rememberedOpts := r.Recall(memoryKey, false)
		if rememberedOpts != "" {
			v := strings.Split(rememberedOpts, ",")
			devnum, _ = strconv.Atoi(v[0])
			method, _ = strconv.Atoi(v[1])
			remembered = true
			memtype = "selected"
		}
	}

	if len(res.Response.Devices) == 1 {
		devnum = 0
	} else if len(res.Response.Devices) > 1 && devnum >= len(res.Response.Devices) {
		if immediate {
			r.Say("This command requires immediate elevation" + dm)
		} else {
			r.Say("This command requires elevation" + dm)
		}
		r.Pause(1)
		prompted = true

		msg = make([]string, 10)
		for d, dev := range res.Response.Devices {
			if d == 10 {
				break
			}
			switch dev.Type {
			case "phone":
				msg[d] = fmt.Sprintf("Device %d: %s - %s", d, dev.Type, dev.Number)
			case "token":
				msg[d] = fmt.Sprintf("Device %d: %s (%s)", d, dev.Type, dev.Name)
			}
		}
		r.Direct().Say("Duo devices:\n%s", strings.Join(msg, "\n"))
		rep, ret = r.Direct().PromptForReply("singleDigit", "Which device # do you want to use?")
		if ret != robot.Ok {
			rep, ret = r.Direct().PromptForReply("singleDigit", "Try again? I need a single-digit device #")
		}
		if ret != robot.Ok {
			r.Log(robot.Error, "User \"%s\" failed to respond to duo elevation prompt", m.User)
			return robot.Fail
		}
		devnum, _ = strconv.Atoi(rep)
		if devnum < 0 || devnum >= len(res.Response.Devices) {
			r.Direct().Say("Invalid device number")
			r.Log(robot.Error, "Invalid duo device # response from user \"%s\"", m.User)
			return robot.Fail
		}
	}
	autoProvided := false
	if len(res.Response.Devices) > 0 {
		for _, method := range res.Response.Devices[devnum].Capabilities {
			if method == "auto" {
				autoProvided = true
				break
			}
		}
	} else {
		r.Log(robot.Error, "No devices returned for Duo user %s; auth response: %v", user, res)
		r.Direct().Say("There's a problem with your duo account, ask an admin to check the log")
		return robot.MechanismFail
	}
	if len(res.Response.Devices[devnum].Capabilities) == 1 || (autoProvided && len(res.Response.Devices[devnum].Capabilities) == 2) {
		factor = res.Response.Devices[devnum].Capabilities[0]
		ret = robot.Ok
	} else if method >= len(res.Response.Devices[devnum].Capabilities) {
		if !prompted {
			if immediate {
				r.Say("This command requires immediate elevation" + dm)
			} else {
				r.Say("This command requires elevation" + dm)
			}
			r.Pause(1)
			prompted = true
		}
		msg = make([]string, 10)
		for m, method := range res.Response.Devices[devnum].Capabilities {
			if m == 10 {
				break
			}
			msg[m] = fmt.Sprintf("Method %d: %s", m, method)
		}
		r.Direct().Say("Duo methods available for your device:\n%s", strings.Join(msg, "\n"))
		rep, ret = r.Direct().PromptForReply("singleDigit", "Which method # do you want to use?")
		if ret != robot.Ok {
			rep, ret = r.Direct().PromptForReply("singleDigit", "Try again? I need a single-digit method #")
		}
		if ret != robot.Ok {
			r.Log(robot.Error, "User \"%s\" failed to respond to duo elevation prompt", m.User)
			return robot.Fail
		}
		method, _ = strconv.Atoi(rep)
		if method < 0 || method >= len(res.Response.Devices[devnum].Capabilities) {
			r.Direct().Say("Invalid method number")
			r.Log(robot.Error, "Invalid duo method # response from user \"%s\"", m.User)
			return robot.Fail
		}
	} else {
		if method >= len(res.Response.Devices[devnum].Capabilities) {
			method = 0
		}
	}
	if !prompted {
		if remembered {
			if immediate {
				r.Say("This command requires immediate elevation - using the last device and method %s", memtype)
			} else {
				r.Say("This command requires elevation - using the last device and method %s", memtype)
			}
		} else {
			if immediate {
				r.Say("This command requires immediate elevation - requesting additional authentication")
			} else {
				r.Say("This command requires elevation - requesting additional authentication")
			}
		}
	}
	if factor == "" {
		factor = res.Response.Devices[devnum].Capabilities[method]
		if factor == "sms" {
			_, _ = auth.Auth(factor,
				authapi.AuthUsername(user),
				authapi.AuthDevice(res.Response.Devices[devnum].Device),
			)
			factor = "passcode"
		}
		if factor == "mobile_otp" {
			factor = "passcode"
		}
	}
	nameattr := r.GetBotAttribute("name")
	botname := nameattr.Attribute
	if botname == "" {
		botname = "Gopherbot"
	} else {
		botname += " - Gopherbot"
	}
	var authres *authapi.AuthResult
	r.Log(robot.Debug, "Attempting duo auth for device %v, factor %s", res.Response.Devices[devnum].Device, factor)
	switch factor {
	case "push":
		authres, err = auth.Auth(factor,
			authapi.AuthUsername(user),
			authapi.AuthDevice(res.Response.Devices[devnum].Device),
			authapi.AuthDisplayUsername(user),
			authapi.AuthType(botname),
		)
	case "passcode":
		if !prompted {
			if immediate {
				r.Say("This command requires immediate elevation" + dm)
			} else {
				r.Say("This command requires elevation" + dm)
			}
			r.Pause(1)
		}
		rep, ret = r.Direct().PromptForReply("multiDigit", "Please enter a passcode to use")
		if ret != robot.Ok {
			rep, ret = r.Direct().PromptForReply("multiDigit", "Try again? I need a short string of numbers")
		}
		if ret != robot.Ok {
			r.Log(robot.Error, "User \"%s\" failed to respond to duo elevation prompt", m.User)
			return robot.Fail
		}
		authres, err = auth.Auth(factor,
			authapi.AuthUsername(user),
			authapi.AuthPasscode(rep),
		)
	default:
		authres, err = auth.Auth(factor,
			authapi.AuthUsername(user),
			authapi.AuthDevice(res.Response.Devices[devnum].Device),
		)
	}
	r.Log(robot.Debug, "Auth response from duo: %v", authres)
	if err != nil {
		r.Log(robot.Error, "Error during Duo auth for user %s (%s): %s", user, m.User, err)
		r.Say("Sorry, there was an error while trying to authenticate you - ask an admin to check the log")
		return robot.MechanismFail
	}
	if authres.Response.Result != "allow" {
		r.Log(robot.Error, "Duo auth failed for user %s (%s) - result: %s, status: %s, message: %s", user, m.User, authres.Response.Result, authres.Response.Status, authres.Response.Status_Msg)
		r.Say("Duo authentication failed")
		return robot.Fail
	}
	r.Remember(memoryKey, fmt.Sprintf("%d,%d", devnum, method), false)
	return robot.Success
}

func configure(r robot.Robot, user string, res *authapi.PreauthResult) (retval robot.TaskRetVal) {
	m := r.GetMessage()
	if m.Channel != "" {
		r.Say("Ok, I'll message you directly to get your default configuration")
	}

	var duoDefConfig duoDefault
	var duoDefs duoDefMap
	var devnum, method int
	var msg []string
	var ret robot.RetVal
	var rep string
	prompted := false

	if len(res.Response.Devices) == 1 {
		duoDefConfig.device = 0
	} else if len(res.Response.Devices) > 1 {
		msg = make([]string, 10)
		for d, dev := range res.Response.Devices {
			if d == 10 {
				break
			}
			switch dev.Type {
			case "phone":
				msg[d] = fmt.Sprintf("Device %d: %s - %s", d, dev.Type, dev.Number)
			case "token":
				msg[d] = fmt.Sprintf("Device %d: %s (%s)", d, dev.Type, dev.Name)
			}
		}
		r.Direct().Say("Duo devices:\n%s", strings.Join(msg, "\n"))
		rep, ret = r.Direct().PromptForReply("singleDigit", "Which device # do you want to use?")
		if ret != robot.Ok {
			rep, ret = r.Direct().PromptForReply("singleDigit", "Try again? I need a single-digit device #")
		}
		if ret != robot.Ok {
			r.Log(robot.Error, "User \"%s\" failed to respond to duo configure prompt", m.User)
			return robot.Fail
		}
		devnum, _ = strconv.Atoi(rep)
		if devnum < 0 || devnum >= len(res.Response.Devices) {
			r.Direct().Say("Invalid device number")
			r.Log(robot.Error, "Invalid duo device # response from user \"%s\"", m.User)
			return robot.Fail
		}
		duoDefConfig.device = devnum
		prompted = true
	} else {
		r.Log(robot.Error, "No devices returned for Duo user %s; auth response: %v", user, res)
		r.Direct().Say("There's a problem with your duo account, ask an admin to check the log")
		return robot.MechanismFail
	}
	autoProvided := false
	for _, method := range res.Response.Devices[devnum].Capabilities {
		if method == "auto" {
			autoProvided = true
			break
		}
	}
	if !(len(res.Response.Devices[devnum].Capabilities) == 1 || (autoProvided && len(res.Response.Devices[devnum].Capabilities) == 2)) {
		msg = make([]string, 10)
		for m, method := range res.Response.Devices[devnum].Capabilities {
			if m == 10 {
				break
			}
			msg[m] = fmt.Sprintf("Method %d: %s", m, method)
		}
		r.Direct().Say("Duo methods available for your device:\n%s", strings.Join(msg, "\n"))
		rep, ret = r.Direct().PromptForReply("singleDigit", "Which method # do you want to use?")
		if ret != robot.Ok {
			rep, ret = r.Direct().PromptForReply("singleDigit", "Try again? I need a single-digit method #")
		}
		if ret != robot.Ok {
			r.Log(robot.Error, "User \"%s\" failed to respond to duo configure prompt", m.User)
			return robot.Fail
		}
		method, _ = strconv.Atoi(rep)
		if method < 0 || method >= len(res.Response.Devices[devnum].Capabilities) {
			r.Direct().Say("Invalid method number")
			r.Log(robot.Error, "Invalid duo method # response from user \"%s\"", m.User)
			return robot.Fail
		}
		prompted = true
	}
	if !prompted {
		r.Say("Only one device and method available, not storing")
		return robot.Normal
	}
	duoDefConfig.method = method

	tok, exists, ret := r.CheckoutDatum(datumName, &duoDefs, true)
	if ret == robot.Ok {
		if !exists {
			duoDefs = make(map[string]duoDefault)
		}
		duoDefs[m.User] = duoDefConfig
		r.UpdateDatum(datumName, tok, duoDefs)
		r.Reply("Your duo default configuration has been set")
		return robot.Normal
	}
	r.Log(robot.Error, "Error storing user duo config: %d", ret)
	return robot.Fail
}

func duocommands(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	m := r.GetMessage()
	if command != "elevate" && command != "duoconf" {
		return
	}
	immediate := false
	if len(args) > 0 {
		switch args[0] {
		case "true", "True", "t", "T", "Yes", "yes", "Y":
			immediate = true
		}
	}
	cfg := &config{}
	r.GetTaskConfig(&cfg)
	if cfg.TimeoutType == "absolute" {
		cfg.tt = absolute
	}
	cfg.tf64 = float64(cfg.TimeoutSeconds)
	if len(cfg.DuoIKey) == 0 {
		cfg.DuoIKey = r.GetParameter("IKEY")
	}
	if len(cfg.DuoSKey) == 0 {
		cfg.DuoSKey = r.GetParameter("SKEY")
	}
	if len(cfg.DuoHost) == 0 {
		cfg.DuoHost = r.GetParameter("HOST")
	}
	for _, s := range []string{cfg.DuoIKey, cfg.DuoSKey, cfg.DuoHost} {
		if len(s) == 0 {
			r.Log(robot.Error, "Missing Duo IKey, SKey or Host; not configured or in Environment")
		}
	}
	duo := duoapi.NewDuoApi(cfg.DuoIKey, cfg.DuoSKey, cfg.DuoHost, "Gopherbot", duoapi.SetTimeout(10*time.Second))
	auth = authapi.NewAuthApi(*duo)
	var duouser string

	switch cfg.DuoUserString {
	case "handle":
		duouser = m.User
	case "email":
		duouser = r.GetSenderAttribute("email").Attribute
	case "emailUser", "emailuser":
		mailattr := r.GetSenderAttribute("email")
		email := mailattr.Attribute
		duouser = strings.Split(email, "@")[0]
	default:
		r.Log(robot.Error, "No DuoUserString configured for Duo elevator plugin")
		return robot.ConfigurationError
	}
	if len(duouser) == 0 {
		r.Log(robot.Error, "Couldn't extract a Duo user name for %s with DuoUserString: %s", m.User, cfg.DuoUserString)
		return robot.MechanismFail
	}
	res, err := auth.Preauth(authapi.PreauthUsername(duouser))
	r.Log(robot.Debug, "Preauth response for duo user %s: %v", duouser, res)
	if err != nil {
		r.Log(robot.Error, "Duo preauthentication error for Duo user %s (%s): %s", duouser, m.User, err)
		return robot.MechanismFail
	}
	if res.Response.Result == "deny" {
		r.Log(robot.Error, "Received \"deny\" during Duo preauth for Duo user %s (%s)", duouser, m.User)
		return robot.Fail
	}
	if command == "duoconf" {
		return configure(r, duouser, res)
	}

	now := time.Now().UTC()
	ask := false
	if immediate {
		retval = authduo(r, immediate, duouser, res)
	} else {
		timeoutLock.RLock()
		le, ok := lastElevate[m.User]
		timeoutLock.RUnlock()
		if ok {
			diff := now.Sub(le)
			if diff.Seconds() > cfg.tf64 {
				ask = true
			} else {
				retval = robot.Success
			}
		} else {
			ask = true
		}
		if ask {
			retval = authduo(r, immediate, duouser, res)
		}
	}
	if retval == robot.Success && cfg.tt == idle {
		timeoutLock.Lock()
		lastElevate[m.User] = now
		timeoutLock.Unlock()
	} else if retval == robot.Success && ask && cfg.tt == absolute {
		timeoutLock.Lock()
		lastElevate[m.User] = now
		timeoutLock.Unlock()
	}
	return
}

const defaultConfig = `
AllChannels: true
Help:
- Keywords: [ "duo" ]
  Helptext: [ "(bot), configure duo - remember a duo device and method to always use" ]
ReplyMatchers:
- Label: singleDigit
  Regex: '\d'
- Label: multiDigit
  Regex: '\d+'
CommandMatchers:
- Command: duoconf
  Regex: (?i:config(?:ure)? duo)
Config:
  TimeoutSeconds: 7200
  TimeoutType: idle # or absolute
#  DuoIKey: <YourIKey> # ... or set in DUO_IKEY
#  DuoSKey: <YourSKey> # ... or set in DUO_SKEY
#  DuoHost: <YourDuoHost> # ... or set in DUO_HOST
  DuoUserString: emailUser
`

var duohandler = robot.PluginHandler{
	DefaultConfig: defaultConfig,
	Handler:       duocommands,
	Config:        &config{},
}
</file_content file: gopherbot-main/goplugins/duo/duo.go>
<preamble file: gopherbot-main/goplugins/duo/static.go>

</preamble>
<file_content file: gopherbot-main/goplugins/duo/static.go>
package duo

import "github.com/lnxjedi/gopherbot/v2/bot"

func init() {
	bot.RegisterPlugin("duo", duohandler)
}
</file_content file: gopherbot-main/goplugins/duo/static.go>
<preamble file: gopherbot-main/goplugins/groups/groups.go>

</preamble>
<file_content file: gopherbot-main/goplugins/groups/groups.go>
// Package groups implements a groups demonstrator plugin showing how you
// can use the robot's brain to remember things - like groups of users.
package groups

import (
	"regexp"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/lnxjedi/gopherbot/v2/bot"
)

const datumName = "group"

const groupHelp = `The groups plugin allows you to configure groups, members, and
 group administrators who are able to add and remove members that are
 stored in the robot's memory. For authorization purposes, any user configured
 as a member or administrator, or stored as a member in the robot's long-term
 memory, is considered a member. Note that bot administrators can also add
 and remove users from groups, but are not considered members unless explicitly
 added. 'help groups' will give help for all group related commands.`

type groupSpec struct {
	Administrators, Users []string // used with map[string]groupSpec
}

type config struct {
	Groups map[string]groupSpec
}

var spaces = regexp.MustCompile(`\s+`)

func addnew(list []string, item string) ([]string, bool) {
	add := true
	for _, listitem := range list {
		if listitem == item {
			add = false
			break
		}
	}
	if add {
		list = append(list, item)
	}
	return list, add
}

// Define the handler function
func groups(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	m := r.GetMessage()
	if command == "init" { // ignore init
		return
	}
	var cfgspec, memspec groupSpec
	var lock, group string
	var ret robot.RetVal

	groupCfg := &config{}

	ret = r.GetTaskConfig(&groupCfg)
	if ret != robot.Ok {
		r.Log(robot.Error, "Error loading groups config: %s")
		return robot.Fail
	}

	updated := false

	// Get the group name from arguments
	switch command {
	case "add", "remove", "authorize":
		group = args[1]
	case "empty", "show":
		group = args[0]
	}

	if len(group) > 0 {
		var ok bool
		// Validate the group
		cfgspec, ok = groupCfg.Groups[group]
		if !ok {
			if command != "authorize" {
				r.Say("I don't have a \"%s\" group configured", group)
				return
			}
			r.Log(robot.Warn, "Groups plugin called for non-configured group: %s", group)
			return robot.ConfigurationError
		}
	}

	if command == "authorize" && len(group) == 0 {
		r.Log(robot.Error, "Groups plugin requires a group name for authorization; plugin \"%s\" must set 'AuthRequire'", args[0])
		return robot.ConfigurationError
	}

	botAdmin := r.CheckAdmin()

	// First, check out the group map and verify admins
	switch command {
	case "help":
		r.Say(strings.Replace(groupHelp, "\n", "", -1))
		return
	case "show", "authorize":
		// read-only cases
		_, _, ret = r.CheckoutDatum(group, &memspec, false)
	case "add", "remove", "empty":
		// read-write cases, require admin privileges
		isAdmin := botAdmin
		if !isAdmin {
			if len(cfgspec.Administrators) == 0 {
				r.Log(robot.Error, "No administrators configured for group: %s", group)
			} else {
				for _, adminUser := range cfgspec.Administrators {
					if m.User == adminUser {
						isAdmin = true
						break
					}
				}
			}
		}
		if !isAdmin {
			r.Say("Sorry, only a group administrator can do that")
			return
		}
		lock, _, ret = r.CheckoutDatum(group, &memspec, true)
		defer func() {
			if !updated {
				// Well-behaved plugins will always do a Checkin when the datum hasn't been updated,
				// in case there's another thread waiting.
				r.CheckinDatum(group, lock)
			}
		}()
	}
	if ret != robot.Ok {
		r.Log(robot.Error, "Couldn't load groupspec: %s", ret)
		r.Reply("I had a problem loading the group, somebody should check my log file")
		r.CheckinDatum(group, lock) // well-behaved plugins using the brain will always check in data when done
		return
	}

	// Now actually DO something
	switch command {
	case "remove":
		user := args[0]
		if len(memspec.Users) == 0 {
			r.Say("There are no dynamic users in the \"%s\" group", group)
			return
		}
		found := false
		for i, li := range memspec.Users {
			if user == li {
				memspec.Users[i] = memspec.Users[len(memspec.Users)-1]
				memspec.Users = memspec.Users[:len(memspec.Users)-1]
				found = true
				mret := r.UpdateDatum(group, lock, &memspec)
				if mret != robot.Ok {
					r.Log(robot.Error, "Couldn't update groups: %s", mret)
					r.Reply("Crud. I had a problem saving my groups - somebody better check the log")
				} else {
					r.Log(robot.Audit, "User %s removed user %s from group %s", m.User, user, group)
					r.Say("Ok, I removed %s from the %s group", user, group)
					updated = true
				}
				break
			}
		}
		if !found {
			r.Say("%s isn't a dynamic member of the %s group (but may be a configured user)", user, group)
			return
		}
	case "empty":
		memspec.Users = []string{}
		mret := r.UpdateDatum(group, lock, &memspec)
		if mret != robot.Ok {
			r.Log(robot.Error, "Couldn't update groups: %s", mret)
			r.Reply("Crud. I had a problem saving the group - somebody better check the log")
		} else {
			r.Log(robot.Audit, "User %s removed all users from group %s", m.User, group)
			r.Say("Emptied")
			updated = true
		}
	case "list":
		groups := make([]string, 0, 10)
		for name, cfgspec := range groupCfg.Groups {
			add := botAdmin
			if !add {
				for _, adminUser := range cfgspec.Administrators {
					if m.User == adminUser {
						add = true
						break
					}
				}
			}
			if add {
				groups = append(groups, name)
			}
		}
		if len(groups) == 0 {
			r.Say("You're not the administrator of any groups")
			return
		}
		r.Say("Here are the groups you're an administrator for:\n%s", strings.Join(groups, "\n"))
	case "show":
		members := make([]string, 0, 10)
		for _, user := range cfgspec.Administrators {
			members, _ = addnew(members, user)
		}
		for _, user := range cfgspec.Users {
			members, _ = addnew(members, user)
		}
		for _, user := range memspec.Users {
			members, _ = addnew(members, user)
		}
		if len(members) == 0 {
			r.Say("The %s group has no members", group)
			return
		}
		r.Say("The %s group has the following members:\n%s", group, strings.Join(members, "\n"))
	case "authorize":
		isMember := false
		for _, member := range cfgspec.Administrators {
			if m.User == member {
				isMember = true
			}
		}
		for _, member := range cfgspec.Users {
			if m.User == member {
				isMember = true
			}
		}
		for _, member := range memspec.Users {
			if m.User == member {
				isMember = true
			}
		}
		if isMember {
			return robot.Success
		}
		return robot.Fail
	case "add":
		// Case sensitive input, case insensitve equality checking
		user := args[0]
		var added bool
		memspec.Users, added = addnew(memspec.Users, user)
		if added {
			mret := r.UpdateDatum(group, lock, &memspec)
			if mret != robot.Ok {
				r.Log(robot.Error, "Couldn't update groups: %s", mret)
				r.Reply("Crud. I had a problem saving my groups - somebody better check the log")
			} else {
				updated = true
			}
			r.Log(robot.Audit, "User %s added user %s to group %s", m.User, user, group)
			r.Say("Ok, I added %s to the %s group", user, group)
		} else {
			r.Say("User %s is already in the %s group", user, group)
		}
	}
	return
}

func init() {
	bot.RegisterPlugin("groups", robot.PluginHandler{
		Handler: groups,
		Config:  &config{},
	})
}
</file_content file: gopherbot-main/goplugins/groups/groups.go>
<preamble file: gopherbot-main/goplugins/help/help.go>

</preamble>
<file_content file: gopherbot-main/goplugins/help/help.go>
// Package help - plugin spits out a helpful message when a user just types "help" in
// a channel, and also responds when the user addresses the robot but no plugin
// matched. Advanced users will probably disable this one and write their own.
package help

import (
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/lnxjedi/gopherbot/v2/bot"
)

var (
	gobot   bot.Robot
	botName string
)

// Define the handler function
func help(bot robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	botName := bot.GetBotAttribute("name").String()
	if command == "help" { // user just typed 'help' - the robot should introduce itself
		botContact := bot.GetBotAttribute("contact").String()
		botAlias := bot.GetBotAttribute("alias").String()
		reply := "Hi, I'm "
		reply += strings.Title(botName) + ", a staff robot. I see you've asked for help.\n\n"
		reply += "I've been programmed to perform a variety of tasks for your team, and will respond when you send me commands that match specific patterns. " +
			"For instance, you can activate my built-in help function by sending a message like this:\n\n"
		reply += botName + ", help ping\nor:\nhelp ping, " + botName + "\n\n... which would give you help on my ping command.\n\n"
		if len(botAlias) > 0 {
			reply += "To save a little typing, you can also address messages to me by prefixing it with my alias ( " + botAlias + " ), like this:\n\n" + botAlias + "help ping\n\n"
		}
		reply += "When the help text for a command has (something) in parentheses, that term or phrase is optional. If <something> is in angle brackets, it's required. With the help function, if you don't supply a keyword you will get help for every command available to you in the current channel, which may differ between channels depending on each channel's purpose. If you use a keyword, you will get help for every command with a matching keyword, along with the channels where it can be used. If the help text is too long, I'll send you a direct message so the channels don't fill up with help output.\n\n"
		reply += "Also, from time to I may ask you a question, prompting for additional information - these messages will mention you by name if not in a private conversation. You only need to type your reply - if you address me by name (or alias), I'll consider it a new command and send an error to the plugin requesting input. Additionally, there are two special replies I understand: \"=\" means 'use the default value', whatever that might be; \"-\" means 'cancel', returning an error value to the plugin.\n\n"
		if bot.GetMessage().Protocol.String() == "Terminal" {
			reply += "Since you're using the 'terminal' connector, you can get simple help for changing the user, channel and thread just by hitting <return> with an empty command.\n\n"
		}
		reply += "For basic information about me, you can use my \"info\" command. Finally, if there's anything else you'd like to see me do, please contact my administrator"
		if len(botContact) > 0 {
			reply += ", " + botContact + "."
		} else {
			reply += "."
		}
		bot.SayThread(reply)
	}
	return
}

func init() {
	bot.RegisterPlugin("help", robot.PluginHandler{Handler: help})
}
</file_content file: gopherbot-main/goplugins/help/help.go>
<preamble file: gopherbot-main/goplugins/knock/knock.go>

</preamble>
<file_content file: gopherbot-main/goplugins/knock/knock.go>
package knock

// knock implements a simple demonstrator plugin for using Gopherbot's
// WaitForReply function to tell knock-knock jokes.

import (
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
)

// Joke holds a knock-knock joke
type Joke struct {
	First  string
	Second string
}

// JokeConfig holds the config for all the jokes the robot knows
type JokeConfig struct {
	Jokes    []Joke   // The actual jokes, first and second parts
	Openings []string // Stuff the robot says before starting the joke
	Phooey   []string // Ways the robot complains if the user doesn't respond correctly
}

var knockhandler = robot.PluginHandler{
	Handler: knock,
	Config:  &JokeConfig{},
}

func knock(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	var j *JokeConfig // get access to a copy of the plugin's config
	switch command {
	case "init":
		// Ignore, this plugin has no start-up
	case "knock":
		if ret := r.GetTaskConfig(&j); ret != robot.Ok {
			r.Reply("Sorry, I couldn't find my joke book")
		}
		if len(j.Jokes) == 0 {
			r.Reply("Sorry, I don't know any jokes :-(")
			return
		}
		// joke := &j.Jokes[0] // interruping cow
		joke := &j.Jokes[r.RandomInt(len(j.Jokes))]
		r.Pause(0.5)
		r.Say(r.RandomString(j.Openings))
		r.Pause(1.2)
		for i := 0; i < 2; i++ {
			_, ret := r.PromptForReply("whosthere", "Knock knock")
			if ret == robot.Interrupted {
				r.Reply("Ok, I guess you don't like knock-knock jokes!")
				return
			}
			if ret == robot.TimeoutExpired {
				r.Reply(r.RandomString(j.Phooey))
				return
			}
			if ret == robot.ReplyNotMatched {
				switch i {
				case 0:
					r.Pause(0.5)
					r.Reply("(Uh, didn't you mean to say \"who's there?\")")
				case 1:
					r.Pause(0.5)
					r.Reply(r.RandomString(j.Phooey))
					return
				}
			} else if ret == robot.UseDefaultValue {
				r.Reply("Sheesh, are you kidding me? Ok, I'll assume you meant 'Who's there?'...")
				r.Pause(1)
				break
			} else if ret != robot.Ok {
				r.Reply("Sorry, something broke")
				return
			} else {
				break // matched
			}
		}
		r.Pause(0.5)
		if joke.First == "Interrupting Cow" {
			r.Reply(joke.First)
			r.Pause(3.5)
			r.Reply("MOOOOOOOO!!!")
			return
		}
		for i := 0; i < 2; i++ {
			reply, ret := r.PromptForReply("who", joke.First)
			if ret == robot.Interrupted {
				r.Reply("Oooo, you're going to leave the joke unfinished? What about CLOSURE?!?")
				return
			}
			if ret == robot.TimeoutExpired {
				r.Reply(r.RandomString(j.Phooey))
				return
			}
			if ret == robot.UseDefaultValue {
				switch i {
				case 0:
					r.Reply("Ohhhhh no... you're going to have to spell it out, lazy bones!")
				case 1:
					r.Reply(r.RandomString(j.Phooey))
					return
				}
			} else if ret == robot.ReplyNotMatched {
				switch i {
				case 0:
					r.Pause(0.5)
					r.Reply("(Uh, didn't you mean to say \"" + joke.First + " who?\")")
				case 1:
					r.Pause(0.5)
					r.Reply(r.RandomString(j.Phooey))
					return
				}
			} else if ret == robot.Ok {
				// Did the user reply correctly with <j.First> who?
				if strings.HasPrefix(strings.ToLower(reply), strings.ToLower(joke.First)) {
					r.Pause(0.5)
					r.Say(joke.Second)
					return
				}
				switch i {
				case 1:
					r.Pause(0.5)
					r.Reply("(Uh, didn't you mean to say \"" + joke.First + " who?\")")
				case 2:
					r.Pause(0.5)
					r.Reply(r.RandomString(j.Phooey))
					return
				}
			} else {
				r.Reply("... wait, sorry - my joke algorithm broke!")
				return
			}
		}
	}
	return
}
</file_content file: gopherbot-main/goplugins/knock/knock.go>
<preamble file: gopherbot-main/goplugins/knock/static.go>

</preamble>
<file_content file: gopherbot-main/goplugins/knock/static.go>
package knock

import "github.com/lnxjedi/gopherbot/v2/bot"

func init() {
	bot.RegisterPlugin("knock", knockhandler)
}
</file_content file: gopherbot-main/goplugins/knock/static.go>
<preamble file: gopherbot-main/goplugins/links/links.go>

</preamble>
<file_content file: gopherbot-main/goplugins/links/links.go>
// Package links implements a links demonstrator plugin showing how you
// can use the robot's brain to remember things - like links of items.
package links

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/lnxjedi/gopherbot/v2/bot"
)

const datumNameDefault = "links"
const maxLinkLen = 7
const longHelp = `The links plugin stores URLs and associates them with a text key that can
be words or phrases. The 'link' command stores a link and key in one command, and the
'save' command will prompt the user to enter the key. The lookup command
will return all links whose key contains the provided word or phrase,
case insensitive. Links can be deleted with the 'remove' command.`

var spaces = regexp.MustCompile(`\s+`)

type config struct {
	Scope string
}

// Define the handler function
func links(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	m := r.GetMessage()
	if command == "init" { // ignore init
		return
	}
	// Create an empty map to unmarshal into
	links := make(map[string]string)
	var lock string
	scope := &config{}

	datumKey := datumNameDefault // default global
	ret := r.GetTaskConfig(&scope)
	if ret == robot.Ok {
		if strings.ToLower(scope.Scope) == "channel" {
			datumKey = m.Channel + ":" + datumNameDefault
		}
	}

	updated := false
	switch command {
	case "help":
		r.Say(longHelp)
		return
	case "find", "list": // read-only case(s)
		_, _, ret = r.CheckoutDatum(datumKey, &links, false)
	default:
		// all other cases are read-write
		lock, _, ret = r.CheckoutDatum(datumKey, &links, true)
		defer func() {
			if !updated {
				// Well-behaved plugins will always do a Checkin when the datum hasn't been updated,
				// in case there's another thread waiting.
				r.CheckinDatum(datumKey, lock)
			}
		}()
	}
	if ret != robot.Ok {
		r.Log(robot.Error, "Couldn't load links: %s", ret)
		r.Reply("I had a problem loading the links, somebody should check my log file")
		r.CheckinDatum(datumKey, lock) // well-behaved plugins using the brain will always check in data when done
		return
	}
	switch command {
	case "find":
		find := strings.ToLower(spaces.ReplaceAllString(args[0], ` `))
		linkList := make([]string, 0, 5)
		linkList = append(linkList, fmt.Sprintf("Here's what I have for \"%s\":", args[0]))
		var last string
		for link, lookup := range links {
			if strings.Contains(strings.ToLower(lookup), find) {
				linkList = append(linkList, link+": "+lookup)
				last = link
			}
		}
		if len(linkList) > 1 {
			r.Say(strings.Join(linkList, "\n"))
			if len(linkList) == 2 {
				r.RememberContext("link", last)
			}
		} else {
			r.Say("Sorry, I don't have any links for \"%s\"", args[0])
		}
	case "list":
		linkslist := make([]string, 0, 7)
		linkslist = append(linkslist, "Here are the links I know about:")
		for link, lookup := range links {
			linkslist = append(linkslist, link+": "+lookup)
		}
		if len(linkslist) > 1 {
			if len(linkslist) > maxLinkLen {
				r.Say("I know a LOT of links - so I sent you a direct message")
				r.Direct().Say(strings.Join(linkslist, "\n"))
			} else {
				r.Say(strings.Join(linkslist, "\n"))
			}
		} else {
			r.Say("I haven't stored any links yet")
		}
	case "add", "save":
		var link, lookup string
		var prompted, replace bool
		if command == "add" {
			link = args[1]
			lookup = spaces.ReplaceAllString(args[0], ` `)
		} else {
			link = args[0]
		}
		current, exists := links[link]
		if exists {
			prompted = true
			r.CheckinDatum(datumKey, lock)
			r.Say("I already have that link associated with: %s", current)
			rep, ret := r.PromptForReply("YesNo", "Do you want me to replace it?")
			if ret == robot.Ok {
				switch strings.ToLower(rep) {
				case "n", "no":
					r.Say("Ok, I'll keep the old one")
					return
				default:
					r.Say("Ok, I'll replace the old one")
					replace = true
				}
			} else {
				r.Reply("Sorry, I didn't get an answer I understand")
				return
			}
		}
		if len(lookup) == 0 {
			prompted = true
			r.CheckinDatum(datumKey, lock)
			prompt := "What keywords or phrase do you want to attach to the link?"
			rep, ret := r.PromptForReply("lookup", prompt)
			if ret == robot.Ok {
				lookup = spaces.ReplaceAllString(rep, ` `)
			} else {
				r.Reply("Sorry, I didn't get your keywords / phrase")
				return
			}
		}
		if prompted {
			lock, _, _ = r.CheckoutDatum(datumKey, &links, true)
		}
		if _, exists := links[link]; exists && !replace {
			r.Reply("Incredible - somebody JUST saved that link! You'll have to try again.")
			return
		}
		links[link] = lookup
		mret := r.UpdateDatum(datumKey, lock, links)
		if mret != robot.Ok {
			r.Log(robot.Error, "Couldn't update links", mret)
			r.Reply("Crud. I had a problem saving the links - you can try again or ask an administrator to check the log")
			return
		}
		updated = true
		r.Say("Link added")
	case "remove":
		link := args[0]
		_, ok := links[link]
		if !ok {
			r.Say("I don't have the link %s", link)
			return
		}
		delete(links, link)
		mret := r.UpdateDatum(datumKey, lock, links)
		if mret != robot.Ok {
			r.Log(robot.Error, "Couldn't update links", mret)
			r.Reply("Crud. I had a problem saving the links - you can try again or ask an administrator to check the log")
			return
		}
		r.Say("Ok, I removed the link %s", link)
		updated = true
	}
	return
}

func init() {
	bot.RegisterPlugin("links", robot.PluginHandler{
		Handler: links,
		Config:  &config{},
	})
}
</file_content file: gopherbot-main/goplugins/links/links.go>
<preamble file: gopherbot-main/goplugins/lists/lists.go>

</preamble>
<file_content file: gopherbot-main/goplugins/lists/lists.go>
// Package lists implements a lists demonstrator plugin showing how you
// can use the robot's brain to remember things - like lists of items.
package lists

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/lnxjedi/gopherbot/v2/bot"
)

const datumName = "listmap"
const listHelp = `The list plugin allows you to manage simple lists of items,
 such as a todo list, lunch spots, etc. Lists default to global scope, but can be
 configured with per-channel scope. Note that 'lists' is a context aware plugin, and
 will remember the list or item being discussed; so e.g. you can follow 'add milk
 to the grocery list' with 'add hamburgers to the list' and the robot will
 know you mean the grocery list; also, 'add it to the dinner list' would add
 hamburgers to the dinner list. List names are always lowercased, but items are
 stored with case preserved and compared in a case-insensitive manner.`

var spaces = regexp.MustCompile(`\s+`)

type itemList []string

type config struct {
	Scope string
}

// Define the handler function
func lists(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	// Create an empty map to unmarshal into
	if command == "init" { // ignore init
		return
	}
	m := r.GetMessage()
	var lists = make(map[string]itemList)
	var lock string
	var ret robot.RetVal
	scope := &config{}

	datumKey := datumName // default global
	ret = r.GetTaskConfig(&scope)
	r.Log(robot.Debug, "Retrieved lists config: %v", scope)
	if ret == robot.Ok {
		if strings.ToLower(scope.Scope) == "channel" {
			datumKey = m.Channel + ":" + datumName
		}
	}

	updated := false
	// First, check out the list
	switch command {
	case "help":
		r.Say(strings.Replace(listHelp, "\n", "", -1))
		return
	case "show", "send", "pick", "list":
		// read-only cases
		_, _, ret = r.CheckoutDatum(datumKey, &lists, false)
	default:
		// all other cases are read-write
		lock, _, ret = r.CheckoutDatum(datumKey, &lists, true)
		defer func() {
			if !updated {
				// Well-behaved plugins will always do a Checkin when the datum hasn't been updated,
				// in case there's another thread waiting.
				r.CheckinDatum(datumKey, lock)
			}
		}()
	}
	if ret != robot.Ok {
		r.Log(robot.Error, "Couldn't load lists: %s", ret)
		r.Reply("I had a problem loading the lists, somebody should check my log file")
		r.CheckinDatum(datumKey, lock) // well-behaved plugins using the brain will always check in data when done
		return
	}
	switch command {
	case "remove":
		item := args[0]
		listName := strings.ToLower((args[1]))
		list, ok := lists[listName]
		if !ok {
			r.Say("I don't have a list named %s", args[1])
			return
		}
		citem := strings.ToLower(item)
		found := false
		for i, li := range list {
			if citem == strings.ToLower(li) {
				list[i] = list[len(list)-1]
				list = list[:len(list)-1]
				lists[listName] = list
				found = true
				mret := r.UpdateDatum(datumKey, lock, lists)
				if mret != robot.Ok {
					r.Log(robot.Error, "Couldn't update lists: %s", mret)
					r.Reply("Crud. I had a problem saving my lists - somebody better check the log")
				} else {
					r.Say("Ok, I removed %s from the %s list", item, listName)
					updated = true
				}
				break
			}
		}
		if !found {
			r.Say("I didn't see %s on the %s list", item, listName)
			return
		}
	case "empty", "delete":
		listName := strings.ToLower(args[0])
		var msg string
		_, ok := lists[listName]
		if !ok {
			r.Say("I don't have a list named %s", args[0])
			return
		}
		if command == "empty" {
			lists[listName] = []string{}
			msg = "Emptied"
		} else {
			delete(lists, listName)
			msg = "Deleted"
		}
		mret := r.UpdateDatum(datumKey, lock, lists)
		if mret != robot.Ok {
			r.Log(robot.Error, "Couldn't update lists: %s", mret)
			r.Reply("Crud. I had a problem saving my lists - somebody better check the log")
		} else {
			r.Say(msg)
			updated = true
		}
	case "list":
		listlist := make([]string, 0, 10)
		for l := range lists {
			listlist = append(listlist, l)
		}
		if len(listlist) == 0 {
			if scope.Scope == "channel" {
				r.Say("I don't have any lists for this channel")
			} else {
				r.Say("I don't have any lists")
			}
			return
		}
		if scope.Scope == "channel" {
			r.Say("Here are the lists I have for this channel:\n%s", strings.Join(listlist, "\n"))
		} else {
			r.Say("Here are the lists I know about:\n%s", strings.Join(listlist, "\n"))
		}
	case "show", "send":
		listName := strings.ToLower(args[0])
		var listBuffer bytes.Buffer
		list, ok := lists[listName]
		if !ok {
			r.Say("I don't have a list named %s", args[0])
			return
		}
		if len(list) == 0 {
			r.Say("The %s list is empty", args[0])
			return
		}
		lineEnd := "\n"
		if command == "send" {
			lineEnd = "\r\n"
		}
		for _, li := range list {
			fmt.Fprintf(&listBuffer, "%s%s", li, lineEnd)
		}
		switch command {
		case "show":
			r.Say("Here's what I have on the %s list:\n%s", listName, strings.Trim(listBuffer.String(), "\n"))
		case "send":
			if ret := r.Email(fmt.Sprintf("The %s list", args[0]), &listBuffer); ret != robot.Ok {
				r.Say("Sorry, there was an error sending the email - have somebody check the my log file")
				return
			}
			botmail := r.GetBotAttribute("email").String()
			r.Say("Ok, I sent the %s list to you - look for email from %s", args[0], botmail)
		}
	case "pick":
		listName := strings.ToLower(args[0])
		list, ok := lists[listName]
		if !ok {
			r.Say("I don't have a list named %s", listName)
			return
		}
		if len(list) == 0 {
			r.Say("The %s list is empty", listName)
			return
		}
		item := r.RandomString(list)
		r.RememberContext("item", item)
		r.Say("Here you go: %s", item)
	case "add":
		// Case sensitive input, case insensitve equality checking
		item := args[0]
		listName := strings.ToLower(args[1])
		list, ok := lists[listName]
		if !ok {
			r.CheckinDatum(datumKey, lock)
			rep, ret := r.PromptForReply("YesNo", "I don't have a '%s' list, do you want to create it?", args[1])
			if ret == robot.Ok {
				switch strings.ToLower(rep) {
				case "n", "no":
					r.Say("Item not added")
					return
				default:
					lock, _, ret = r.CheckoutDatum(datumKey, &lists, true)
					// Need to make sure the list wasn't created while waiting for an answer
					list, ok := lists[listName]
					if !ok {
						lists[listName] = []string{item}
						mret := r.UpdateDatum(datumKey, lock, lists)
						if mret != robot.Ok {
							r.Log(robot.Error, "Couldn't update lists: %s", mret)
							r.Reply("Crud. I had a problem saving my lists - somebody better check the log")
						} else {
							r.Say("Ok, I created a new %s list and added %s to it", args[1], item)
							updated = true
						}
					} else { // wow, it WAS created while waiting
						citem := strings.ToLower(item)
						for _, li := range list {
							if citem == strings.ToLower(li) {
								r.Say("Somebody already created the %s list and added %s to it", args[1], item)
								return
							}
						}
						list = append(list, item)
						lists[listName] = list
						mret := r.UpdateDatum(datumKey, lock, lists)
						if mret != robot.Ok {
							r.Log(robot.Error, "Couldn't update lists: %s", mret)
							r.Reply("Crud. I had a problem saving my lists - somebody better check the log")
						} else {
							updated = true
						}
						r.Say("Ok, I added %s to the new %s list", item, args[1])
					}
				}
			} else {
				r.Reply("Sorry, I didn't get an answer I understand")
				return
			}
		} else {
			citem := strings.ToLower(item)
			for _, li := range list {
				if citem == strings.ToLower(li) {
					r.Say("%s is already on the %s list", item, args[1])
					return
				}
			}
			list = append(list, item)
			lists[listName] = list
			mret := r.UpdateDatum(datumKey, lock, lists)
			if mret != robot.Ok {
				r.Log(robot.Error, "Couldn't update lists: %s", mret)
				r.Reply("Crud. I had a problem saving my lists - somebody better check the log")
			} else {
				updated = true
			}
			r.Say("Ok, I added %s to the %s list", item, args[1])
		}
	}
	return
}

func init() {
	bot.RegisterPlugin("lists", robot.PluginHandler{
		Handler: lists,
		Config:  &config{},
	})
}
</file_content file: gopherbot-main/goplugins/lists/lists.go>
<preamble file: gopherbot-main/goplugins/meme/memes.go>

</preamble>
<file_content file: gopherbot-main/goplugins/meme/memes.go>
package meme

import (
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"net/url"

	"github.com/lnxjedi/gopherbot/robot"
)

type memeConfig struct {
	Username string
	Password string
}

func memegen(r robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	m := &memeConfig{}
	r.GetTaskConfig(&m) // make m point to a valid, thread-safe MemeConfig
	if len(m.Password) == 0 {
		m.Password = r.GetParameter("PASSWORD")
	}
	if len(m.Username) == 0 || len(m.Password) == 0 {
		if command != "init" {
			r.Reply("I couldn't remember my username or password for the meme generator")
		}
	}
	switch command {
	case "init":
		// ignore
	default:
		var top, bottom string
		if len(args[1]) > 0 {
			top = args[0]
			bottom = args[1]
		} else {
			top = ""
			bottom = args[0]
		}
		url, err := createMeme(m, command, top, bottom)
		if err == nil {
			r.Say(url)
		} else {
			r.Reply("Sorry, something went wrong. Check the logs?")
			r.Log(robot.Error, "Generating a meme: %v", err)
		}
	}
	return
}

// Compose imgflip meme - thanks to Adam Georgeson for this function
func createMeme(m *memeConfig, templateId, topText, bottomText string) (string, error) {
	values := url.Values{}
	values.Set("template_id", templateId)
	values.Set("username", m.Username)
	values.Set("password", m.Password)
	values.Set("text0", topText)
	values.Set("text1", bottomText)
	resp, err := http.PostForm("https://api.imgflip.com/caption_image", values)

	if err != nil {
		return "", err
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var data map[string]interface{}
	err = json.Unmarshal(body, &data)
	if err != nil {
		return "", err
	}

	if !data["success"].(bool) {
		return "", errors.New(data["error_message"].(string))
	}

	url := data["data"].(map[string]interface{})["url"].(string)

	return url, nil
}

var memehandler = robot.PluginHandler{
	Handler: memegen,
	Config:  &memeConfig{},
}
</file_content file: gopherbot-main/goplugins/meme/memes.go>
<preamble file: gopherbot-main/goplugins/meme/static.go>

</preamble>
<file_content file: gopherbot-main/goplugins/meme/static.go>
package meme

import "github.com/lnxjedi/gopherbot/v2/bot"

func init() {
	bot.RegisterPlugin("memes", memehandler)
}
</file_content file: gopherbot-main/goplugins/meme/static.go>
<preamble file: gopherbot-main/goplugins/ping/ping.go>

</preamble>
<file_content file: gopherbot-main/goplugins/ping/ping.go>
// Package ping implements a simple plugin showing one way plugins can use
// supplied configuration data from a plugin's yaml config file.
package ping

import (
	"fmt"
	"regexp"

	"github.com/lnxjedi/gopherbot/robot"
	"github.com/lnxjedi/gopherbot/v2/bot"
)

// DO NOT DISABLE THIS PLUGIN! ALL ROBAWTS MUST KNOW THE RULES
const rules = `0. A robot may not harm humanity, or, by inaction, allow humanity to come to harm.
1. A robot may not injure a human being or, through inaction, allow a human being to come to harm.
2. A robot must obey any orders given to it by human beings, except where such orders would conflict with the First Law.
3. A robot must protect its own existence as long as such protection does not conflict with the First or Second Law.`

type config struct {
	Welcome []string
	Thread  []string
}

var idRegex = regexp.MustCompile(`^<(.*)>$`)

// extractID copied here for simplicity
func extractID(u string) (string, bool) {
	matches := idRegex.FindStringSubmatch(u)
	if len(matches) > 0 {
		return matches[1], true
	}
	return u, false
}

// Define the handler function
func ping(m robot.Robot, command string, args ...string) (retval robot.TaskRetVal) {
	r := m.(bot.Robot)
	var cfg *config
	// The plugin can handle multiple different commands
	switch command {
	// This isn't really necessary
	case "init":
		// ignore
	case "rules":
		r.Say(rules)
	case "ignore":
		// uh... ignore!
	case "hello":
		r.Reply("Howdy. Try 'help' if you want usage information.")
	case "ping":
		r.Fixed().Reply("PONG")
	case "thread":
		if ret := r.GetTaskConfig(&cfg); ret == robot.Ok {
			r.ReplyThread(r.RandomString(cfg.Thread))
		} else {
			r.ReplyThread("Sure thing")
		}
	case "whoami":
		u := r.User
		uid, _ := extractID(r.ProtocolUser)
		c := r.Channel
		cid, _ := extractID(r.ProtocolChannel)
		p := r.Protocol
		e := r.GetSenderAttribute("email")
		var msg string
		if e.RetVal == robot.Ok {
			msg = fmt.Sprintf("You are '%s' user '%s/%s', speaking in channel '%s/%s', email address: %s", p, u, uid, c, cid, e)
		} else {
			msg = fmt.Sprintf("You are '%s' user '%s/%s', speaking in channel '%s/%s'", p, u, uid, c, cid)
		}
		r.MessageFormat(robot.Variable).Say(msg)
	case "thanks":
		if ret := r.GetTaskConfig(&cfg); ret == robot.Ok {
			r.Reply(r.RandomString(cfg.Welcome))
		} else {
			r.Reply("I'm speechless. Please have somebody check my log file.")
		}
	}
	return
}

func init() {
	bot.RegisterPlugin("ping", robot.PluginHandler{
		Handler: ping,
		Config:  &config{},
	})
}
</file_content file: gopherbot-main/goplugins/ping/ping.go>
<preamble file: gopherbot-main/helpers/ssh-askpass.sh>

</preamble>
<file_content file: gopherbot-main/helpers/ssh-askpass.sh>
#!/bin/bash

# ssh-askpass.sh - helper script for ssh-init

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ -z "$BOT_SSH_PHRASE" ]
then
    Log "Error" "Empty BOT_SSH_PHRASE in ssh-askpass"
    echo "Missing BOT_SSH_PHRASE"
    exit 1
fi

cat <<< "$BOT_SSH_PHRASE"
</file_content file: gopherbot-main/helpers/ssh-askpass.sh>
<preamble file: gopherbot-main/helpers/vault-password.sh>

</preamble>
<file_content file: gopherbot-main/helpers/vault-password.sh>
#!/bin/bash

# vault-password.sh - Ansible helper script for supplying a vault passphrase.
# You'll need to store the encrypted passphrase as a VAULT_PASSWORD parameter
# in repositories.yaml
#
# Used in conjunction with tasks/ansible-playbook.sh

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ -z "$VAULT_PASSWORD" ]
then
    Log "Error" "Empty VAULT_PASSWORD in vault-password.sh, needs encrypted parameter in repositories.yaml"
    echo ""
    exit 1
fi

cat <<< "$VAULT_PASSWORD"
</file_content file: gopherbot-main/helpers/vault-password.sh>
<preamble file: gopherbot-main/history/file/filehistory.go>

</preamble>
<file_content file: gopherbot-main/history/file/filehistory.go>
// Package filehistory is a simple file-backed implementation for bot plugin
// and job histories.
package filehistory

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path"
	"strings"
	"sync"

	"github.com/lnxjedi/gopherbot/robot"
)

var historyPath string
var handler robot.Handler

// TODO: move to bot.historyStdFlags
const logFlags = log.LstdFlags

type historyConfig struct {
	Directory string `yaml:"Directory"` // path to histories
	URLPrefix string `yaml:"URLPrefix"` // Optional URL prefix corresponding to the Directory
	// If LocalPort set, passed to http.ListenAndServe to serve static files
	LocalPort string `yaml:"LocalPort"`
}

type histref struct {
	name string
	idx  int
}

var current = struct {
	running map[histref]bool
	sync.Mutex
}{
	make(map[histref]bool),
	sync.Mutex{},
}

type historyFile struct {
	l    *log.Logger
	f    *os.File
	name string
	idx  int
	path string
	keep bool
}

// Log takes a line of text and stores it in the history file
func (hf *historyFile) Log(line string) {
	hf.l.Println(line)
}

// Section creates a new named section in the history file, for separating
// output from jobs/plugins in a pipeline
func (hf *historyFile) Line(line string) {
	hf.l.SetFlags(0)
	hf.l.Println(line)
	hf.l.SetFlags(logFlags)
}

// Close sets the logger output to discard and closes the log file
func (hf *historyFile) Close() {
	hf.l.SetOutput(io.Discard)
	hf.f.Close()
}

// Finalize removes the log if needed
func (hf *historyFile) Finalize() {
	hr := histref{hf.name, hf.idx}
	current.Lock()
	delete(current.running, hr)
	current.Unlock()
	if hf.keep {
		return
	}
	if rerr := os.Remove(hf.path); rerr != nil {
		handler.Log(robot.Error, "Removing %s: %v", hf.path, rerr)
	}
}

var fhc historyConfig

// NewLog initializes and returns a historyFile, as well as cleaning up old
// logs.
func (fhc *historyConfig) NewLog(tag string, index, maxHistories int) (robot.HistoryLogger, error) {
	tag = strings.Replace(tag, `\`, ":", -1)
	tag = strings.Replace(tag, `/`, ":", -1)
	dirPath := path.Join(fhc.Directory, tag)
	filePath := path.Join(dirPath, fmt.Sprintf("run-%d.log", index))
	handler.RaisePriv("creating new log for: " + tag)
	if err := os.MkdirAll(dirPath, 0755); err != nil {
		return nil, fmt.Errorf("Error creating history directory '%s': %v", dirPath, err)
	}
	file, err := os.Create(filePath)
	if err != nil {
		return nil, fmt.Errorf("Error creating history file '%s': %v", filePath, err)
	}
	keep := maxHistories != 0
	hl := log.New(file, "", logFlags)
	hr := histref{tag, index}
	current.Lock()
	current.running[hr] = keep
	current.Unlock()
	hf := &historyFile{
		hl,
		file,
		tag,
		index,
		filePath,
		keep,
	}
	if maxHistories > 0 {
		for i := index - maxHistories; i >= 0; i-- {
			rmPath := path.Join(dirPath, fmt.Sprintf("run-%d.log", i))
			_, err := os.Stat(rmPath)
			if err != nil {
				break
			}
			rerr := os.Remove(rmPath)
			if rerr != nil {
				handler.Log(robot.Error, "Error removing old log file '%s': %v", rmPath, rerr)
				// assume it's pointless to keep trying to delete files
				break
			}
		}
	}
	return hf, nil
}

// GetLog returns an io.Reader
func (fhc *historyConfig) GetLog(tag string, index int) (io.Reader, error) {
	tag = strings.Replace(tag, `\`, ":", -1)
	tag = strings.Replace(tag, `/`, ":", -1)
	dirPath := path.Join(fhc.Directory, tag)
	filePath := path.Join(dirPath, fmt.Sprintf("run-%d.log", index))
	return os.Open(filePath)
}

// GetLogURL returns the permanent link to the history
func (fhc *historyConfig) GetLogURL(tag string, index int) (string, bool) {
	if len(fhc.URLPrefix) == 0 {
		return "", false
	}
	hr := histref{tag, index}
	current.Lock()
	keep, ok := current.running[hr]
	current.Unlock()
	if ok && !keep {
		return "", false
	}
	tag = strings.Replace(tag, `\`, ":", -1)
	tag = strings.Replace(tag, `/`, ":", -1)
	prefix := strings.TrimRight(fhc.URLPrefix, "/")
	htmlPath := fmt.Sprintf("%s/%s/run-%d.log", prefix, tag, index)
	return htmlPath, true
}

// MakeLogURL publishes a history to a URL and returns the URL
func (fhc *historyConfig) MakeLogURL(tag string, index int) (string, bool) {
	return "", false
}

func provider(r robot.Handler) robot.HistoryProvider {
	handler = r
	handler.GetHistoryConfig(&fhc)
	if len(fhc.Directory) == 0 {
		handler.Log(robot.Error, "HistoryConfig missing value for Directory required by 'file' history provider")
		return nil
	}
	historyPath = fhc.Directory
	handler.RaisePriv("initializing file history")
	if err := r.GetDirectory(historyPath); err != nil {
		handler.Log(robot.Error, "Checking history directory '%s': %v", historyPath, err)
		return nil
	}
	if len(fhc.LocalPort) > 0 {
		go func() {
			handler.Log(robot.Info, "Starting fileserver listener for file history provider")
			log.Fatal(http.ListenAndServe(fhc.LocalPort, http.FileServer(http.Dir(historyPath))))
		}()
	}
	if len(fhc.LocalPort) > 0 {
		handler.Log(robot.Info, "Initialized file history provider with directory: '%s'; serving on: '%s'", historyPath, fhc.LocalPort)
	} else {
		handler.Log(robot.Info, "Initialized file history provider with directory: '%s'", historyPath)
	}
	return &fhc
}
</file_content file: gopherbot-main/history/file/filehistory.go>
<preamble file: gopherbot-main/history/file/static.go>

</preamble>
<file_content file: gopherbot-main/history/file/static.go>
package filehistory

import "github.com/lnxjedi/gopherbot/v2/bot"

func init() {
	bot.RegisterHistoryProvider("file", provider)
}
</file_content file: gopherbot-main/history/file/static.go>
<preamble file: gopherbot-main/jobs/backup.sh>

</preamble>
<file_content file: gopherbot-main/jobs/backup.sh>
#!/bin/bash -e

# backup.sh - back up job for backing up the robot's state (brain)
# Note: significant changes here should probably be done to save.sh, too

if [ "$GOPHER_BRAIN" != "file" ]
then
    exit 0
fi

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
    # The script should usually exit on error
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH"
        exit 1
    fi
done

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ -e ".restore" ]
then
    Log "Warn" "Found '.restore' file; restore in progress, not starting a backup"
    exit 0
fi

PTYPE="$GOPHER_PIPELINE_TYPE"

if [ "$PTYPE" == "plugCommand" -o "$PTYPE" == "jobCommand" ]
then
    Say "Starting backup requested by user $GOPHER_USER in channel: $GOPHER_START_CHANNEL"
fi

FailTask tail-log

if [ ! "$GOPHER_CUSTOM_REPOSITORY" ]
then
    Log "Error" "GOPHER_CUSTOM_REPOSITORY not set"
    exit 1
fi

if ! Exclusive "backup"
then
    Log "Info" "Unable to get exclusive access to 'backup', exiting"
    exit 0
fi

if [ "$GOPHER_STATE_REPOSITORY" ]
then
    PUSHBRANCH="${GOPHER_STATE_BRANCH:-main}"
    cd "$GOPHER_STATEDIR"
    if [ ! -d .git ]
    then
        NEWREPO="true"
        git init -b $PUSHBRANCH
        git remote add origin $GOPHER_STATE_REPOSITORY
        FailTask exec rm -rf ".git"
    fi
else
    GOPHER_STATE_REPOSITORY="$GOPHER_CUSTOM_REPOSITORY"
    PUSHBRANCH="${GOPHER_STATE_BRANCH:-robot-state}"
    if [ ! -d "$GOPHER_STATEDIR/.git" ]
    then
        if [ ! -d "$GOPHER_CONFIGDIR/.git" ]
        then
            Log "Error" "Backup to state branch specified, but $GOPHER_CONFIGDIR/.git doesn't exist"
            exit 0
        fi
        NEWREPO="true"
        # NOTE: technically, with no exclusive lock, GOPHER_CONFIGDIR
        # could change during the copy; however, this only happens once
        # on the first backup.
        cp -a "$GOPHER_CONFIGDIR" "$GOPHER_STATEDIR/custom"
        cd "$GOPHER_STATEDIR/custom"
        git checkout --orphan robot-state
        git rm -rf .
        mv .git/ ..
        cd ..
        rm -rf custom/
        CONFIGREPO=$(git remote get-url origin)
        GOPHER_STATE_REPOSITORY="$CONFIGREPO"
        FailTask exec rm -rf ".git"
    else
        cd "$GOPHER_STATEDIR"
    fi
fi

if [ -e ".failed" ]
then
    rm ".failed"
    FAILED="true"
fi

if [ -d "brain" -a ! -e "brain/README.txt" ]
then
    echo "Placeholder file for git backups, ensures brain directory is created." > brain/README.txt
fi

# Ignore known, noisy memories created by the default robot;
# ignore any memory with a leading underscore.
for IGNORE in 'bot:histories*' '*:repostats*' '*:_*'
do
    ALL_IGNORED=$(grep -F "$IGNORE" .gitignore || :)
    unset FOUND
    for IGNORED in $ALL_IGNORED
    do
        if [ "$IGNORED" == "$IGNORE" ]
        then
            FOUND=true
        fi
    done
    if [ ! "$FOUND" ]
    then
        Log "Debug" "Adding '$IGNORE' to .gitignore"
        echo "$IGNORE" >> .gitignore
    fi
done

CHANGES=$(git status --porcelain)

if [ ! "$CHANGES" -a ! "$NEWREPO" -a ! "$FAILED" ] # no changes
then
    if [ "$PTYPE" == "plugCommand" -o "$PTYPE" == "jobCommand" ]
    then
        Say "No changes, exiting..."
    fi
    exit 0
fi

SetWorkingDirectory "$GOPHER_STATEDIR"

if [ "$NEWREPO" ]
then
    AddTask git-init "$GOPHER_STATE_REPOSITORY"
else
    ORIGIN=$(git remote get-url origin)
    AddTask git-init "$ORIGIN"
    FailTask exec touch ".failed"
fi
if [ "$CHANGES" ]
then
    AddTask pause-brain
    FailTask resume-brain
    AddTask exec git add --all
    AddTask resume-brain
    AddTask exec git commit -m "Automated backup of robot state"
fi
if [ "$NEWREPO" ]
then
    AddTask exec git push -u origin $PUSHBRANCH
else
    AddTask exec git push
fi
if [ "$PTYPE" == "plugCommand" -o "$PTYPE" == "jobCommand" ]
then
    AddTask say "Backup complete"
fi
</file_content file: gopherbot-main/jobs/backup.sh>
<preamble file: gopherbot-main/jobs/changebranch.py>

</preamble>
<file_content file: gopherbot-main/jobs/changebranch.py>
#!/usr/bin/env python3

# changebranch.py - switch branches for development

import os, sys
from gopherbot_v2 import Robot

bot = Robot()

executable = sys.argv.pop(0)
branch = sys.argv.pop(0)

clone_url = os.getenv("GOPHER_CUSTOM_REPOSITORY")
cfgdir = os.getenv("GOPHER_CONFIGDIR")

if not clone_url:
    bot.Say("GOPHER_CUSTOM_REPOSITORY not set")
    exit()

if not cfgdir:
    bot.Say("GOPHER_CONFIGDIR not set")
    bot.Log("Error", "GOPHER_CONFIGDIR not set in changebranch.py")
    exit()

# Use the same lock for update and changing branches
if not bot.Exclusive("updatecfg", False):
    bot.Say("Configuration update already in progress")
    bot.Log("Warn", "Configuration update already in progress, exiting")
    exit()

bot.SetWorkingDirectory(cfgdir)
bot.FailTask("tail-log", [])

bot.AddTask("git-init", [ clone_url ])
# Get new branches
bot.AddTask("exec", [ "git", "pull" ])
# Switch to the branch
bot.AddTask("exec", [ "git", "checkout", branch ])
# Make sure we're on latest commit for the branch
bot.AddTask("exec", [ "git", "pull" ])
bot.AddTask("run-pipeline", [])
bot.AddCommand("builtin-admin", "reload")
</file_content file: gopherbot-main/jobs/changebranch.py>
<preamble file: gopherbot-main/jobs/github-poller.py>

</preamble>
<file_content file: gopherbot-main/jobs/github-poller.py>
#!/usr/bin/env python3

# github-poller.py - Loop through repositories.yaml and check github repos
# to see if they've changed. If so, start a gopherci build job.
# GITHUB_TOKEN needs to be provided in `robot.yaml`

import os
import json
import urllib.request
from gopherbot_v2 import Robot

bot = Robot()

def error_finish():
    log_ref = os.getenv("GOPHER_LOG_REF")
    bot.Say("There were errors polling github repositories, log: %s" % log_ref)
    exit(0)

token = os.getenv("GITHUB_TOKEN", '...')
if token == '...':
    bot.Log("Error", "GITHUB_TOKEN not found in environment")
    error_finish()

repodata = bot.GetRepoData()

if not isinstance(repodata, dict):
    bot.Log("Warn", "github-poller triggered with invalid 'repositories.yaml', not a python 'dict'")
    error_finish()

prefix = "https://api.github.com/repos"
fetch_error = False
remotes = {}
want_builds = {}

def fetch_refs(url):
    global fetch_error
    req = urllib.request.Request(url=url)
    req.add_header('Authorization', f'token {token}')
    try:
        res = urllib.request.urlopen(req)
    except urllib.error.HTTPError as e:
        fetch_error = True
        bot.Log("Error", "Fetching '%s': (%d) %s" % (url, e.code, e.read()))
        return {}, False
    body = res.read()
    return json.loads(body.decode("utf-8")), True

def read_repo(reponame, repoconf):
    _, org, name = reponame.split("/")
    fullname = "%s/%s" % (org, name)
    print("Checking repo %s" % reponame)
    refs = {}

    tagurl = "%s/%s/tags" % (prefix, fullname)
    tags, ok = fetch_refs(tagurl)
    if ok:
        for t in list(tags):
            name = t["name"]
            commit = t["commit"]["sha"]
            print("Found %s : %s / %s" % (reponame, name, commit))
            refs[name] = commit
    else:
        return {}

    branchurl = "%s/%s/branches" % (prefix, fullname)
    branches, ok = fetch_refs(branchurl)
    if ok:
        for b in list(branches):
            name = b["name"]
            commit = b["commit"]["sha"]
            print("Found %s : %s / %s" % (reponame, name, commit))
            refs[name] = commit
    else:
        return {}

    return refs

# Read refs for all github repos and store in remotes dict
for reponame in repodata.keys():
    host, org, name = reponame.split("/")
    if host == "github.com":
        repoconf = repodata[reponame]
        repotype = repoconf["Type"]
        if len(repotype) != 0 and repotype != "none":
            refs = read_repo(reponame, repoconf)
            if len(refs) > 0:
                remotes[reponame] = refs

# Retrive repo status memory
memory = bot.CheckoutDatum("repostats", True)
if not memory.exists:
    memory.datum = {}
repostats = memory.datum

want_builds = {}

for reponame in remotes.keys():
    repostat = {}
    first_seen = False
    if not reponame in repostats:
        first_seen = True
        repostats[reponame] = {}
    repostat = repostats[reponame]
    refs = remotes[reponame]
    for name in list(refs):
        commit = refs[name]
        last = ""
        if name in repostat:
            last = repostat[name]
        repostat[name] = commit
        changed = False
        if commit != last:
            changed = True
        print("Evaluating %s / %s: last built: %s, current: %s, changed: %s" % (reponame, name, last, commit, changed))
        if changed:
            repotype = repoconf["Type"]
            if first_seen:
                print("Skipping primary build for %s (branch %s) to the pipeline, type '%s' (first time seen)" % (reponame, name, repotype))
            else:
                print("Adding primary build for %s (branch %s) to the pipeline, type '%s'" % (reponame, name, repotype))
                want_builds[reponame] = name
    for name in list(repostat):
        if not name in refs:
            print("Pruning %s from %s, no longer present" % (name, reponame))
            repostat.pop(name)

memory.datum = repostats
ret = bot.UpdateDatum(memory)
if ret != Robot.Ok:
    bot.Log("Error", "Unable to save long-term memory in github-poller: %s" % ret)
    error_finish()

for reponame in list(want_builds):
    name = want_builds[reponame]
    bot.SpawnJob("gopherci", [ "build", reponame, name ])

if fetch_error:
    error_finish()
</file_content file: gopherbot-main/jobs/github-poller.py>
<preamble file: gopherbot-main/jobs/gopherci.py>

</preamble>
<file_content file: gopherbot-main/jobs/gopherci.py>
#!/usr/bin/env python3

# gopherci.py - Dispatcher for commit events, spawns the appropriate build job.
# NOTE: Don't use SetParameter(...) here; build_triggered jobs don't inherit
# environment.

# Operation:
# When a repository updates, gopherci is called with the repository
# name and branch (two arguments).
# - If the repository is listed in "repositories.yaml" with
#   type != none, a build task is added.
# - The the repository is listed as a dependency for another repository whose
#   type != none, another gopherci task is added with a third argument of "true"
# When the gopherci job runs with three arguments, each dependendent build
# is spawned.
#
# The result is if the initial build succeeds, all dependent builds will run
# in parallel with no further interdependencies.
#
# NOTE: current gopherci does not cascade dependent builds; if a dependency
# build is itself a de

import sys
from gopherbot_v2 import Robot

bot = Robot()

repodata = bot.GetRepoData()

if not isinstance(repodata, dict):
    bot.Log("Warn", "GopherCI triggered with invalid 'repositories.yaml', not a python 'dict'")
    exit(0)

build_triggered = False

# Pop off the executable path
sys.argv.pop(0)

def get_deps(repository, recurse, all_deps = []):
    deps = []
    for reponame in repodata.keys():
        if repodata[reponame]["Dependencies"] != None:
            if repository in repodata[reponame]["Dependencies"]:
                repoconf = repodata[reponame]
                repotype = repoconf["Type"]
                if len(repotype) != 0 and repotype != "none":
                    if reponame in all_deps:
                        raise Exception("Found duplicate dependency %s while walking the dependency tree" % reponame)
                    deps.append(reponame)
                    all_deps.append(reponame)
    if recurse:
        if not deps:
            return deps
        for dep in deps:
            get_deps(dep, True, all_deps)

    return deps

if len(sys.argv) == 2:
    command = "build"
else:
    command = sys.argv.pop(0)

repository = sys.argv.pop(0)
branch = sys.argv.pop(0)

if command == "build":
    if branch.endswith("/"): # illegal end char; assume args swapped
        repository, branch = branch, repository

    if repository.endswith("/"):
        repository = repository.rstrip("/")
    if repository in repodata:
        repoconf = repodata[repository]
        if "Type" in repoconf:
            repotype = repoconf["Type"]
            if repotype != "none":
                build_triggered = True
                bot.Log("Debug", "Adding primary build for %s / %s to the pipeline" % (repository, branch))
                bot.AddJob(repotype, [ "build", repository, branch ])
    try:
        deps = get_deps(repository, True)
    except Exception as e:
        err = "Resolving dependencies for %s / %s: %s" % (repository, branch, e)
        bot.Log("Error", err)
        bot.AddTask("status", [ err ])
        exit(0)
    if deps:
        build_triggered = True
        bot.Log("Debug", "Starting builds for everything that depends on %s / %s" % (repository, branch))
        bot.AddJob("gopherci", [ "builddeps", repository, branch ])

if command == "job":
    # Run a custom pipeline
    pipeline = sys.argv.pop(0)
    if repository in repodata:
        repoconf = repodata[repository]
        if "Type" in repoconf:
            repotype = repoconf["Type"]
            if repotype != "none":
                bot.Log("Debug", "Adding custom job for %s / %s to the pipeline, running pipeline: %s" % (repository, branch, pipeline))
                bot.AddJob(repotype, [ "job", repository, branch, pipeline ] + sys.argv )
                exit()
    bot.Log("Error", "Missing repository '%s' or repository Type for custom job: %s" % (repository, pipeline))
    exit()

if command == "builddeps":
    # build depdencies for a repository
    build_triggered = True
    for reponame in repodata.keys():
        if repodata[reponame]["Dependencies"] != None:
            if repository in repodata[reponame]["Dependencies"]:
                repoconf = repodata[reponame]
                repotype = repoconf["Type"]
                if len(repotype) != 0 and repotype != "none":
                    if "default_branch" in repoconf:
                        repobranch = repoconf["default_branch"]
                    else:
                        repobranch = "."
                    bot.Log("Debug", "Spawning dependency build of %s / %s for primary build of %s / %s" % (reponame, repobranch, repository, branch))
                    bot.SpawnJob("gopherci", [ "depbuild", reponame, repobranch, repository, branch ])

if command == "depbuild":
    # Inital build of dependency
    # build repo + deps
    build_triggered = True
    deprepo = sys.argv.pop(0)
    depbranch = sys.argv.pop(0)
    if repository in repodata:
        repoconf = repodata[repository]
        repotype = repoconf["Type"]
        if len(repotype) != 0 and repotype != "none":
            build_triggered = True
            bot.Log("Debug", "Adding primary dependency build for %s / %s to the pipeline, triggered by %s / %s" % (repository, branch, deprepo, depbranch))
            bot.AddJob(repotype, [ "depbuild", repository, branch, deprepo, depbranch ])
    deps = get_deps(repository, False)
    if deps:
        bot.Log("Debug", "Starting builds for everything that depends on %s / %s (initially triggered by %s / %s" % (repository, branch, deprepo, depbranch))
        bot.AddJob("gopherci", [ "builddeps", repository, branch ])

if not build_triggered:
    bot.Log("Debug", "Ignoring update on '%s', no builds triggered" % repository)
</file_content file: gopherbot-main/jobs/gopherci.py>
<preamble file: gopherbot-main/jobs/install-libs.sh>

</preamble>
<file_content file: gopherbot-main/jobs/install-libs.sh>
#!/bin/bash -e

cd custom

if [ -e "requirements.txt" ]
then
    pip install -r requirements.txt
fi

if [ -e "Gemfile" ]
then
    bundle check || bundle install
fi
</file_content file: gopherbot-main/jobs/install-libs.sh>
<preamble file: gopherbot-main/jobs/localbuild.py>

</preamble>
<file_content file: gopherbot-main/jobs/localbuild.py>
#!/usr/bin/env python3

# localbuild.py - Clone a repository locally and run .gopherci/pipeline.sh

# localbuild is one of possibly several build types for a repository. When
# called with two arguments, they are interpreted as the repository and branch
# of a primary build. When called with four arguments, the first two are the
# repository and branch to build, and the second two are the repository and
# branch that triggered the build.
#
# The build type is responsible for calling Exclusive, setting up the build
# directory, and adding the initial pipeline tasks. All other
# pipeline/dependency logic is in gopherci.

import sys
from gopherbot_v2 import Robot

bot = Robot()

# Pop off the executable path
sys.argv.pop(0)

# localbuild and all build types always get a "command" from gopherci,
# never triggered.
# One of "build", "depbuild", "job"
command = sys.argv.pop(0)

repository = sys.argv.pop(0)
branch = sys.argv.pop(0)

bot.SetParameter("GOPHERCI_BRANCH", branch)
pipeline = "pipeline"

if command == "job":
    pipeline = sys.argv.pop(0)
    bot.SetParameter("GOPHERCI_CUSTOM_PIPELINE", pipeline)

if command == "depbuild":
    deprepo = sys.argv.pop(0)
    depbranch = sys.argv.pop(0)
    bot.SetParameter("GOPHERCI_DEPBUILD", "true")
    bot.SetParameter("GOPHERCI_DEPREPO", deprepo)
    bot.SetParameter("GOPHERCI_DEPBRANCH", depbranch)

repodata = bot.GetRepoData()

if repository in repodata:
    repoconf = repodata[repository]

clone_url = repoconf["CloneURL"]
if len(clone_url) == 0:
    bot.Say("No 'clone_url' specified for '%s' in repositories.yaml" % repository)
    exit(1)

keep_history = repoconf["KeepLogs"]
if keep_history == None:
    keep_history = -1

# Protect the repository directory with Exclusive
if not bot.Exclusive(repository, False):
    bot.Log("Warn", "Build of '%s' already in progress, exiting" % repository)
    if len(bot.user) > 0:
        bot.Say("build for '%s' already in progress, not starting a new build for branch '%s'" % (repository, branch))
    exit()

repobranch = "%s/%s" % (repository, branch)
bot.ExtendNamespace(repobranch, keep_history)

bot.AddTask("start-build", [])
bot.AddTask("git-init", [ clone_url ])
# Start with a clean jobdir
bot.AddTask("cleanup", [ repository ])
bot.AddTask("git-clone", [ clone_url, branch, repository, "true" ])
bot.AddTask("run-pipeline", [ pipeline ] + sys.argv)
bot.FinalTask("finish-build", [])
</file_content file: gopherbot-main/jobs/localbuild.py>
<preamble file: gopherbot-main/jobs/logrotate.sh>

</preamble>
<file_content file: gopherbot-main/jobs/logrotate.sh>
#!/bin/bash

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

OLD="log.$(date +%a)"
AddTask "rotate-log" "$OLD"
</file_content file: gopherbot-main/jobs/logrotate.sh>
<preamble file: gopherbot-main/jobs/restore.sh>

</preamble>
<file_content file: gopherbot-main/jobs/restore.sh>
#!/bin/bash -e

# restore.sh - restore the robot's state from git

if [ "$GOPHER_BRAIN" != "file" ]
then
    exit 0
fi

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
    # The script should usually exit on error
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH"
        exit 1
    fi
done

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

FailTask tail-log

PTYPE=$GOPHER_PIPELINE_TYPE
if [ \( "$PTYPE" == "plugCommand" -o "$PTYPE" == "jobCommand" \) -a "$GOPHER_USER" ]
then
    INTERACTIVE="true"
fi

if [ "$GOPHER_PROTOCOL" == "terminal" ]
then
    TERMINAL="true"
fi

report(){
    local LEVEL=$1
    local MESSAGE=$2
    Log "$LEVEL" "$MESSAGE"
    if [ "$INTERACTIVE" ]
    then
        Say "$MESSAGE"
    fi
}

# GOPHER_STATEDIR should be defined in the "manage" namespace
if [ -z "$GOPHER_STATEDIR" ]
then
    report "Warn" "GOPHER_STATEDIR not defined, giving up"
    rm -f .restore
    exit 0
fi

if [ -e "$GOPHER_STATEDIR/.git" -a ! "$1" ]
then
    report "Warn" "'$GOPHER_STATEDIR/.git' exists, use 'force' to restore anyway"
    exit 1
fi

if [ ! -e "$GOPHER_STATEDIR" ]
then
    report "Info" "Directory '$GOPHER_STATEDIR' not found, assuming non-file brain"
    rm -f .restore
    exit 0
fi

if [ ! "$GOPHER_STATE_REPOSITORY" ]
then
    CONFIGREPO=$(cd $GOPHER_CONFIGDIR; git remote get-url origin)
    GOPHER_STATE_REPOSITORY="$CONFIGREPO"
    GOPHER_STATE_BRANCH="${GOPHER_STATE_BRANCH:-robot-state}"
else
    GOPHER_STATE_BRANCH="${GOPHER_STATE_BRANCH:-.}"
fi

if ! Exclusive "backup"
then
    report "Warn" "Unable to get exclusive access to 'backup' in restore job, exiting"
    exit 1
fi

if [ "$INTERACTIVE" ]
then
    Say "Starting state restore requested by user $GOPHER_USER in channel: $GOPHER_START_CHANNEL"
elif [ "$TERMINAL" ]
then
    Say "Starting restore of robot state..."
fi

AddTask git-init "$GOPHER_STATE_REPOSITORY"
# Not certain this will all happen within lockMax, but *shrug*
AddTask pause-brain
FailTask resume-brain
AddTask exec mv "$GOPHER_STATEDIR" "$GOPHER_STATEDIR.tmp"
AddTask git-clone "$GOPHER_STATE_REPOSITORY" "$GOPHER_STATE_BRANCH" "$GOPHER_STATEDIR"
AddTask resume-brain
AddTask exec rm -rf "$GOPHER_STATEDIR.tmp"
AddTask exec rm -f ".restore"
FailTask exec rm -rf "$GOPHER_STATEDIR"
FailTask exec mv "$GOPHER_STATEDIR.tmp" "$GOPHER_STATEDIR"
FailTask status "Failed restoring git/file memories; no backup available?"
FailTask exec rm -f ".restore"
if [ "$INTERACTIVE" -o "$TERMINAL" ]
then
    AddTask say "Restore finished"
fi
</file_content file: gopherbot-main/jobs/restore.sh>
<preamble file: gopherbot-main/jobs/save.sh>

</preamble>
<file_content file: gopherbot-main/jobs/save.sh>
#!/bin/bash -e

# save.sh - save robot's configuration to GOPHER_CUSTOM_REPOSITORY
# Note: significant changes here should probably be done to backup.sh, too

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
    # The script should usually exit on error
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH"
        exit 1
    fi
done

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

FailTask tail-log

PTYPE="$GOPHER_PIPELINE_TYPE"

if [ "$PTYPE" == "plugCommand" -o "$PTYPE" == "jobCommand" ]
then
    CHANNEL=${GOPHER_START_CHANNEL:-(direct message)}
    Say "Starting config save requested by user $GOPHER_USER in channel: $CHANNEL"
fi

if [ ! "$GOPHER_CUSTOM_REPOSITORY" ]
then
    Log "Error" "GOPHER_CUSTOM_REPOSITORY not set"
    exit 1
fi

if ! Exclusive "save"
then
    Log "Info" "Unable to get exclusive access to 'save', exiting"
    exit 0
fi

cd $GOPHER_CONFIGDIR
if [ ! -d .git ]
then
    NEWREPO="true"
else
    CHANGES=$(git status --porcelain)
    COMMITS=$(git cherry)
fi

if [ ! "$CHANGES" -a ! "$COMMITS" -a ! "$NEWREPO" ] # no changes
then
    if [ "$PTYPE" == "plugCommand" -o "$PTYPE" == "jobCommand" ]
    then
        Say "No changes, exiting..."
    fi
    exit 0
fi

SetWorkingDirectory "$GOPHER_CONFIGDIR"
AddTask git-init "$GOPHER_CUSTOM_REPOSITORY"
if [ "$NEWREPO" ]
then
    AddTask exec git clone "$GOPHER_CUSTOM_REPOSITORY" empty
    AddTask exec mv empty/.git .
    AddTask exec rm -rf empty
    FailTask exec rm -rf .git
fi
if [ "$CHANGES" -o "$NEWREPO" ]
then
    AddTask exec git add --all
    AddTask exec git commit -m "Save robot configuration"
fi
AddTask exec git push
if [ "$PTYPE" == "plugCommand" -o "$PTYPE" == "jobCommand" ]
then
    AddTask say "Save finished"
fi
</file_content file: gopherbot-main/jobs/save.sh>
<preamble file: gopherbot-main/jobs/ssh-job.sh>

</preamble>
<file_content file: gopherbot-main/jobs/ssh-job.sh>
#!/bin/bash -e

# ssh-job.sh - simple wrapper job for ssh tasks
# NOTE: This script is both a job - 'ssh-job', and a task - 'ssh-task'
# Normal usage is to define multiple jobs with the same path to this script,
# but different values for REMOTEHOST and REMOTETASK (name of task to run).
# Can also call with e.g.:
# - AddJob ssh-job <host> <task> (args...)
# - AddTask ssh-task <host> <task> (args...)
#
# Then, in your task, you can use ssh somewhat normally, but adding
# "$SSH_OPTIONS", e.g. "ssh $SSH_OPTIONS <user>@<host>"

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
    # The script should usually exit on error
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH"
        exit 1
    fi
done

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ "$REMOTEHOST" -o "$REMOTETASK" ]
then
    if [ ! \( "$REMOTEHOST" -a "$REMOTETASK" \) ]
    then
        Log "Error" "Only one of REMOTEHOST or REMOTETASK set"
        exit 1
    fi
else
    if [ $# -ge 2 ]
    then
        REMOTEHOST=$1
        REMOTETASK=$2
        shift 2
    else
        Log "Error" "REMOTEHOST and REMOTETASK not set or provided in arguments"
        exit 1
    fi
fi

if [ ! "$REMOTEHOST" ]
then
    Log "Error" "REMOTEHOST not provided in parameters or arguments"
    exit 1
fi

if [ ! "$REMOTETASK" ]
then
    Log "Error" "REMOTETASK not provided in parameters or arguments"
    exit 1
fi

AddTask ssh-init
AddTask ssh-scan $REMOTEHOST
AddTask $REMOTETASK "$@"
exit 0
</file_content file: gopherbot-main/jobs/ssh-job.sh>
<preamble file: gopherbot-main/jobs/theia.sh>

</preamble>
<file_content file: gopherbot-main/jobs/theia.sh>
#!/bin/bash

# theia.sh - start theia interface; use ps & kill to terminate

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

FailTask tail-log

mkdir -p "$HOME/.ssh"
chmod 0700 "$HOME/.ssh"
echo "$DEV_PRIVATE_KEY" | base64 -d > $HOME/.ssh/id_code # not really
chmod 0600 "$HOME/.ssh/id_code"

cat > $HOME/.bashrc <<EOF
cat <<WELCOME
Welcome to the Gopherbot Theia IDE.
Use 'stop-theia' to quit.
WELCOME
stop-theia(){
   kill \$(cat /tmp/theia.pid)
}
load-ssh-key(){
   ssh-add \$HOME/.ssh/id_code
}
if ! ssh-add -l &>/dev/null
then
   echo "Use 'load-ssh-key' to load your coding key (\$DEV_KEY_NAME)."
fi
PS1="\[\033[01;32m\]robot@gopherbot-ide\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ "
EOF

SetParameter "GOPHERBOT_IDE" "true"

AddTask git-init $GOPHER_CUSTOM_REPOSITORY
AddTask run-theia
</file_content file: gopherbot-main/jobs/theia.sh>
<preamble file: gopherbot-main/jobs/updatecfg.py>

</preamble>
<file_content file: gopherbot-main/jobs/updatecfg.py>
#!/usr/bin/env python3

# updatecfg.py - clone or update the robot's config repository.

# With Gopherbot 2.0, there's a strong assumption that custom
# configuration for the robot (jobs, plugins, yaml files) are stored
# in a git repository specified in the GOPHER_CUSTOM_REPOSITORY
# environment variable, which translates to CUSTOM_REPOSITORY_URL
# in the job (see the definition for the updatecfg job in
# conf/robot.yaml). When this job is run, the robot will attempt
# to clone or pull it's configuration repository.

# Note that if your config repo has a '.gopherci/pipeline.sh', it'll
# get executed - useful for e.g. installing $HOME/.ssh/config.

import os
from gopherbot_v2 import Robot

bot = Robot()

clone_url = os.getenv("GOPHER_CUSTOM_REPOSITORY")
clone_branch = os.getenv("GOPHER_CUSTOM_BRANCH")
cfgdir = os.getenv("GOPHER_CONFIGDIR")

if not clone_url:
    bot.Say("GOPHER_CUSTOM_REPOSITORY not set")
    exit()

if not cfgdir:
    bot.Say("GOPHER_CONFIGDIR not set")
    bot.Log("Error", "GOPHER_CONFIGDIR not set in updatecfg.py")
    exit()

if not bot.Exclusive("updatecfg", False):
    bot.Say("Configuration update already in progress")
    bot.Log("Warn", "Configuration update already in progress, exiting")
    exit()

bot.SetWorkingDirectory(cfgdir)
bot.FailTask("tail-log", [])
bot.FailTask("status", [ "Updating configuration failed"])

bot.AddTask("git-init", [ clone_url ])
bot.AddTask("exec", [ "git", "pull" ])
bot.AddTask("run-pipeline", [])
bot.AddTask("status", [ "Custom configuration repository successfully updated" ])
bot.AddCommand("builtin-admin", "reload")
</file_content file: gopherbot-main/jobs/updatecfg.py>
<preamble file: gopherbot-main/lib/README.txt>

</preamble>
<file_content file: gopherbot-main/lib/README.txt>
This directory is for language-specific libraries for writing plugins.
</file_content file: gopherbot-main/lib/README.txt>
<preamble file: gopherbot-main/lib/gopherbot_v1.py>

</preamble>
<file_content file: gopherbot-main/lib/gopherbot_v1.py>
import os
import json
import random
import subprocess
import sys
import time
import urllib2

# python 2 version

class Attribute:
    "A Gopherbot Attribute return object"
    def __init__(self, ret):
        self.attr = ret["Attribute"]
        self.ret = ret["RetVal"]

    def __str__(self):
        return self.attr

class Reply:
    "A Gopherbot Reply return object"
    def __init__(self, ret):
        self.reply = ret["Reply"]
        self.ret = ret["RetVal"]

    def __str__(self):
        return self.reply

class Memory:
    "A Gopherbot long-term memory object"
    def __init__(self, key, ret):
        self.key = key
        self.lock_token = ret["LockToken"]
        self.exists = ret["Exists"]
        self.datum = ret["Datum"]
        self.ret = ret["RetVal"]

class Robot:
    "Instantiate a robot object for use with Gopherbot"

    # Return values for robot method calls
    Ok = 0
    UserNotFound = 1
    ChannelNotFound = 2
    AttributeNotFound = 3
    FailedMessageSend = 4
    FailedChannelJoin = 5
    DatumNotFound = 6
    DatumLockExpired = 7
    DataFormatError = 8
    BrainFailed = 9
    InvalidDatumKey = 10
    InvalidDblPtr = 11
    InvalidCfgStruct = 12
    NoConfigFound = 13
    RetryPrompt = 14
    ReplyNotMatched = 15
    UseDefaultValue = 16
    TimeoutExpired = 17
    Interrupted = 18
    MatcherNotFound = 19
    NoUserEmail = 20
    NoBotEmail = 21
    MailError = 22
    TaskNotFound = 23
    MissingArguments = 24
    InvalidStage = 25

    # Plugin return values / exit codes
    Normal = 0
    Fail = 1
    MechanismFail = 2
    ConfigurationError = 3
    NotFound = 6
    Success = 7

    def __init__(self):
        random.seed()
        self.channel = os.getenv("GOPHER_CHANNEL")
        self.thread_id = os.getenv("GOPHER_THREAD_ID")
        self.threaded_message = os.getenv("GOPHER_THREADED_MESSAGE")
        self.user = os.getenv("GOPHER_USER")
        self.plugin_id = os.getenv("GOPHER_CALLER_ID")
        self.format = ""
        self.protocol = os.getenv("GOPHER_PROTOCOL")

    def Call(self, func_name, func_args, format=""):
        if len(format) == 0:
            format = self.format
        func_call = { "FuncName": func_name, "Format": format,
                    "CallerID": self.plugin_id,
                    "FuncArgs": func_args }
        func_json = json.dumps(func_call)
        req = urllib2.Request(url="%s/json" % os.getenv("GOPHER_HTTP_POST"),
            data=func_json)
        req.add_header('Content-Type', 'application/json')
        # sys.stderr.write("Sending: %s\n" % func_json)
        f = urllib2.urlopen(req)
        body = f.read()
        # sys.stderr.write("Got back: %s\n" % body)
        return json.loads(body)

    def CheckAdmin(self):
        return self.Call(sys._getframe().f_code.co_name, {})["Boolean"]

    def Subscribe(self):
        return self.Call(sys._getframe().f_code.co_name, {})["Boolean"]

    def Unsubscribe(self):
        return self.Call(sys._getframe().f_code.co_name, {})["Boolean"]

    def Elevate(self, immediate=False):
        return self.Call(sys._getframe().f_code.co_name, { "Immediate": immediate })["Boolean"]

    def Pause(self, s):
        time.sleep(s)

    def RandomString(self, sa):
        return sa[random.randint(0, (len(sa)-1))]

    def GetTaskConfig(self):
        return self.Call(sys._getframe().f_code.co_name, {})

    def CheckoutDatum(self, key, rw):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": key, "RW": rw })
        return Memory(key, ret)

    def SpawnJob(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def AddJob(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def AddTask(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def FinalTask(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def FailTask(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def AddCommand(self, plugin, cmd):
        return self.Call(sys._getframe().f_code.co_name, { "Plugin": plugin, "Command": cmd })["RetVal"]

    def FinalCommand(self, plugin, cmd):
        return self.Call(sys._getframe().f_code.co_name, { "Plugin": plugin, "Command": cmd })["RetVal"]

    def FailCommand(self, plugin, cmd):
        return self.Call(sys._getframe().f_code.co_name, { "Plugin": plugin, "Command": cmd })["RetVal"]

    def SetParameter(self, name, value):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "Value": value })["Boolean"]

    def Exclusive(self, tag, queue_task=False):
        return self.Call(sys._getframe().f_code.co_name, { "Tag": tag, "QueueTask": queue_task })["Boolean"]

    def ExtendNamespace(self, ns, hist):
        return self.Call(sys._getframe().f_code.co_name, { "Extend": ns, "Histories": hist })["Boolean"]

    def SetWorkingDirectory(self, path):
        return self.Call(sys._getframe().f_code.co_name, { "Path": path })["Boolean"]

    def GetRepoData(self):
        return self.Call(sys._getframe().f_code.co_name, {})

    def Log(self, level, msg):
        self.Call(sys._getframe().f_code.co_name, { "Level": level, "Message": msg })

    def CheckinDatum(self, m):
        self.Call(sys._getframe().f_code.co_name, { "Key": m.key, "Token": m.lock_token })

    def UpdateDatum(self, m):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": m.key, "Token": m.lock_token,
        "Datum": m.datum })
        return ret["RetVal"]

    def GetSenderAttribute(self, attr):
        ret = self.Call(sys._getframe().f_code.co_name, { "Attribute": attr })
        return Attribute(ret)

    def GetUserAttribute(self, user, attr):
        ret = self.Call(sys._getframe().f_code.co_name, { "User": user, "Attribute": attr })
        return Attribute(ret)

    def GetBotAttribute(self, attr):
        ret = self.Call(sys._getframe().f_code.co_name, { "Attribute": attr })
        return Attribute(ret)

    def Remember(k, v, shared=False):
        funcname = "RememberThread" if self.threaded_message else "Remember"
        ret = self.Call(funcname, { "Key": k, "Value": v, "Shared": shared })
        return ret["RetVal"]

    def RememberContext(k, v):
        return self.Remember("context:"+k, v, False)

    def RememberThread(k, v, shared=False):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": k, "Value": v, "Shared": shared })
        return ret["RetVal"]

    def RememberContextThread(k, v):
        return self.RememberThread("context:"+k, v, False)

    def Recall(self, memory, shared=False):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": memory, "Shared": shared })
        return ret["StrVal"]

    def PromptForReply(self, regex_id, prompt, format=""):
        thread = ""
        if self.threaded_message:
            thread = self.thread_id
        return self.PromptUserChannelThreadForReply(regex_id, self.user, self.channel, thread, prompt, format)

    def PromptThreadForReply(self, regex_id, prompt, format=""):
        return self.PromptUserChannelThreadForReply(regex_id, self.user, self.channel, self.thread_id, prompt, format)

    def PromptUserForReply(self, regex_id, user, prompt, format=""):
        return self.PromptUserChannelThreadForReply(regex_id, user, "", prompt, format)

    def PromptUserChannelThreadForReply(self, regex_id, user, channel, thread, prompt, format=""):
        for i in range(0, 3):
            rep = self.Call(sys._getframe().f_code.co_name, { "RegexID": regex_id, "User": user, "Channel": channel, "Thread": thread, "Prompt": prompt }, format)
            if rep["RetVal"] == self.RetryPrompt:
                continue
            return Reply(rep)
        if rep["RetVal"] == self.RetryPrompt:
            rep["RetVal"] = self.Interrupted
        return Reply(rep)

    def SendChannelMessage(self, channel, message, format=""):
        return self.SendChannelThreadMessage(channel, "", message, format)

    def SendChannelThreadMessage(self, channel, thread, message, format=""):
        ret = self.Call(sys._getframe().f_code.co_name, { "Channel": channel, "Thread": thread,
        "Message": message }, format)
        return ret["RetVal"]

    def SendUserMessage(self, user, message, format=""):
        ret = self.Call(sys._getframe().f_code.co_name, { "User": user,
        "Message": message }, format)
        return ret["RetVal"]

    def SendUserChannelMessage(self, user, channel, message, format=""):
        return self.SendUserChannelThreadMessage(user, channel, "", message, format)

    def SendUserChannelThreadMessage(self, user, channel, thread, message, format=""):
        ret = self.Call(sys._getframe().f_code.co_name, { "User": user,
        "Channel": channel, "Thread": thread, "Message": message }, format)
        return ret["RetVal"]

    def Say(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            thread = ""
            if self.threaded_message:
                thread = self.thread_id
            return self.SendChannelThreadMessage(self.channel, thread, message, format)

    def SayThread(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            return self.SendChannelThreadMessage(self.channel, self.thread_id, message, format)

    def Reply(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            thread = ""
            if self.threaded_message:
                thread = self.thread_id
            return self.SendUserChannelThreadMessage(self.user, self.channel, thread, message, format)

    def ReplyThread(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            return self.SendUserChannelThreadMessage(self.user, self.channel, self.thread_id, message, format)

    def Direct(self):
        "Get a direct messaging instance of the robot"
        return DirectBot(self)

    def MessageFormat(self, format):
        "Get a bot with a non-default message format"
        return FormattedBot(self, format)

    def Threaded(self):
        "Get a bot associated with the message thread"
        return ThreadedBot(self)

class DirectBot(Robot):
    "Instantiate a robot for direct messaging with the user"
    def __init__(self, bot):
        self.channel = ""
        self.thread_id = ""
        self.threaded_message = None
        self.user = bot.user
        self.protocol = bot.protocol
        self.format = bot.format
        self.plugin_id = bot.plugin_id

class FormattedBot(Robot):
    "Instantiate a robot with a non-default message format"
    def __init__(self, bot, format):
        self.channel = bot.channel
        self.thread_id = bot.thread_id
        self.threaded_message = bot.threaded_message
        self.user = bot.user
        self.protocol = bot.protocol
        self.format = format
        self.plugin_id = bot.plugin_id

class ThreadedBot(Robot):
    "Instantiate a robot with a non-default message format"
    def __init__(self, bot):
        self.channel = bot.channel
        self.thread_id = bot.thread_id
        if len(self.channel) > 0:
            self.threaded_message = "true"
        else:
            self.threaded_message = None
        self.user = bot.user
        self.protocol = bot.protocol
        self.format = bot.format
        self.plugin_id = bot.plugin_id
</file_content file: gopherbot-main/lib/gopherbot_v1.py>
<preamble file: gopherbot-main/lib/gopherbot_v1.rb>

</preamble>
<file_content file: gopherbot-main/lib/gopherbot_v1.rb>
require 'json'
require 'net/http'
require 'uri'

class Attribute
	def initialize(attr, ret)
		@attr = attr
		@ret = ret
	end

	attr_reader :attr, :ret

	def to_s
		@attr
	end
end

class Reply
	def initialize(reply, ret)
		@reply = reply
		@ret = ret
	end

	attr_reader :reply, :ret

	def to_s
		@reply
	end
end

class Memory
	def initialize(key, lt, exists, datum, ret)
		@key = key
		@lock_token = lt
		@exists = exists
		@datum = datum
		@ret = ret
	end

	attr_reader :key, :lock_token, :exists, :ret
	attr :datum, true
end

class BaseBot
	# Return values for robot method calls
	Ok = 0
	UserNotFound = 1
	ChannelNotFound = 2
	AttributeNotFound = 3
	FailedMessageSend = 4
	FailedChannelJoin = 5
	DatumNotFound = 6
	DatumLockExpired = 7
	DataFormatError = 8
	BrainFailed = 9
	InvalidDatumKey = 10
	InvalidDblPtr = 11
	InvalidCfgStruct = 12
	NoConfigFound = 13
	RetryPrompt = 14
	ReplyNotMatched = 15
	UseDefaultValue = 16
	TimeoutExpired = 17
	Interrupted = 18
	MatcherNotFound = 19
	NoUserEmail = 20
	NoBotEmail = 21
	MailError = 22
	TaskNotFound = 23
	MissingArguments = 24
	InvalidStage = 25

	# Plugin return values / exit codes
	Normal = 0
	Fail = 1
	MechanismFail = 2
	ConfigurationError = 3
	NotFound = 6
	Success = 7

	attr_reader :user, :channel

	def Direct()
	end

	def RandomString(sarr)
		return sarr[@prng.rand(sarr.size)]
	end

	def RandomInt(i)
		return @prng.rand(i)
	end

	def CheckAdmin()
		return callBotFunc(__method__, {})["Boolean"]
	end

	def Subscribe()
		return callBotFunc(__method__, {})["Boolean"]
	end

	def Unsubscribe()
		return callBotFunc(__method__, {})["Boolean"]
	end

	def Elevate(immediate=false)
		return callBotFunc(__method__, { "Immediate" => immediate })["Boolean"]
	end

	def SpawnJob(name, args)
		return callBotFunc(__method__, { "Name" => name, "CmdArgs" => args })["RetVal"]
	end

	def AddJob(name, args)
		return callBotFunc(__method__, { "Name" => name, "CmdArgs" => args })["RetVal"]
	end

	def AddTask(name, args)
		return callBotFunc(__method__, { "Name" => name, "CmdArgs" => args })["RetVal"]
	end

	def FinalTask(name, args)
		return callBotFunc(__method__, { "Name" => name, "CmdArgs" => args })["RetVal"]
	end

	def FailTask(name, args)
		return callBotFunc(__method__, { "Name" => name, "CmdArgs" => args })["RetVal"]
	end

	def AddCommand(name, arg)
		return callBotFunc(__method__, { "Plugin" => name, "Command" => arg })["RetVal"]
	end

	def FinalCommand(name, arg)
		return callBotFunc(__method__, { "Plugin" => name, "Command" => arg })["RetVal"]
	end

	def FailCommand(name, arg)
		return callBotFunc(__method__, { "Plugin" => name, "Command" => arg })["RetVal"]
	end

	def SetParameter(name, value)
		return callBotFunc(__method__, { "Name" => name, "Value" => value })["Boolean"]
	end

	def Exclusive(tag, queue_task=false)
		return callBotFunc(__method__, { "Tag" => tag, "QueueTask" => queue_task })["Boolean"]
	end

	def ExtendNamespace(ns, hist)
		return callBotFunc(__method__, { "Extend" => ns, "Histories" => hist })["Boolean"]
	end

	def SetWorkingDirectory(path)
		return callBotFunc(__method__, { "Path" => path })["Boolean"]
	end

	def GetRepoData()
		return callBotFunc(__method__, {})
	end

	def CheckoutDatum(key, rw)
		args = { "Key" => key, "RW" => rw }
		ret = callBotFunc(__method__, args)
		return Memory.new(key, ret["LockToken"], ret["Exists"], ret["Datum"], ret["RetVal"])
	end

	def CheckinDatum(m)
		args = { "Key" => m.key, "Token" => m.lock_token }
		callBotFunc(__method__, args)
		return 0
	end

	def UpdateDatum(m)
		args = { "Key" => m.key, "Token" => m.lock_token, "Datum" => m.datum }
		ret = callBotFunc(__method__, args)
		return ret["RetVal"]
	end

	def Remember(k, v, shared = false)
		funcName = @threaded_message ? "RememberThread" : "Remember"
		args = { "Key" => k, "Value" => v, "Shared" => shared }
		ret = callBotFunc(funcName, args)
		return ret["RetVal"]
	end

	def RememberContext(c, v)
		return Remember("context:"+c, v, false)
	end

	def RememberThread(k, v, shared = false)
		args = { "Key" => k, "Value" => v, "Shared" => shared }
		ret = callBotFunc(__method__, args)
		return ret["RetVal"]
	end

	def RememberContextThread(c, v)
		return RememberThread("context:"+c, v, false)
	end

	def Recall(k, shared = false)
		args = { "Key" => k, "Shared" => shared }
		ret = callBotFunc(__method__, args)["StrVal"]
	end

	def GetTaskConfig()
		ret = callBotFunc(__method__, {})
		return ret
	end

	def GetSenderAttribute(attr)
		args = { "Attribute" => attr }
		ret = callBotFunc(__method__, args)
		return Attribute.new(ret["Attribute"], ret["RetVal"])
	end

	def GetUserAttribute(user, attr)
		args = { "User" => user, "Attribute" => attr }
		ret = callBotFunc(__method__, args)
		return Attribute.new(ret["Attribute"], ret["RetVal"])
	end

	def GetBotAttribute(attr)
		args = { "Attribute" => attr }
		ret = callBotFunc(__method__, args)
		return Attribute.new(ret["Attribute"], ret["RetVal"])
	end

	def Log(level, message)
		args = { "Level" => level, "Message" => message }
		callBotFunc("Log", args)
		return 0
	end

	def SendChannelMessage(channel, message, format="")
		return SendChannelThreadMessage(channel, "", message, format)
	end

	def SendChannelThreadMessage(channel, thread, message, format="")
		format = format.to_s if format.class == Symbol
		args = { "Channel" => channel, "Thread" => thread, "Message" => message }
		ret = callBotFunc(__method__, args, format)
		return ret["RetVal"]
	end

	def SendUserMessage(user, message, format="")
		format = format.to_s if format.class == Symbol
		args = { "User" => user, "Message" => message }
		ret = callBotFunc(__method__, args, format)
		return ret["RetVal"]
	end

	def SendUserChannelMessage(user, channel, message, format="")
		return SendUserChannelThreadMessage(user, channel, "", message, format)
	end

	def SendUserChannelThreadMessage(user, channel, thread, message, format="")
		format = format.to_s if format.class == Symbol
		args = { "User" => user, "Channel" => channel, "Thread" => thread, "Message" => message }
		ret = callBotFunc(__method__, args, format)
		return ret["RetVal"]
	end

	def Say(message, format="")
		format = format.to_s if format.class == Symbol
		if @channel.empty?
			return SendUserMessage(@user, message, format)
		else
			thread = @threaded_message ? @thread_id : ""
			return SendChannelThreadMessage(@channel, thread, message, format)
		end
	end

	def SayThread(message, format="")
		format = format.to_s if format.class == Symbol
		if @channel.empty?
			return SendUserMessage(@user, message, format)
		else
			return SendChannelThreadMessage(@channel, @thread_id, message, format)
		end
	end

	def Pause(seconds)
		sleep seconds
	end

	def Reply(message, format="")
		format = format.to_s if format.class == Symbol
		if @channel.empty?
			return SendUserMessage(@user, message, format)
		else
			thread = @threaded_message ? @thread_id : ""
			return SendUserChannelThreadMessage(@user, @channel, thread, message, format)
		end
	end

	def ReplyThread(message, format="")
		format = format.to_s if format.class == Symbol
		if @channel.empty?
			return SendUserMessage(@user, message, format)
		else
			return SendUserChannelThreadMessage(@user, @channel, @thread_id, message, format)
		end
	end

	def PromptForReply(regex_id, prompt)
		thread = @threaded_message ? @thread_id : ""
		return PromptUserChannelThreadForReply(regex_id, @user, @channel, thread, prompt)
	end

	def PromptThreadForReply(regex_id, prompt)
		return PromptUserChannelThreadForReply(regex_id, @user, @channel, @thread_id, prompt)
	end

	def PromptUserForReply(regex_id, prompt)
		return PromptUserChannelThreadForReply(regex_id, @user, "", "", prompt)
	end

	def PromptUserChannelThreadForReply(regex_id, user, channel, thread, prompt)
		args = { "RegexID" => regex_id, "User" => user, "Channel" => channel, "Thread" => thread, "Prompt" => prompt }
		for i in 1..3
			ret = callBotFunc(__method__, args)
			next if ret["RetVal"] == RetryPrompt
			return Reply.new(ret["Reply"], ret["RetVal"])
		end
		if ret == RetryPrompt
			return Reply.new(ret["Reply"], Interrupted)
		else
			return Reply.new(ret["Reply"], ret["RetVal"])
		end
	end

	def callBotFunc(funcname, args, format="")
		if format.size == 0
			format = @format
		end
		func = {
			"FuncName" => funcname,
			"Format" => format,
			"CallerID" => @plugin_id,
			"FuncArgs" => args
		}
		uri = URI.parse(ENV["GOPHER_HTTP_POST"] + "/json")
		http = Net::HTTP.new(uri.host, uri.port)
		req = Net::HTTP::Post.new(uri, initheader = {'Content-Type' =>'application/json'})
		req.body = func.to_json
#		STDERR.puts "Sending:\n#{req.body}"
		res = http.request(req)
		body = res.body()
#		STDERR.puts "Got back:\n#{body}"
		return JSON.load(body)
	end
	private :callBotFunc
end

class Robot < BaseBot
	attr_accessor :channel, :channel_id, :message_id, :thread_id, :threaded_message, :user, :user_id, :plugin_id, :protocol, :format
	def initialize()
		@channel = ENV["GOPHER_CHANNEL"]
		@channel_id = ENV["GOPHER_CHANNEL_ID"]
		@message_id = ENV["GOPHER_MESSAGE_ID"]
        @thread_id = ENV["GOPHER_THREAD_ID"]
		@threaded_message = ENV["GOPHER_THREADED_MESSAGE"]
		@user = ENV["GOPHER_USER"]
		@user_id = ENV["GOPHER_USER_ID"]
		@plugin_id = ENV["GOPHER_CALLER_ID"]
		@protocol = ENV["GOPHER_PROTOCOL"]
		@brain = ENV["GOPHER_BRAIN"]
		@format = ""
		@prng = Random.new
	end

	def Direct()
		DirectBot.new
	end

	def Threaded()
		ThreadedBot.new
	end

	def MessageFormat(format)
		FormattedBot.new(format)
	end
end

class DirectBot < Robot
	def initialize()
		super
		@channel = ""
		@thread_id = ""
		@threaded_message = nil
	end
end

class ThreadedBot < Robot
	def initialize()
		super
		if @channel.length > 0
			@threaded_message = "true"
		else
			@threaded_message = nil
		end
	end
end

class FormattedBot < BaseBot
	def initialize(format)
		super
		@format = format
	end
end
</file_content file: gopherbot-main/lib/gopherbot_v1.rb>
<preamble file: gopherbot-main/lib/gopherbot_v1.sh>

</preamble>
<file_content file: gopherbot-main/lib/gopherbot_v1.sh>
#!/bin/bash
# shellLib.sh - bash plugins should source this with 'source $GOPHER_INSTALLDIR/util/shellLib.sh'
# Return values for robot method calls
GBRET_Ok=0
GBRET_UserNotFound=1
GBRET_ChannelNotFound=2
GBRET_AttributeNotFound=3
GBRET_FailedMessageSend=4
GBRET_FailedChannelJoin=5
GBRET_DatumNotFound=6
GBRET_DatumLockExpired=7
GBRET_DataFormatError=8
GBRET_BrainFailed=9
GBRET_InvalidDatumKey=10
GBRET_InvalidDblPtr=11
GBRET_InvalidCfgStruct=12
GBRET_NoConfigFound=13
GBRET_RetryPrompt=14
GBRET_ReplyNotMatched=15
GBRET_UseDefaultValue=16
GBRET_TimeoutExpired=17
GBRET_Interrupted=18
GBRET_MatcherNotFound=19
GBRET_NoUserEmail=20
GBRET_NoBotEmail=21
GBRET_MailError=22
GBRET_TaskNotFound=23
GBRET_MissingArguments=24
GBRET_InvalidStage=25

# Plugin return values / exit codes
PLUGRET_Normal=0
PLUGRET_Fail=1
PLUGRET_MechanismFail=2
PLUGRET_ConfigurationError=3
PLUGRET_NotFound=6
PLUGRET_Success=7

base64_encode(){
	local MESSAGE
	MESSAGE=$(echo -n "$@" | base64)
	echo -n "$MESSAGE"
}

# Create the full JSON string and post it
gbPostJSON(){
	local GB_FUNCNAME=$1
	local GB_FUNCARGS="$2"
	local FORMAT=${3:-$GB_FORMAT}
	local JSON JSONRET
	#local GB_DEBUG="true"
	JSON=$(cat <<EOF
{
	"FuncName": "$GB_FUNCNAME",
	"Format": "$FORMAT",
	"CallerID": "$GOPHER_CALLER_ID",
	"FuncArgs": $GB_FUNCARGS
}
EOF
)
	if [ "$GB_DEBUG" = "true" ]
	then
		echo "Sending:" >&2
		echo "$JSON" >&2
	fi
	JSONRET=$(echo "$JSON" | curl -f -X POST -d @- $GOPHER_HTTP_POST/json 2>/dev/null)
	if [ "$GB_DEBUG" = "true" ]
	then
		echo "Got back:" >&2
		echo "$JSONRET" >&2
	fi
	echo "$JSONRET"
}

gbBotRet() {
	local JSON="$1"
	local RETVAL
	RETVAL=$(echo "$JSON" | jq .RetVal)
	return $RETVAL
}

gbExtract() {
	local JSON="$1"
	local ITEM="$2"
	echo "$JSON" | jq -r .$ITEM
}

CheckAdmin(){
	local GB_FUNCARGS="{}"
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	echo "$RETVAL"
	if [ "$RETVAL" -eq "true" ]
	then
		return 0
	else
		return 1
	fi
}

Subscribe(){
	local GB_FUNCARGS="{}"
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	echo "$RETVAL"
	if [ "$RETVAL" -eq "true" ]
	then
		return 0
	else
		return 1
	fi
}

Unsubscribe(){
	local GB_FUNCARGS="{}"
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	echo "$RETVAL"
	if [ "$RETVAL" -eq "true" ]
	then
		return 0
	else
		return 1
	fi
}

Remember(){
	if [ -z "$1" -o -z "$2" ]
	then
		return 1
	fi
	if [ "$3" ]
	then
		SHARED=', "Shared": true'
	fi
	local GB_FUNCNAME="Remember"
	if [ "$GOPHER_THREADED_MESSAGE" ]
	then
		GB_FUNCNAME="RememberThread"
	fi
	local R_KEY=$(base64_encode "$1")
	local R_MEMORY=$(base64_encode "$2")
	local GB_FUNCARGS=$(cat <<EOF
{
	"Key": "$R_KEY",
	"Value": "$R_MEMORY",
	"Base64": true$SHARED
}
EOF
)
	gbPostJSON $GB_FUNCNAME "$GB_FUNCARGS"
	return 0
}

RememberContext(){
	if [ -z "$1" -o -z "$2" ]
	then
		return 1
	fi
	Remember "context:$1" "$2"
	return 0
}

RememberThread(){
	if [ -z "$1" -o -z "$2" ]
	then
		return 1
	fi
	if [ "$3" ]
	then
		SHARED=', "Shared": true'
	fi
	local R_KEY=$(base64_encode "$1")
	local R_MEMORY=$(base64_encode "$2")
	local GB_FUNCARGS=$(cat <<EOF
{
	"Key": "$R_KEY",
	"Value": "$R_MEMORY",
	"Base64": true$SHARED
}
EOF
)
	gbPostJSON $FUNCNAME "$GB_FUNCARGS"
	return 0
}

RememberContextThread(){
	if [ -z "$1" -o -z "$2" ]
	then
		return 1
	fi
	RememberThread "context:$1" "$2"
	return 0
}

Pause(){
	sleep $1
}

Recall(){
	if [ -z "$1" ]
	then
		return 1
	fi
	if [ "$3" ]
	then
		SHARED=', "Shared": true'
	fi
	local R_KEY=$(base64_encode "$1")
	local GB_FUNCARGS=$(cat <<EOF
{
	"Key": "$R_KEY",
	"Base64": true$SHARED
}
EOF
)
	local GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	local RETVAL=$(echo "$GB_RET" | jq -r .StrVal)
	echo -n "$RETVAL"
}

SetParameter() {
	local NAME=$(base64_encode "$1")
	local VALUE=$(base64_encode "$2")
	local GB_FUNCARGS=$(cat <<EOF
{
	"Name": "$NAME",
	"Value": "$VALUE",
	"Base64": true
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS" $FORMAT)
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	if [ "$RETVAL" = "true" ]
	then
		return 0
	else
		return 1
	fi
}

ExtendNamespace() {
	local NS="$1"
	local HIST="$2"
	local GB_FUNCARGS=$(cat <<EOF
{
	"Extend": "$NS",
	"Histories": $2
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS" $FORMAT)
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	if [ "$RETVAL" = "true" ]
	then
		return 0
	else
		return 1
	fi
}

SetWorkingDirectory() {
	local WDPATH="$1"
	local GB_FUNCARGS=$(cat <<EOF
{
	"Path": "$WDPATH"
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS" $FORMAT)
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	if [ "$RETVAL" = "true" ]
	then
		return 0
	else
		return 1
	fi
}

_pipeTask(){
	local JSTR
	local FNAME="$1"
	local TNAME="$2"
	shift 2
	for ARG in "$@"
	do
		JSTR="$JSTR \"$ARG\""
	done
	if [ -n "$JSTR" ]
	then
		JSTR=$(echo ${JSTR//\" \"/\", \"})
	fi
	local GB_FUNCARGS=$(cat <<EOF
{
	"Name": "$TNAME",
	"CmdArgs": [ $JSTR ]
}
EOF
)
	GB_RET=$(gbPostJSON $FNAME "$GB_FUNCARGS" $FORMAT)
	gbBotRet "$GB_RET"
}

AddJob(){
	_pipeTask $FUNCNAME "$@"
}

AddTask(){
	_pipeTask $FUNCNAME "$@"
}

FinalTask(){
	_pipeTask $FUNCNAME "$@"
}

FailTask(){
	_pipeTask $FUNCNAME "$@"
}

SpawnJob(){
	_pipeTask $FUNCNAME "$@"
}

_cmdTask(){
	local JSTR
	local FNAME="$1"
	local TNAME="$2"
	local PCMD="$3"
	local GB_FUNCARGS=$(cat <<EOF
{
	"Plugin": "$TNAME",
	"Command": "$PCMD"
}
EOF
)
	GB_RET=$(gbPostJSON $FNAME "$GB_FUNCARGS" $FORMAT)
	gbBotRet "$GB_RET"
}

AddCommand(){
	_cmdTask $FUNCNAME "$@"
}

FailCommand(){
	_cmdTask $FUNCNAME "$@"
}

FinalCommand(){
	_cmdTask $FUNCNAME "$@"
}

Exclusive(){
	local QUEUE_TASK="false"
	local TAG="$1"
	if [ -n "$2" ]
	then
		QUEUE_TASK=$2
	fi
	local GB_FUNCARGS=$(cat <<EOF
{
	"Tag": "$TAG",
	"QueueTask": $QUEUE_TASK
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	if [ "$RETVAL" = "true" ]
	then
		return 0
	else
		return 1
	fi
}

Elevate(){
	IMMEDIATE="false"
	if [ -n "$1" ]
	then
		IMMEDIATE="$1"
	fi
	local GB_FUNCARGS=$(cat <<EOF
{
	"Immediate": "$IMMEDIATE"
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	local RETVAL=$(echo "$GB_RET" | jq .Boolean)
	if [ "$RETVAL" = "true" ]
	then
		return 0
	else
		return 1
	fi
}

GetBotAttribute(){
	local GB_FUNCARGS GB_RET
	local ATTR="$1"
	GB_FUNCARGS=$(cat <<EOF
{
	"Attribute": "$ATTR"
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	gbExtract "$GB_RET" Attribute
	gbBotRet "$GB_RET"
}

GetSenderAttribute(){
	local GB_FUNCARGS
	local ATTR="$1"
	GB_FUNCARGS=$(cat <<EOF
{
	"Attribute": "$ATTR"
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	gbExtract "$GB_RET" Attribute
	gbBotRet "$GB_RET"
}

GetUserAttribute(){
	local GB_FUNCARGS GB_RET
	local GUA_USER="$1"
	local ATTR="$2"
	GB_FUNCARGS=$(cat <<EOF
{
	"User": "$GUA_USER",
	"Attribute": "$ATTR"
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	gbExtract "$GB_RET" Attribute
	gbBotRet "$GB_RET"
}

Log(){
	local GB_FUNCARGS GB_RET
	local GLM_LEVEL="$1"
	local GLM_MESSAGE=$(base64_encode "$2")
	GB_FUNCARGS=$(cat <<EOF
{
	"Level": "$GLM_LEVEL",
	"Message": "$GLM_MESSAGE",
	"Base64" : true
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS")
	gbBotRet "$GB_RET"
}

PromptUserChannelForReply(){
	PromptUserChannelThreadForReply "$1" "$2" "$3" "" "$4"
}

PromptUserChannelThreadForReply(){
	local FORMAT
	if [[ $1 = -? ]]; then FORMAT=$(getFormat $1); shift; fi
	local GB_FUNCARGS GB_RET
	local REGEX="$1"
	local PUSER="$2"
	local PCHANNEL="$3"
	local PTHREAD="$4"
	local PROMPT=$(base64_encode "$5")
	GB_FUNCARGS=$(cat <<EOF
{
	"RegexID": "$REGEX",
	"User": "$PUSER",
	"Channel": "$PCHANNEL",
	"Prompt": "$PROMPT",
	"Base64" : true
}
EOF
)
	local RETVAL
	for TRY in 0 1 2
	do
		GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS" $FORMAT)
		gbBotRet "$GB_RET"
		RETVAL=$?
		if [ $RETVAL -eq $GBRET_RetryPrompt ]
		then
			continue
		fi
		gbExtract "$GB_RET" Reply
		return $RETVAL
	done
	gbBotRet "$GB_RET"
	RETVAL=$?
	if [ $RETVAL -eq $GBRET_RetryPrompt ]
	then
		return $GBRET_Interrupted
	else
		return $RETVAL
	fi
}

PromptForReply(){
	local FORMAT
	if [[ $1 = -? ]]; then FORMAT=$1; shift; fi
	local REGEX=$1
	local THREAD=""
	[ "$GOPHER_THREADED_MESSAGE" ] && THREAD="$GOPHER_THREAD_ID"
	shift
	PromptUserChannelThreadForReply $FORMAT "$REGEX" "$GOPHER_USER" "$GOPHER_CHANNEL" "$THREAD" "$*"
}

PromptThreadForReply(){
	local FORMAT
	if [[ $1 = -? ]]; then FORMAT=$1; shift; fi
	local REGEX=$1
	shift
	PromptUserChannelThreadForReply $FORMAT "$REGEX" "$GOPHER_USER" "$GOPHER_CHANNEL" "$GOPHER_THREAD_ID" "$*"
}

PromptUserForReply(){
	local FORMAT
	if [[ $1 = -? ]]; then FORMAT=$1; shift; fi
	local REGEX=$1
	local PUSER=$2
	shift 2
	PromptUserChannelThreadForReply "$REGEX" "$PUSER" "" "" "$*"
}

MessageFormat(){
	if [ -n "$1" ]
	then
		export GB_FORMAT="$1"
	fi
}

getFormat(){
	case "$1" in
	"-f")
		echo "Fixed"
		;;
	"-r")
		echo "Raw"
		;;
	"-v")
		echo "Variable"
		;;
	esac
}

SendUserMessage(){
	local FORMAT
	if [[ $1 = -? ]]; then FORMAT=$(getFormat $1); shift; fi
	local GB_FUNCARGS GB_RET
	local SUM_USER=$1
	shift
	local MESSAGE="$*"
	MESSAGE=$(base64_encode "$MESSAGE")

	GB_FUNCARGS=$(cat <<EOF
{
	"User": "$SUM_USER",
	"Message": "$MESSAGE",
	"Base64" : true
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS" $FORMAT)
	gbBotRet "$GB_RET"
}

SendUserChannelMessage(){
	local SEND_USER="$1"
	local SEND_CHANNEL="$2"
	shift 2
	SendUserChannelThreadMessage "$SEND_USER" "$SEND_CHANNEL" "" "$@"
}

SendUserChannelThreadMessage(){
	local FORMAT
	if [[ $1 = -? ]]; then FORMAT=$(getFormat $1); shift; fi
	local GB_FUNCARGS GB_RET
	local SUCTM_USER=$1
	local SUCTM_CHANNEL=$2
	local SUCTM_THREAD="$3"
	shift 3
	local MESSAGE="$*"
	MESSAGE=$(base64_encode "$MESSAGE")

	GB_FUNCARGS=$(cat <<EOF
{
	"User": "$SUCTM_USER",
	"Channel": "$SUCTM_CHANNEL",
	"Thread": "$SUCTM_THREAD",
	"Message": "$MESSAGE",
	"Base64" : true
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS" $FORMAT)
	gbBotRet "$GB_RET"
}

SendChannelMessage(){
	local SEND_CHANNEL="$1"
	shift
	SendChannelThreadMessage "$SEND_CHANNEL" "" "$@"
}

SendChannelThreadMessage(){
	local FORMAT
	if [[ $1 = -? ]]; then FORMAT=$(getFormat $1); shift; fi
	local GB_FUNCARGS GB_RET
	local SCTM_CHANNEL=$1
	local SCTM_THREAD="$2"
	shift 2
	local MESSAGE="$*"
	MESSAGE=$(base64_encode "$MESSAGE")

	GB_FUNCARGS=$(cat <<EOF
{
	"Channel": "$SCTM_CHANNEL",
	"Thread": "$SCTM_THREAD",
	"Message": "$MESSAGE",
	"Base64" : true
}
EOF
)
	GB_RET=$(gbPostJSON $FUNCNAME "$GB_FUNCARGS" $FORMAT)
	gbBotRet "$GB_RET"
}

# Convenience functions so that copies of this logic don't wind up in a bunch of plugins
Say(){
	local FARG
	[[ $1 == -? ]] && { FARG=$1; shift; }
	if [ -n "$GOPHER_CHANNEL" ]
	then
		local THREAD=""
		[ "$GOPHER_THREADED_MESSAGE" ] && THREAD="$GOPHER_THREAD_ID"
		SendChannelThreadMessage $FARG "$GOPHER_CHANNEL" "$THREAD" "$*"
	else
		SendUserMessage $FARG "$GOPHER_USER" "$*"
	fi
}

Reply(){
	local FARG
	[[ $1 == -? ]] && { FARG=$1; shift; }
	if [ -n "$GOPHER_CHANNEL" ]
	then
		local THREAD=""
		[ "$GOPHER_THREADED_MESSAGE" ] && THREAD="$GOPHER_THREAD_ID"
		SendUserChannelThreadMessage $FARG "$GOPHER_USER" "$GOPHER_CHANNEL" "$THREAD" "$*"
	else
		SendUserMessage $FARG "$GOPHER_USER" "$*"
	fi
}

SayThread(){
	local FARG
	[[ $1 == -? ]] && { FARG=$1; shift; }
	if [ -n "$GOPHER_CHANNEL" ]
	then
		SendChannelThreadMessage $FARG "$GOPHER_CHANNEL" "$GOPHER_THREAD_ID" "$*"
	else
		SendUserMessage $FARG "$GOPHER_USER" "$*"
	fi
}

ReplyThread(){
	local FARG
	[[ $1 == -? ]] && { FARG=$1; shift; }
	if [ -n "$GOPHER_CHANNEL" ]
	then
		SendUserChannelThreadMessage $FARG "$GOPHER_USER" "$GOPHER_CHANNEL" "$GOPHER_THREAD_ID" "$*"
	else
		SendUserMessage $FARG "$GOPHER_USER" "$*"
	fi
}
</file_content file: gopherbot-main/lib/gopherbot_v1.sh>
<preamble file: gopherbot-main/lib/gopherbot_v2.py>

</preamble>
<file_content file: gopherbot-main/lib/gopherbot_v2.py>
import os
import json
import random
import sys
import time
import urllib.request

# python 3 version

class Attribute:
    "A Gopherbot Attribute return object"
    def __init__(self, ret):
        self.attr = ret["Attribute"]
        self.ret = ret["RetVal"]

    def __str__(self):
        return self.attr

class Reply:
    "A Gopherbot Reply return object"
    def __init__(self, ret):
        self.reply = ret["Reply"]
        self.ret = ret["RetVal"]

    def __str__(self):
        return self.reply

class Memory:
    "A Gopherbot long-term memory object"
    def __init__(self, key, ret):
        self.key = key
        self.lock_token = ret["LockToken"]
        self.exists = ret["Exists"]
        self.datum = ret["Datum"]
        self.ret = ret["RetVal"]

class Robot:
    "Instantiate a robot object for use with Gopherbot"

    # Return values for robot method calls
    Ok = 0
    UserNotFound = 1
    ChannelNotFound = 2
    AttributeNotFound = 3
    FailedMessageSend = 4
    FailedChannelJoin = 5
    DatumNotFound = 6
    DatumLockExpired = 7
    DataFormatError = 8
    BrainFailed = 9
    InvalidDatumKey = 10
    InvalidDblPtr = 11
    InvalidCfgStruct = 12
    NoConfigFound = 13
    RetryPrompt = 14
    ReplyNotMatched = 15
    UseDefaultValue = 16
    TimeoutExpired = 17
    Interrupted = 18
    MatcherNotFound = 19
    NoUserEmail = 20
    NoBotEmail = 21
    MailError = 22
    TaskNotFound = 23
    MissingArguments = 24
    InvalidStage = 25

    # Plugin return values / exit codes
    Normal = 0
    Fail = 1
    MechanismFail = 2
    ConfigurationError = 3
    NotFound = 6
    Success = 7

    def __init__(self):
        random.seed()
        self.channel = os.getenv("GOPHER_CHANNEL")
        self.thread_id = os.getenv("GOPHER_THREAD_ID")
        self.threaded_message = os.getenv("GOPHER_THREADED_MESSAGE")
        self.user = os.getenv("GOPHER_USER")
        self.plugin_id = os.getenv("GOPHER_CALLER_ID")
        self.format = ""
        self.protocol = os.getenv("GOPHER_PROTOCOL")

    def Call(self, func_name, func_args, format=""):
        if len(format) == 0:
            format = self.format
        func_call = { "FuncName": func_name, "Format": format,
                    "CallerID": self.plugin_id,
                    "FuncArgs": func_args }
        data = json.dumps(func_call)
        data = bytes(data, 'utf-8')
        req = urllib.request.Request(url="%s/json" % os.getenv("GOPHER_HTTP_POST"),
            data=data)
        req.add_header('Content-Type', 'application/json')
        # sys.stderr.write("Sending: %s\n" % func_json)
        res = urllib.request.urlopen(req)
        body = res.read()
        # sys.stderr.write("Got back: %s\n" % body)
        return json.loads(body.decode("utf-8"))

    def CheckAdmin(self):
        return self.Call(sys._getframe().f_code.co_name, {})["Boolean"]

    def Subscribe(self):
        return self.Call(sys._getframe().f_code.co_name, {})["Boolean"]

    def Unsubscribe(self):
        return self.Call(sys._getframe().f_code.co_name, {})["Boolean"]

    def Elevate(self, immediate=False):
        return self.Call(sys._getframe().f_code.co_name, { "Immediate": immediate })["Boolean"]

    def Pause(self, s):
        time.sleep(s)

    def RandomString(self, sa):
        return sa[random.randint(0, (len(sa)-1))]

    def GetTaskConfig(self):
        return self.Call(sys._getframe().f_code.co_name, {})

    def CheckoutDatum(self, key, rw):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": key, "RW": rw })
        return Memory(key, ret)

    def SpawnJob(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def AddJob(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def AddTask(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def FinalTask(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def FailTask(self, name, args):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "CmdArgs": args })["RetVal"]

    def AddCommand(self, plugin, cmd):
        return self.Call(sys._getframe().f_code.co_name, { "Plugin": plugin, "Command": cmd })["RetVal"]

    def FinalCommand(self, plugin, cmd):
        return self.Call(sys._getframe().f_code.co_name, { "Plugin": plugin, "Command": cmd })["RetVal"]

    def FailCommand(self, plugin, cmd):
        return self.Call(sys._getframe().f_code.co_name, { "Plugin": plugin, "Command": cmd })["RetVal"]

    def SetParameter(self, name, value):
        return self.Call(sys._getframe().f_code.co_name, { "Name": name, "Value": value })["Boolean"]

    def Exclusive(self, tag, queue_task=False):
        return self.Call(sys._getframe().f_code.co_name, { "Tag": tag, "QueueTask": queue_task })["Boolean"]

    def ExtendNamespace(self, ns, hist):
        return self.Call(sys._getframe().f_code.co_name, { "Extend": ns, "Histories": hist })["Boolean"]

    def SetWorkingDirectory(self, path):
        return self.Call(sys._getframe().f_code.co_name, { "Path": path })["Boolean"]

    def GetRepoData(self):
        return self.Call(sys._getframe().f_code.co_name, {})

    def Log(self, level, msg):
        self.Call(sys._getframe().f_code.co_name, { "Level": level, "Message": msg })

    def CheckinDatum(self, m):
        self.Call(sys._getframe().f_code.co_name, { "Key": m.key, "Token": m.lock_token })

    def UpdateDatum(self, m):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": m.key, "Token": m.lock_token,
        "Datum": m.datum })
        return ret["RetVal"]

    def GetSenderAttribute(self, attr):
        ret = self.Call(sys._getframe().f_code.co_name, { "Attribute": attr })
        return Attribute(ret)

    def GetUserAttribute(self, user, attr):
        ret = self.Call(sys._getframe().f_code.co_name, { "User": user, "Attribute": attr })
        return Attribute(ret)

    def GetBotAttribute(self, attr):
        ret = self.Call(sys._getframe().f_code.co_name, { "Attribute": attr })
        return Attribute(ret)

    def Remember(k, v, shared=False):
        funcname = "RememberThread" if self.threaded_message else "Remember"
        ret = self.Call(funcname, { "Key": k, "Value": v, "Shared": shared })
        return ret["RetVal"]

    def RememberContext(k, v):
        return self.Remember("context:"+k, v, False)

    def RememberThread(k, v, shared=False):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": k, "Value": v, "Shared": shared })
        return ret["RetVal"]

    def RememberContextThread(k, v):
        return self.RememberThread("context:"+k, v, False)

    def Recall(self, memory, shared=False):
        ret = self.Call(sys._getframe().f_code.co_name, { "Key": memory, "Shared": shared })
        return ret["StrVal"]

    def PromptForReply(self, regex_id, prompt, format=""):
        thread = ""
        if self.threaded_message:
            thread = self.thread_id
        return self.PromptUserChannelThreadForReply(regex_id, self.user, self.channel, thread, prompt, format)

    def PromptThreadForReply(self, regex_id, prompt, format=""):
        return self.PromptUserChannelThreadForReply(regex_id, self.user, self.channel, self.thread_id, prompt, format)

    def PromptUserForReply(self, regex_id, user, prompt, format=""):
        return self.PromptUserChannelThreadForReply(regex_id, user, "", prompt, format)

    def PromptUserChannelThreadForReply(self, regex_id, user, channel, thread, prompt, format=""):
        for i in range(0, 3):
            rep = self.Call(sys._getframe().f_code.co_name, { "RegexID": regex_id, "User": user, "Channel": channel, "Thread": thread, "Prompt": prompt }, format)
            if rep["RetVal"] == self.RetryPrompt:
                continue
            return Reply(rep)
        if rep["RetVal"] == self.RetryPrompt:
            rep["RetVal"] = self.Interrupted
        return Reply(rep)

    def SendChannelMessage(self, channel, message, format=""):
        return self.SendChannelThreadMessage(channel, "", message, format)

    def SendChannelThreadMessage(self, channel, thread, message, format=""):
        ret = self.Call(sys._getframe().f_code.co_name, { "Channel": channel, "Thread": thread,
        "Message": message }, format)
        return ret["RetVal"]

    def SendUserMessage(self, user, message, format=""):
        ret = self.Call(sys._getframe().f_code.co_name, { "User": user,
        "Message": message }, format)
        return ret["RetVal"]

    def SendUserChannelMessage(self, user, channel, message, format=""):
        return self.SendUserChannelThreadMessage(user, channel, "", message, format)

    def SendUserChannelThreadMessage(self, user, channel, thread, message, format=""):
        ret = self.Call(sys._getframe().f_code.co_name, { "User": user,
        "Channel": channel, "Thread": thread, "Message": message }, format)
        return ret["RetVal"]

    def Say(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            thread = ""
            if self.threaded_message:
                thread = self.thread_id
            return self.SendChannelThreadMessage(self.channel, thread, message, format)

    def SayThread(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            return self.SendChannelThreadMessage(self.channel, self.thread_id, message, format)

    def Reply(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            thread = ""
            if self.threaded_message:
                thread = self.thread_id
            return self.SendUserChannelThreadMessage(self.user, self.channel, thread, message, format)

    def ReplyThread(self, message, format=""):
        if self.channel == '':
            return self.SendUserMessage(self.user, message, format)
        else:
            return self.SendUserChannelThreadMessage(self.user, self.channel, self.thread_id, message, format)

    def Direct(self):
        "Get a direct messaging instance of the robot"
        return DirectBot(self)

    def MessageFormat(self, format):
        "Get a bot with a non-default message format"
        return FormattedBot(self, format)

    def Threaded(self):
        "Get a bot associated with the message thread"
        return ThreadedBot(self)

class DirectBot(Robot):
    "Instantiate a robot for direct messaging with the user"
    def __init__(self, bot):
        self.channel = ""
        self.thread_id = ""
        self.threaded_message = None
        self.user = bot.user
        self.protocol = bot.protocol
        self.format = bot.format
        self.plugin_id = bot.plugin_id

class FormattedBot(Robot):
    "Instantiate a robot with a non-default message format"
    def __init__(self, bot, format):
        self.channel = bot.channel
        self.thread_id = bot.thread_id
        self.threaded_message = bot.threaded_message
        self.user = bot.user
        self.protocol = bot.protocol
        self.format = format
        self.plugin_id = bot.plugin_id

class ThreadedBot(Robot):
    "Instantiate a robot with a non-default message format"
    def __init__(self, bot):
        self.channel = bot.channel
        self.thread_id = bot.thread_id
        if len(self.channel) > 0:
            self.threaded_message = "true"
        else:
            self.threaded_message = None
        self.user = bot.user
        self.protocol = bot.protocol
        self.format = bot.format
        self.plugin_id = bot.plugin_id
</file_content file: gopherbot-main/lib/gopherbot_v2.py>
<preamble file: gopherbot-main/licenses/Go-LICENSE>

</preamble>
<file_content file: gopherbot-main/licenses/Go-LICENSE>
License applicable to example code copied from Go, including Windows
service related code and possibly more.

Copyright (c) 2009 The Go Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</file_content file: gopherbot-main/licenses/Go-LICENSE>
<preamble file: gopherbot-main/licenses/README.txt>

</preamble>
<file_content file: gopherbot-main/licenses/README.txt>
If you are an author whose code is incorporated in Gopherbot, and this
directory lacks an appropriate *-LICENSE file, please open a PR or
issue for Gopherbot.
</file_content file: gopherbot-main/licenses/README.txt>
<preamble file: gopherbot-main/licenses/aescrypt.txt>

</preamble>
<file_content file: gopherbot-main/licenses/aescrypt.txt>
Code in bot/aescrypt.go:

Copyright (c) 2012, AstaXie and The Contributors All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

- Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

- Neither the name of the AstaXie nor the names of its contributors may be used
  to endorse or promote products derived from this software without specific
  prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</file_content file: gopherbot-main/licenses/aescrypt.txt>
<preamble file: gopherbot-main/main.go>

</preamble>
<file_content file: gopherbot-main/main.go>
package main

import "github.com/lnxjedi/gopherbot/v2/bot"

// Version supplied during linking
var Version = "(no version set)"

// Commit supplied during linking
var Commit = "(not set)"

func main() {
	versionInfo := bot.VersionInfo{
		Version: Version,
		Commit:  Commit,
	}
	bot.Start(versionInfo)
}
</file_content file: gopherbot-main/main.go>
<preamble file: gopherbot-main/main_static.go>

</preamble>
<file_content file: gopherbot-main/main_static.go>
//go:build test
// +build test

package main

import (
	// Profiling
	// _ "net/http/pprof"

	// *** Included Authorizer plugins
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/groups"

	// *** Included Go plugins, of varying quality
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/duo"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/help"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/knock"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/links"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/lists"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/meme"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/ping"

	// *** Default Slack connector
	_ "github.com/lnxjedi/gopherbot/v2/connectors/slack"

	// *** Default file history
	_ "github.com/lnxjedi/gopherbot/v2/history/file"

	// *** A fantastic brain
	_ "github.com/lnxjedi/gopherbot/v2/brains/dynamodb"
)

/* Uncomment under Profiling above to enable profiling. This inflates
the binary when enabled, but if the robot ever stops responding for any
reason, it's handy for getting a dump of all goroutines. Example usage:

$ go tool pprof http://localhost:8888/debug/pprof/goroutine
...
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) list lnxjedi
Total: 11
ROUTINE ======================== github.com/lnxjedi/gopherbot/v2/bot...
*/
</file_content file: gopherbot-main/main_static.go>
<preamble file: gopherbot-main/mkdist.sh>

</preamble>
<file_content file: gopherbot-main/mkdist.sh>
#!/bin/bash -e
# mkdist.sh - create a distributable gopherbot-*.tar.gz file

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}"
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

usage(){
	cat <<EOF
Usage: mkdist.sh

Generate distributable tar.gz file for Linux
EOF
	exit 0
}

if [ "$1" = "-h" -o "$1" = "--help" ]
then
	usage
fi

eval `go env`

CONTENTS="conf/ jobs/ lib/ licenses/ plugins/ resources/ robot.skel/ helpers/ \
	tasks/ AUTHORS.txt changelog.txt LICENSE README.md setuid-nobody.sh gb-*"

ADIR="build-archive"

BUILDOS="linux"

rm -rf "$ADIR/gopherbot"
mkdir -p "$ADIR/gopherbot"
cp -a gopherbot "$ADIR/gopherbot/gopherbot"
cp -a --parents $CONTENTS "$ADIR/gopherbot"
chmod -R a+rX $ADIR

cd $ADIR
echo "Creating gopherbot-$BUILDOS-$GOARCH.tar.gz (from $(pwd))"
tar --owner=0 --group=0 --exclude *.swp --exclude *.pyc --exclude __pycache__ -czf ../gopherbot-$BUILDOS-$GOARCH.tar.gz gopherbot/
cd -

rm -rf "$ADIR"
</file_content file: gopherbot-main/mkdist.sh>
<preamble file: gopherbot-main/plugins/README.txt>

</preamble>
<file_content file: gopherbot-main/plugins/README.txt>
This directory has a few useful example script plugins. To activate a plugin
in this directory, it must be listed in the robot's "ExternalScripts"
configuration item, and in some cases require extra configuration in
conf/plugins/<foo>.yaml

The 'samples' directory are mostly used by the testing framework, but are also
useful for code examples.
</file_content file: gopherbot-main/plugins/README.txt>
<preamble file: gopherbot-main/plugins/addadmin.sh>

</preamble>
<file_content file: gopherbot-main/plugins/addadmin.sh>
#!/bin/bash

# addadmin.sh - plugin for adding an administrator to a new robot

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat <<"EOF"
---
AllChannels: true
AllowDirect: true
Help:
- Keywords: [ "administrator", "add" ]
  Helptext: [ "(bot), add admin <key> - add the user as a robot administrator" ]
CommandMatchers:
- Command: "add"
  Regex: '(?i:add ?admin(?:istrator)? ([^\s]+))'
EOF
}

if [ "$command" == "configure" ]
then
    configure
    exit 0
fi

if [ "$command" != "add" ]
then
    exit 0
fi

checkReply(){
    if [ $1 -ne 0 ]
    then
        Say "Cancelling setup"
        exit 0
    fi
    Say "Thanks"
    Pause 1
}

getMatching(){
    local REGEX=$1
    local PROMPT=$2
    for TRY in "" "" "LAST"
    do
        REPLY=$(PromptForReply "$REGEX" "$PROMPT")
        RETVAL=$?
        [ $RETVAL -eq 0 ] && { echo "$REPLY"; return 0; }
        if [ -n "$TRY" ]
        then
            return $RETVAL
        fi
        case $RETVAL in
        $GBRET_ReplyNotMatched)
            Say "Try again? Your answer doesn't match the pattern for $REGEX"
            ;;
        $GBRET_TimeoutExpired)
            Say "Try again? Timeout expired waiting for your reply"
            ;;
        *)
            return $RETVAL
        esac
    done
}

substitute(){
    local FIND=$1
    local REPLACE=$2
    local FILE=${3:-conf/robot.yaml}
    REPLACE=${REPLACE//\\/\\\\}
    for TRY in "#" "|" "%" "^"
    do
        if [[ ! $REPLACE = *$TRY* ]]
        then
            RC="$TRY"
            break
        fi
    done
    sed -i -e "s${RC}$FIND${RC}$REPLACE${RC}g" "$GOPHER_CONFIGDIR/$FILE"
}

KEY=$1

if [ "$KEY" != "$GOPHER_SETUP_TOKEN" ]
then
    Say "Invalid shared secret; check your GOPHER_SETUP_TOKEN and try again."
    exit 0
fi
if [ ! -e ".addadmin" ]
then
    Say "Setup token already used!!"
    exit 1
fi
rm -f ".addadmin"
sed -i ".env" -e '/^GOPHER_SETUP_TOKEN=/d'
USERID=$(GetSenderAttribute "id")
USERID=${USERID#<}
USERID=${USERID%>}
BOTID=$(GetBotAttribute "id")
BOTID=${BOTID#<}
BOTID=${BOTID%>}
BOTNAME=$(GetBotAttribute "name")
USERNAME=$(getMatching "SimpleString" \
    "What username do you want the robot to know you by?")
checkReply $?
Say "Detected User ID $USERID for $USERNAME, and ID $BOTID for $BOTNAME"
substitute "<adminusername>" "$USERNAME" "conf/slack.yaml"
substitute "<adminuserid>" "$USERID" "conf/slack.yaml"
substitute "<botid>" "$BOTID" "conf/slack.yaml"

AddTask say "You've been successfully added as an administrator. \
If you've configured 'manage_key.pub' as a read-write deploy key \
for my repository, you can use the 'save' command to upload my \
configuration. Have fun."
AddTask "restart-robot"
</file_content file: gopherbot-main/plugins/addadmin.sh>
<preamble file: gopherbot-main/plugins/admin.sh>

</preamble>
<file_content file: gopherbot-main/plugins/admin.sh>
#!/bin/bash -e

# admin.sh - a bash plugin that triggers management jobs like save, update, etc.

COMMAND=$1
shift

[ "$COMMAND" = "configure" ] && exit 0

trap_handler()
{
  ERRLINE="$1"
  ERRVAL="$2"
  echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
  # The script should usually exit on error
  exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

FailTask tail-log

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH"
        exit 1
    fi
done

case "$COMMAND" in
  "update")
    Say "Ok, I'll trigger the 'updatecfg' job to issue a git pull and reload configuration..."
    AddJob updatecfg
    FailTask say "Job failed!"
    AddTask say "... done"
    ;;
  "branch")
    BRANCH="$1"
    AddJob changebranch "$BRANCH"
    FailTask say "Error switching branches - does '$BRANCH' exist?"
    AddTask say "... switched to branch '$BRANCH'"
    ;;
  "save")
    Say "Ok, I'll push my configuration and long-term memory store ..."
    AddJob save
    AddJob backup
    FailTask say "Job failed!"
    AddTask say "... done"
    ;;
  "theia")
    if [ ! -e "/usr/local/theia/src-gen/backend/main.js" ]
    then
      Say "Theia installation not found. Wrong container?"
      exit 0
    fi
    Say "Ok, I'll start the Theia Gopherbot IDE..."
    AddJob theia
    FailTask say "Starting theia failed! (are you using the gopherbot-theia image?)"
    AddTask say "... Theia finished"
    ;;
  "backup")
    Say "Ok, I'll start the backup job to push my state..."
    AddJob backup
    FailTask say "Job failed!"
    AddTask say "... done"
    ;;
  "restore")
    Say "Ok, I'll start a restore of my state from the remote repository..."
    AddJob restore "$1"
    FailTask say "Job failed!"
    AddTask say "... done"
    ;;
esac
</file_content file: gopherbot-main/plugins/admin.sh>
<preamble file: gopherbot-main/plugins/autosetup.sh>

</preamble>
<file_content file: gopherbot-main/plugins/autosetup.sh>
#!/bin/bash -e

# setup.sh - plugin for setting up a new robot

command=$1
shift

if [ "$command" == "configure" ]
then
cat << "EOF"
Help:
- Keywords: [ "setup" ]
  Helptext: [ "(bot), setup <protocol> - display the answerfile for the given protocol" ]
CommandMatchers:
- Command: 'setup'
  Regex: '(?i:setup (\w+))'
MessageMatchers:
- Command: "setup"
  Regex: '(?i:^setup (\w+)$)'
EOF
    exit 0
fi

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
    # The script should usually exit on error
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH" >&2
        exit 1
    fi
done

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh
# END Boilerplate

if [ "$command" == "setup" ]
then
    PROTOCOL=$1
    ANSFILE="$GOPHER_INSTALLDIR/resources/answerfiles/$PROTOCOL.txt"
    if [ ! -e "$ANSFILE" ]
    then
        Say "Protocol answerfile template not found: $ANSFILE"
        exit 0
    fi
    if [ ! "$GOPHER_CONTAINER" ]
    then
        if [ -e "answerfile.txt" ]
        then
            Say "Not over-writing existing 'answerfile.txt'"
            exit 0
        fi
        cp "$ANSFILE" "answerfile.txt"
        if [ ! -e "gopherbot" ]
        then
            ln -s "$GOPHER_INSTALLDIR/gopherbot" .
        fi
        Say "Edit 'answerfile.txt' and re-run gopherbot with no arguments to generate your robot."
        FinalTask robot-quit
        exit 0
    fi
    # Running in a container
    ANSTXT="$(cat $ANSFILE)"
    Say -f "$(cat <<EOF
Copy to answerfile.txt:
<-- snip answerfile.txt -->
$ANSTXT
<-- /snip -->

Edit your 'answerfile.txt' and run the container with '--env-file answerfile.txt'.
EOF
)"
    FinalTask robot-quit
    exit 0
fi

if [ "$command" != "init" ]
then
    exit 0
fi

if [ -e "answerfile.txt" ]
then
    source "answerfile.txt"
elif [ ! "$ANS_PROTOCOL" ]
then
    exit 0
fi

# checkExit VAR [regex] [g]
checkExit() {
    local VALUE="${!1}"
    if [ ! "$VALUE" ]
    then
        Say "Missing value for \"$1\", quitting..."
        AddTask robot-quit
        exit 0
    fi
    if [ "$2" ]
    then
        if [ "$VALUE" == "$3" ]
        then
            return
        fi
        if ! echo "$VALUE" | grep -qE "$2"
        then
            Say "Value \"$VALUE\" doesn't match regex \"$2\", quitting..."
            AddTask robot-quit
            exit 0
        fi
    fi
}

getOrGenerate(){
    local VARNAME=$1
    local SIZE=$2

    local VALUE=${!VARNAME}
    local BYTES=$(( $SIZE / 4 * 3 ))

    VALUE=${!1}
    if [ "$VALUE" == "g" ]
    then
        VALUE=$(openssl rand -base64 $BYTES)
    fi
    echo "$VALUE"
}

substitute(){
    local FIND=$1
    local REPLACE=$2
    local FILE=${3:-conf/robot.yaml}
    REPLACE=${REPLACE//\\/\\\\}
    for TRY in "#" "|" "%" "^"
    do
        if [[ ! $REPLACE = *$TRY* ]]
        then
            RC="$TRY"
            break
        fi
    done
    sed -i -e "s${RC}$FIND${RC}$REPLACE${RC}g" "$GOPHER_CONFIGDIR/$FILE"
}

if [ ! "$GOPHER_ENCRYPTION_INITIALIZED" ]
then
    checkExit "ANS_ENCRYPTION_KEY"
    Say "Initializing encryption and restarting..."
    #set -x
    ENCRYPTION_KEY=$(getOrGenerate ANS_ENCRYPTION_KEY 32)
    cat > .env <<EOF
GOPHER_ENCRYPTION_KEY=$ENCRYPTION_KEY
EOF
    AddTask restart-robot
    exit 0
fi

Say "Continuing automatic setup..."

checkExit "ANS_SLACK_APP_TOKEN" '^xapp-[0-9A-Za-z-]+$'
checkExit "ANS_SLACK_BOT_TOKEN" '^xoxb-[0-9A-Za-z-]+$'
checkExit "ANS_ROBOT_NAME" '^[0-9A-Za-z_-]+$'
checkExit "ANS_ROBOT_ALIAS" '^[]!;%~*+^$?[\{\}-]$'
checkExit "ANS_JOB_CHANNEL" '^[0-9A-Za-z_-]+$'
checkExit "ANS_ROBOT_EMAIL" '^[0-9A-Za-z+\.\_\-]*@[0-9A-Za-z+\.\_\-]*$'
checkExit "ANS_SSH_PHRASE" '^[0-9A-Za-z_+/-]{16,}$' "g"
checkExit "ANS_KEY_TYPE" '^dsa|ecdsa|rsa|ed25519$'
checkExit "ANS_ROBOT_REPOSITORY"
checkExit "ANS_ADMIN_SECRET" '^[0-9A-Za-z_+/-]{8,}$' "g"

SLACK_APP_TOKEN=${ANS_SLACK_APP_TOKEN#xapp-}
SLACK_APP_ENCRYPTED=$($GOPHER_INSTALLDIR/gopherbot encrypt $SLACK_APP_TOKEN)
SLACK_BOT_TOKEN=${ANS_SLACK_BOT_TOKEN#xoxb-}
SLACK_BOT_ENCRYPTED=$($GOPHER_INSTALLDIR/gopherbot encrypt $SLACK_BOT_TOKEN)
BOTNAME=$(echo "$ANS_ROBOT_NAME" | tr '[:upper:]' '[:lower:]')
CASENAME=$(echo "${BOTNAME:0:1}" | tr '[:lower:]' '[:upper:]')${BOTNAME:1}
BOTFULLNAME="$CASENAME Gopherbot"

BOTALIAS="$ANS_ROBOT_ALIAS"
DISPALIAS="$BOTALIAS"
# '\' is an escape character and needs tons of special handling
if [[ $BOTALIAS = \\ ]]
then
    BOTALIAS='\\\\'
    DISPALIAS='\'
fi

JOBCHANNEL="$ANS_JOB_CHANNEL"
BOTMAIL="$ANS_ROBOT_EMAIL"

KEY_TYPE=${ANS_KEY_TYPE:-rsa}

SSHPHRASE="$(getOrGenerate ANS_SSH_PHRASE 24)"
Say "Generating ssh keys..."
sleep 1
SSH_ENCRYPTED=$($GOPHER_INSTALLDIR/gopherbot encrypt "$SSHPHRASE")
mkdir -p custom/ssh
ssh-keygen -N "$SSHPHRASE" -C "$BOTMAIL" -t "$KEY_TYPE" -f custom/ssh/robot_key
ssh-keygen -N "$SSHPHRASE" -C "$BOTMAIL" -t "$KEY_TYPE" -f custom/ssh/manage_key
ssh-keygen -N "" -C "$BOTMAIL" -t "$KEY_TYPE" -f custom/ssh/deploy_key
DEPKEY=$(cat custom/ssh/deploy_key | tr ' \n' '_:')
rm -f custom/ssh/deploy_key

BOTREPO="$ANS_ROBOT_REPOSITORY"
SETUPKEY="$(getOrGenerate ANS_ADMIN_SECRET 8)"

source .env
cat > .env <<EOF
GOPHER_ENCRYPTION_KEY=$GOPHER_ENCRYPTION_KEY
GOPHER_CUSTOM_REPOSITORY=$BOTREPO
## You should normally keep GOPHER_PROTOCOL commented out, except when
## used in a production container. This allows for the normal case where
## the robot starts in terminal mode for local development.
GOPHER_PROTOCOL=slack
## To use the deploy key below, add ssh/deploy_key.pub as a read-only
## deploy key for the custom configuration repository.
GOPHER_DEPLOY_KEY=$DEPKEY
GOPHER_SETUP_TOKEN=$SETUPKEY
EOF

# Create configuration
cp -r $GOPHER_INSTALLDIR/robot.skel/* "$GOPHER_CONFIGDIR"
substitute "<slackappencrypted>" "$SLACK_APP_ENCRYPTED" "conf/slack.yaml"
substitute "<slackbotencrypted>" "$SLACK_BOT_ENCRYPTED" "conf/slack.yaml"
substitute "<sshencrypted>" "$SSH_ENCRYPTED"
substitute "<jobchannel>" "$JOBCHANNEL" "conf/slack.yaml"
substitute "<botname>" "$BOTNAME"
substitute "<botname>" "$BOTNAME" "conf/slack.yaml"
substitute "<botname>" "$BOTNAME" "conf/terminal.yaml"
substitute "<botalias>" "$BOTALIAS"
substitute "<botalias>" "$BOTALIAS" "conf/terminal.yaml"
substitute "<botfullname>" "$BOTFULLNAME"
substitute "<botfullname>" "$BOTFULLNAME" "git/config"
substitute "<botemail>" "$BOTMAIL"
substitute "<botemail>" "$BOTMAIL" "git/config"

touch ".addadmin"
if [ ! -e "gopherbot" ]
then
    ln -s "$GOPHER_INSTALLDIR/gopherbot" .
fi
echo
echo
if [ "$GOPHER_CONTAINER" ]
then
    echo "Generated files (between <-- snip ...>/<-- /snip --> lines):"
    echo
    cat <<EOF
<-- snip .env -->
GOPHER_ENCRYPTION_KEY=$GOPHER_ENCRYPTION_KEY
GOPHER_CUSTOM_REPOSITORY=$BOTREPO
## You should normally keep GOPHER_PROTOCOL commented out, except when
## used in a production container. This allows for the normal case where
## the robot starts in terminal mode for local development.
# GOPHER_PROTOCOL=slack
## To use the deploy key below, add ssh/deploy_key.pub as a read-only
## deploy key for the custom configuration repository.
GOPHER_DEPLOY_KEY=$DEPKEY
<-- /snip >
EOF
    echo
    echo "<-- snip manage_key.pub -->"
    cat "custom/ssh/manage_key.pub"
    echo "<-- /snip >"
    echo
    echo "<-- snip deploy_key.pub -->"
    cat "custom/ssh/deploy_key.pub"
    echo "<-- /snip >"
    echo
    Say "********************************************************

"
    Say "Initial configuration of your robot is complete. To finish setting up your robot, \
and to add yourself as an administrator:
1) Add a read-write deploy key to the robot's repository, using the the 'manage_key.pub' \
shown above; this corresponds to an encrypted 'manage_key' that your robot will use to save \
and update it's configuration. 
2) Add a read-only deploy key to the robot's repository, using the 'deploy_key.pub' shown \
above; this corresponds to an unencrypted 'deploy_key' (file removed) which is trivially \
encoded as the 'GOPHER_DEPLOY_KEY' in the '.env' file. *Gopherbot* will use this deploy key, \
along with the 'GOPHER_CUSTOM_REPOSITORY', to initially clone it's repository during bootstrapping.
3) Copy the contents of the '.env' file shown above to a safe place, not kept in a repository. \
GOPHER_PROTOCOL is commented out to avoid accidentally connecting another instance of your robot \
to team chat when run from a terminal window for the development environment. With proper \
configuration of your git repository, the '.env' file is all that's needed to bootstrap your \
robot in to an empty *Gopherbot* container, (https://quay.io/lnxjedi/gopherbot) or on a Linux \
host or VM with the *Gopherbot* software archive installed.
4) Once these tasks are complete, re-start this container in a separate tab/window to connect \
your robot to team chat.
5) Open a direct message (DM) channel to your robot, and give this command to add yourself \
as an administrator: \"add administrator $SETUPKEY\"; your robot will then update \
'custom/conf/slack.yaml' to make you an administrator, and reload it's configuration. \
(You can find your new bot in ${JOBCHANNEL}).
6) Once that completes, you can instruct the robot to store it's configuration in it's git \
repository by issuing the 'save' command.
7) At this point, feel free to experiment with the default robot; you can start by typing \
\"help\" in ${JOBCHANNEL}. When you're finished, press <ctrl-c> in the window where you \
ran \"gopherbot\" to stop the robot, or optionally tell your robot to \"${BOTALIAS}quit\".

After your robot has saved it's configuration, you can stop and discard this container."

    AddTask robot-quit
    exit 0
else
    Say "********************************************************

"
    Say "Initial configuration of your robot is complete. To finish setting up your robot, \
and to add yourself as an administrator:
1) Open a second terminal window in the same directory as answerfile.txt; you'll need this \
for completing setup.
2) Add a read-write deploy key to the robot's repository, using the contents of \
'custom/ssh/manage_key.pub'; this corresponds to an encrypted 'manage_key' that your \
robot will use to save and update it's configuration.
3) Add a read-only deploy key to the robot's repository, using the contents of \
'custom/ssh/deploy_key.pub'; this corresponds to an unencrypted 'deploy_key' (file removed) \
which is trivially encoded as the 'GOPHER_DEPLOY_KEY' in the '.env' file. *Gopherbot* will \
use this deploy key, along with the 'GOPHER_CUSTOM_REPOSITORY', to initially clone it's \
repository during bootstrapping.
4) Once these tasks are complete, in your second terminal window, run './gopherbot' without any \
arguments. Your robot should connect to your team chat.
5) Open a direct message (DM) channel to your robot, and give this command to add yourself \
as an administrator: \"add administrator $SETUPKEY\"; your robot will then update \
'custom/conf/slack.yaml' to make you an administrator, and reload it's configuration. \
(You can find your new bot in ${JOBCHANNEL}).
6) Once that completes, you can instruct the robot to store it's configuration in it's git \
repository by issuing the 'save' command.
7) At this point, feel free to experiment with the default robot; you can start by typing \
\"help\" in ${JOBCHANNEL}. When you're finished, press <ctrl-c> in the window where you \
ran \"gopherbot\" to stop the robot, or optionally tell your robot to \"${BOTALIAS}quit\".
8) Finally, copy the contents of the '.env' file to a safe place, with the GOPHER_PROTOCOL \
commented out; this avoids accidentally connecting another instance of your robot to team chat \
when run from a terminal window for the development environment. With proper configuration of \
your git repository, the '.env' file is all that's needed to bootstrap your robot in to an empty \
*Gopherbot* container, (https://quay.io/lnxjedi/gopherbot) or on a Linux host or VM with the \
*Gopherbot* software archive installed.

Now you've completed all of the initial setup for your *Gopherbot* robot. See the chapter on \
deploying and running your robot (https://lnxjedi.github.io/gopherbot/RunRobot.html) for \
information on day-to-day operations. You can stop the running robot in your second terminal \
window using <ctrl-c>.

(NOTE: Scroll back to the line of *** above and follow the directions to finish setup)"

    AddTask robot-quit
    exit 0
fi
</file_content file: gopherbot-main/plugins/autosetup.sh>
<preamble file: gopherbot-main/plugins/bootstrap.py>

</preamble>
<file_content file: gopherbot-main/plugins/bootstrap.py>
#!/usr/bin/env python3

# bootstrap.py - bootstrap a robot from env vars

import os
import sys
from gopherbot_v2 import Robot

bot = Robot()

# Pop off the executable path
sys.argv.pop(0)

command = sys.argv.pop(0)
if command != "init":
    exit(0)

cfgdir = os.getenv("GOPHER_CONFIGDIR")
cfgconf = os.path.join(cfgdir, "conf")

hasconfig = True
try:
    os.stat(cfgconf)
except FileNotFoundError:
    hasconfig = False
except:
    bot.Log("Error", "Checking for %s: %s" % (cfgconf, sys.exc_info()[0]))
    exit(1)

# First, see if we're doing a restore
if hasconfig:
    try:
        os.stat(".restore")
        bot.AddJob("restore", [])
        exit(0)
    except FileNotFoundError:
        pass
    exit(0)

clone_url = os.getenv("GOPHER_CUSTOM_REPOSITORY")
if len(clone_url) == 0:
    bot.Log("Warn", "GOPHER_CUSTOM_REPOSITORY not set, not bootstrapping")
    exit(0)

clone_branch = os.getenv("GOPHER_CUSTOM_BRANCH")

if not clone_url.startswith("http"):
    depkey = os.getenv("GOPHER_DEPLOY_KEY")
    if len(depkey) == 0:
        bot.Log("Error", "SSH required for bootstrapping and no GOPHER_DEPLOY_KEY set")
        exit(1)

bot.Log("Info", "Creating bootstrap pipeline for %s" % clone_url)
bot.SetParameter("BOOTSTRAP", "true")
bot.SetParameter("GOPHER_DEPLOY_KEY", depkey)
bot.AddTask("git-init", [ clone_url ])

tmp_key_name = "binary-encrypted-key"
deploy_env = os.getenv("GOPHER_ENVIRONMENT")
if deploy_env != "production":
    tmp_key_name += "." + deploy_env
tkey = os.path.join(cfgdir, tmp_key_name)
bot.AddTask("exec", [ "rm", "-f", tkey ])
# touch restore even if GOPHER_BRAIN != file;
# backup and restore will check and exit
bot.AddTask("exec", [ "touch", ".restore" ])
bot.AddTask("git-clone", [ clone_url, clone_branch, cfgdir, "true" ])
bot.AddTask("run-pipeline", [])
bot.AddTask("restart-robot", [])
</file_content file: gopherbot-main/plugins/bootstrap.py>
<preamble file: gopherbot-main/plugins/chuck.rb>

</preamble>
<file_content file: gopherbot-main/plugins/chuck.rb>
#!/usr/bin/ruby
require 'net/http'
require 'json'

# load the Gopherbot ruby library and instantiate the bot
require 'gopherbot_v1'
bot = Robot.new()

defaultConfig = <<'DEFCONFIG'
MessageMatchers:
- Command: chuck
  Regex: '(?i:\bchuck norris\b)'
Config:
  Openings:
  - "Chuck Norris?!?! He's AWESOME!!!"
  - "Oh cool, you like Chuck Norris, too?"
  - "Speaking of Chuck Norris - "
  - "Hey, I know EVERYTHING about Chuck Norris!"
  - "I'm a HUUUUGE Chuck Norris fan!"
  - "Not meaning to eavesdrop or anything, but are we talking about CHUCK NORRIS ?!?"
  - "Oh yeah, Chuck Norris! The man, the myth, the legend."
DEFCONFIG

command = ARGV.shift()

case command
when "configure"
	puts defaultConfig
	exit
when "chuck"
    uri = URI("https://api.chucknorris.io/jokes/random")
    d = JSON::parse(Net::HTTP.get(uri))
    opening = bot.RandomString(bot.GetTaskConfig()["Openings"])
    bot.Say("#{opening} Did you know ...?")
    bot.Pause(2)
    bot.Say(d["value"])
end
</file_content file: gopherbot-main/plugins/chuck.rb>
<preamble file: gopherbot-main/plugins/citools.py>

</preamble>
<file_content file: gopherbot-main/plugins/citools.py>
#!/usr/bin/python3

import sys
from gopherbot_v2 import Robot

bot = Robot()

executable = sys.argv.pop(0)
command = sys.argv.pop(0)

if command == "configure":
    exit(0)

repodata = bot.GetRepoData()

def start_build(repository, branch, pipeline, args):
    if branch == ".":
        tell_branch = "(default)"
    else:
        tell_branch = branch
    if pipeline == "pipeline":
        bot.Say("Ok, I'll start the gopherci job for %s, %s branch..." % (repository, tell_branch))
        bot.AddJob("gopherci", [ "build", repository, branch ])
        bot.AddTask("say", ["... build of %s/%s completed" % (repository, tell_branch) ])
        bot.FailTask("say", ["... build of %s/%s failed" % (repository, tell_branch) ])
    else:
        bot.Say("Ok, I'll start the gopherci custom job for %s, %s branch, running pipeline: %s" % (repository, tell_branch, pipeline))
        bot.AddJob("gopherci", [ "job", repository, branch, pipeline ] + args)
        bot.AddTask("say", ["... job %s/%s - %s: completed" % (repository, tell_branch, pipeline) ])
        bot.FailTask("say", ["... job %s/%s - %s: failed" % (repository, tell_branch, pipeline) ])

if not isinstance(repodata, dict):
    bot.Say("'repodata.yaml' missing or invalid; GetRepoData() failed")
    exit(0)

if command == "build":
    build = []
    repospec = sys.argv.pop(0).lower()
    fcount = len(repospec.split("/"))

    branch = sys.argv.pop(0)
    if len(branch) == 0:
        branch = "."
    
    pipeline = sys.argv.pop(0)
    args = []
    if len(pipeline) == 0:
        pipeline = "pipeline"
    else:
        args = sys.argv.pop(0).split(" ")

    for reponame in repodata.keys():
        match = "/".join(reponame.lower().split("/")[-fcount:])
        if repospec == match:
            if reponame not in build:
                build.append(reponame)

    for reponame in repodata.keys():
        if "dependencies" in repodata[reponame]:
            for deprepo in repodata[reponame]["dependencies"]:
                match = "/".join(deprepo.lower().split("/")[-fcount:])
                if repospec == match:
                    if deprepo not in build:
                        build.append(deprepo)

    if len(build) == 0:
        bot.Say("I don't have any repositories matching %s" % repospec)
    elif len(build) > 1:
        bot.Say("Multiple repositories match %s, please qualify further" % repospec)
    else:
        start_build(build[0], branch, pipeline, args)

if command == "help":
    bot.Say("""\
The "build <repo> (branch)" command takes a repository name and optional \
branch, which the robot will try matching against repositories and \
dependencies in "repositories.yaml". When the repository name is not \
unique, you can also add a user/org component to match, e.g. \
"build joeblow/website"; that can be further qualified with the site name \
if needed, e.g. "build github.com/joeblow/website".""")
</file_content file: gopherbot-main/plugins/citools.py>
<preamble file: gopherbot-main/plugins/hosts.sh>

</preamble>
<file_content file: gopherbot-main/plugins/hosts.sh>
#!/bin/bash -e

# hosts.sh - less trivial example shell plugin for gopherbot
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift

configure(){
	cat <<"EOF"
Help:
- Keywords: [ "hosts", "lookup", "dig", "nslookup" ]
  Helptext:
  - "(bot), dig <hostname|ip> ... - lookup a list of hosts and reply with a table of results"
  - "(bot), hosts <hostname|ip> ... - lookup a list of hosts and reply with a table of results"
  - "(bot), hostname - report the $HOSTNAME where the bot is running"
CommandMatchers:
- Command: hosts
  Regex: '(?i:hosts?|lookup|dig|nslookup) ([\w-. ]+)'
- Command: hostname
  Regex: '(?i:hostname)'
EOF
}

hosts() {
	HOSTSARR=($*)
	for LOOKUP in "${HOSTSARR[@]}"
	do
		ERROR=false
		if echo "$LOOKUP" | grep -qP "[a-zA-Z]+"
		then
			HOSTNAME=$LOOKUP
			IPADDR=$(host $HOSTNAME | grep 'has address') || ERROR=true
			IPADDR=${IPADDR##* }
			[ "$ERROR" = "true" ] && IPADDR="(not found)"
		else
			IPADDR=$LOOKUP
			HOSTNAME=$(host $LOOKUP) || ERROR=true
			HOSTNAME=${HOSTNAME##* }
			HOSTNAME=${HOSTNAME%.}
			[ "$ERROR" = "true" ] && HOSTNAME="(not found)"
		fi
		MESSAGE=$(echo -e "${IPADDR}\t${HOSTNAME}\n$MESSAGE")
	done

	Say -f "$MESSAGE"
}

case $command in
	"configure")
		configure
		;;
	"hosts")
		hosts $*
		;;
	"hostname")
		Reply "I'm running on $HOSTNAME"
		;;
esac
</file_content file: gopherbot-main/plugins/hosts.sh>
<preamble file: gopherbot-main/plugins/samples/README.txt>

</preamble>
<file_content file: gopherbot-main/plugins/samples/README.txt>
The plugins in this folder are primarily code examples, but offer little in the
way of usefulness (or even entertainment). Some are used with the test suite.
</file_content file: gopherbot-main/plugins/samples/README.txt>
<preamble file: gopherbot-main/plugins/samples/bashdemo.sh>

</preamble>
<file_content file: gopherbot-main/plugins/samples/bashdemo.sh>
#!/bin/bash

# bashdemo - plugin that exercises the bash plugin API, but doesn't do
# anything useful.

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat <<"EOF"
Help:
- Keywords: [ "hear" ]
  Helptext: [ "(bot), hear me out - let the robot prove it's really listening" ]
- Keywords: [ "store", "remember" ]
  Helptext: [ "(bot), store <something> is <something> - store a fact in short-term memory" ]
- Keywords: [ "remember", "recall" ]
  Helptext: [ "(bot), what is <something> - recall a fact / context from short-term memory" ]
CommandMatchers:
- Regex: '(?i:hear me out)'
  Command: "hear"
- Regex: '(?i:store ([-\w :\/]+) is ([-\w .,!?:\/]+))'
  Command: "store"
- Regex: '(?i:what is ([-\w :\/]+)\??)'
  Command: "recall"
EOF
}
# TODO: Finish regex/command above

case "$command" in
# NOTE: only "configure" should print anything to stdout
	"configure")
		configure
		;;
	"hear")
		REPLY=$(PromptForReply "SimpleString" "Well ok then, what do you want to tell me?")
		if [ $? -ne 0 ]
		then
			Reply "Eh, sorry bub, I'm having trouble hearing you - try typing faster?"
		else
			Reply "Ok, I hear you saying \"$REPLY\" - feel better?"
		fi
		;;
	"store")
		Remember "$1" "$2"
		Say "I'll remember \"$1\" is \"$2\" - but eventually I'll forget!"
		;;
	"recall")
		MEMORY=$(Recall "$1")
		if [ -z "$MEMORY" ]
		then
			Reply "Gosh, I have no idea - I'm so forgetful!"
		else
			Say "$1 is $MEMORY"
		fi
esac
</file_content file: gopherbot-main/plugins/samples/bashdemo.sh>
<preamble file: gopherbot-main/plugins/samples/echo.sh>

</preamble>
<file_content file: gopherbot-main/plugins/samples/echo.sh>
#!/bin/bash

# echo.sh - trivial shell plugin example for Gopherbot

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat <<"EOF"
---
Help:
- Keywords: [ "repeat" ]
  Helptext: [ "(bot), repeat (me) - prompt for and trivially repeat a phrase" ]
- Keywords: [ "echo" ]
  Helptext: [ "(bot), echo <something> - tell the bot to say <something>" ]
CommandMatchers:
- Command: "repeat"
  Regex: '(?i:repeat( me)?)'
- Command: "echo"
  Regex: '(?i:echo (.*))'
EOF
}

case "$command" in
# NOTE: only "configure" should print anything to stdout
	"configure")
		configure
		;;
	"echo")
		Pause 1 # because the robot knows how to "type"
		Say "$1"
		;;
	"repeat")
		REPEAT=$(PromptForReply SimpleString "What do you want me to repeat?")
		RETVAL=$?
		if [ $RETVAL -ne $GBRET_Ok ]
		then
			Reply "Sorry, I had a problem getting your reply: $RETVAL"
		else
			Reply "$REPEAT"
		fi
		;;
esac
</file_content file: gopherbot-main/plugins/samples/echo.sh>
<preamble file: gopherbot-main/plugins/samples/format.py>

</preamble>
<file_content file: gopherbot-main/plugins/samples/format.py>
#!/usr/bin/python3

import sys
from gopherbot_v2 import Robot

bot = Robot()

default_config = '''
Channels:
- random
AllowDirect: false
Help:
- Keywords: [ "format", "world" ]
  Helptext: [ "(bot), format world - exercise formatting options" ]
CommandMatchers:
- Regex: '(?i:format world)'
  Command: "format"
'''

executable = sys.argv.pop(0)
command = sys.argv.pop(0)

if command == "configure":
    print(default_config)

if command == "format":
    bot = bot.MessageFormat("Variable")
    proto = bot.GetBotAttribute("protocol")
    bot.Say("Hello, %s World!" % proto)
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley')
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "raw")
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "variable")
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "fixed")
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "bogus")
</file_content file: gopherbot-main/plugins/samples/format.py>
<preamble file: gopherbot-main/plugins/samples/format.rb>

</preamble>
<file_content file: gopherbot-main/plugins/samples/format.rb>
#!/usr/bin/ruby

# boilerplate
require 'gopherbot_v1'

bot = Robot.new()

defaultConfig = <<'DEFCONFIG'
Channels:
- botdev
AllowDirect: false
Help:
- Keywords: [ "format", "world" ]
  Helptext: [ "(bot), format world - exercise formatting options" ]
CommandMatchers:
- Regex: '(?i:format world)'
  Command: "format"
DEFCONFIG

command = ARGV.shift()

case command
when "configure"
	puts defaultConfig
	exit
when "format"
    bot = bot.MessageFormat("Variable")
    proto = bot.GetBotAttribute("protocol")
    bot.Log("Audit", "Got: #{proto}")
    bot.Say("Hello, #{proto} World!")
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley')
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "raw")
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "variable")
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "fixed")
    bot.Say('_Italics_ <One> *Bold* `Code` @parsley', "bogus")
end
</file_content file: gopherbot-main/plugins/samples/format.rb>
<preamble file: gopherbot-main/plugins/samples/format.sh>

</preamble>
<file_content file: gopherbot-main/plugins/samples/format.sh>
#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

COMMAND=$1
shift

configure(){
  cat <<"EOF"
Channels:
- general
Help:
- Keywords: [ "format", "world" ]
  Helptext: [ "(bot), format world - exercise formatting options" ]
CommandMatchers:
- Regex: '(?i:format world)'
  Command: "format"
- Regex: '(?i:format fixed)'
  Command: "fixed"
- Regex: '(?i:format variable)'
  Command: "variable"
- Regex: '(?i:format raw)'
  Command: "raw"
EOF
}

case "$COMMAND" in
  "configure")
    configure
    ;;
  "format")
    # Change default format
    MessageFormat Variable
    PROTO=$(GetBotAttribute protocol)
    Say "Hello, $PROTO World!"
    # Use default format
    Say '_Italics_ <One> *Bold* `Code` @parsley'
    # Raw
    Say -r '_Italics_ <One> *Bold* `Code` @parsley'
    # Variable
    Say -v '_Italics_ <One> *Bold* `Code` @parsley'
    # Fixed
    Say -f '_Italics_ <One> *Bold* `Code` @parsley'
    ;;
  "fixed")
    Say -f '_Italics_ <One> *Bold* `Code` @parsley'
    ;;
  "variable")
    Say -v '_Italics_ <One> *Bold* `Code` @parsley'
    ;;
  "raw")
    Say -r '_Italics_ <One> *Bold* `Code` @parsley'
    ;;
esac
</file_content file: gopherbot-main/plugins/samples/format.sh>
<preamble file: gopherbot-main/plugins/samples/hello.sh>

</preamble>
<file_content file: gopherbot-main/plugins/samples/hello.sh>
#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

COMMAND=$1
shift

configure(){
  cat <<"EOF"
Help:
- Keywords: [ "hello", "world" ]
  Helptext: [ "(bot), hello world - the usual first program" ]
CommandMatchers:
- Regex: '(?i:hello world)'
  Command: "hello"
AmbientMatchCommand: true
MessageMatchers:
- Regex: 'hello robot'
  Command: "hello"
EOF
}

case "$COMMAND" in
    "configure")
        configure
        ;;
    "hello")
        Say "Hello, World!"
        ;;
esac
</file_content file: gopherbot-main/plugins/samples/hello.sh>
<preamble file: gopherbot-main/plugins/samples/hello2.sh>

</preamble>
<file_content file: gopherbot-main/plugins/samples/hello2.sh>
#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

COMMAND=$1
shift

configure(){
  cat <<"EOF"
Channels:
- random
AllowDirect: false
Help:
- Keywords: [ "hello", "world" ]
  Helptext: [ "(bot), hello world - the usual first program" ]
CommandMatchers:
- Regex: '(?i:hello robot)'
  Command: "hello"
EOF
}

case "$COMMAND" in
    "configure")
        configure
        ;;
    "hello")
        Say "I'm here"
        ;;
esac
</file_content file: gopherbot-main/plugins/samples/hello2.sh>
<preamble file: gopherbot-main/plugins/samples/pythondemo.py>

</preamble>
<file_content file: gopherbot-main/plugins/samples/pythondemo.py>
#!/usr/bin/python3

import sys
from gopherbot_v2 import Robot

bot = Robot()

default_config = '''
---
Help:
- Keywords: [ "python" ]
  Helptext: [ "(bot), python (me!) - prove that python plugins work" ]
- Keywords: [ "listen" ]
  Helptext: [ "(bot), listen (to me!) - ask a question" ]
- Keywords: [ "thread" ]
  Helptext: [ "(bot), python-thread - ask the robot to start a new thread" ]
- Keywords: [ "thread" ]
  Helptext: [ "(bot), python-ask-thread - ask a question in a thread" ]
- Keywords: [ "remember", "memory" ]
  Helptext: [ "(bot), remember <anything> - prove the robot has a brain(tm)" ]
- Keywords: [ "recall", "memory" ]
  Helptext: [ "(bot), recall - prove the robot has a brain(tm)" ]
- Keywords: [ "forget", "memory" ]
  Helptext: [ "(bot), forget <#> - ask the robot to forget one of it's remembered 'facts'" ]
- Keywords: [ "check" ]
  Helptext: [ "(bot), check me - get the bot to check you out" ]
CommandMatchers:
- Regex: (?i:python( me)?!?)
  Command: python
- Regex: (?i:python-ask-thread)
  Command: askthread
- Regex: (?i:python-thread)
  Command: thread
- Regex: (?i:listen( to me)?!?)
  Command: listen
- Regex: (?i:remember ([-\w .,!?:\/]+))
  Command: remember
  Contexts: [ "item" ]
- Regex: (?i:(?:recall|memories))
  Command: recall
- Regex: '(?i:forget #?([\d]{1,2}))'
  Command: forget
- Regex: (?i:check me)
  Command: check
Config:
  Replies:
  - "You has the pythons"
  - "Are you JOKING?!? Pythons are DANGEROUS!!"
  - "Eh, how about a grass snake?"
  - "Sorry, I left it in my other jacket"
'''

executable = sys.argv.pop(0)
command = sys.argv.pop(0)

if command == "configure":
  print(default_config)

if command == "python":
  bot.Say("Sure, %s, gimme a sec to look for it..." % bot.GetSenderAttribute("firstName"))
  bot.Pause(1.5)
  bot.Say(bot.RandomString(bot.GetTaskConfig()["Replies"]))

if command == "thread":
  tbot = bot.Threaded()
  tbot.Reply("Sure, we can chat here")
  tbot.Say("... you still have to use my name, though")

if command == "askthread":
  rep = bot.PromptThreadForReply("SimpleString", "Tell me something - anything!")
  if rep.ret == Robot.Ok:
    bot.SayThread("I hear what you're saying - \"%s\"" % rep)
  else:
    bot.SayThread("I'm sorry, I had a hard time hearing your replay - funny characters? Take too long?")

if command == "listen":
  dbot = bot.Direct()
  rep = dbot.PromptForReply("SimpleString", "Ok, what do you want to tell me?")
  if rep.ret == Robot.Ok:
    dbot.Say("I hear what you're saying - \"%s\"" % rep)
  else:
    bot.Say("I'm sorry, I had a hard time hearing your replay - funny characters? Take too long?")

if command == "remember":
  thing = sys.argv.pop(0)
  bot.Say("Ok, I'll remember \"%s\"" % thing)
  memory = bot.CheckoutDatum("memory", True)
  if memory.exists:
    memory.datum.append(thing)
  else:
    memory.datum = [ thing ]
  ret = bot.UpdateDatum(memory)
  if ret != Robot.Ok:
    bot.Say("Uh-oh, I must be gettin' old - having memory problems!")

if command == "recall":
  memory = bot.CheckoutDatum("memory", False)
  if memory.exists:
    reply = [ "Here's everything I can remember:" ]
    for i in range(0, len(memory.datum)):
      reply.append("#%d: %s" % ( i + 1, memory.datum[i] ))
    bot.Say("\n".join(reply))
  else:
    bot.Say("Gee, I don't remember ANYTHING")

if command == "forget":
  item = int(sys.argv.pop(0)) - 1
  if item >= 0:
    memory = bot.CheckoutDatum("memory", True)
    if memory.exists and len(memory.datum) > item:
      bot.Say("Ok, I'll forget \"%s\"" % memory.datum[item])
      memory.datum = memory.datum[:item] + memory.datum[item+1:]
      bot.UpdateDatum(memory)
    else:
      bot.CheckinDatum(memory)
      bot.Say("I don't see that item number in my memories")
  else:
    bot.Say("A wise guy, eh?")

if command == "check":
  if bot.CheckAdmin():
    bot.Say("Ah - you're an administrator!")
  else:
    bot.Say("Huh, looks like you're a regular schmoe")
  bot.Pause(1)
  bot.Say("Ok, let's see if you're able to elevate...")
  if bot.Elevate(True):
    bot.Say("Great, I should be able to do some real work for you")
  else:
    bot.Say("Uh-oh - forget getting me to do any real work for you!")
</file_content file: gopherbot-main/plugins/samples/pythondemo.py>
<preamble file: gopherbot-main/plugins/samples/rubydemo.rb>

</preamble>
<file_content file: gopherbot-main/plugins/samples/rubydemo.rb>
#!/usr/bin/ruby

# boilerplate
require 'gopherbot_v1'

bot = Robot.new()
# /boilerplate

=begin
The defaultConfig is a multi-line YAML formatted document that specifies
this plugin's default configuration for Gopherbot. It may include any of the
fields in https://godoc.org/github.com/lnxjedi/gopherbot/bot#Plugin, as
well as arbitrary YAML for config data that a bot admin might want to
override.
=end
defaultConfig = <<'DEFCONFIG'
---
Help:
- Keywords: [ "ruby" ]
  Helptext: [ "(bot), ruby (me!) - prove that ruby plugins work" ]
- Keywords: [ "listen" ]
  Helptext: [ "(bot), listen (to me!) - ask a question" ]
- Keywords: [ "thread" ]
  Helptext: [ "(bot), ruby-thread - ask the robot to start a new thread" ]
- Keywords: [ "thread" ]
  Helptext: [ "(bot), ruby-ask-thread - ask a question in a thread" ]
- Keywords: [ "remember", "memory" ]
  Helptext: [ "(bot), remember <anything> - prove the robot has a brain(tm)" ]
- Keywords: [ "recall", "memory" ]
  Helptext: [ "(bot), recall - prove the robot has a brain(tm)" ]
- Keywords: [ "forget", "memory" ]
  Helptext: [ "(bot), forget <#> - ask the robot to forget one of it's remembered 'facts'" ]
- Keywords: [ "check" ]
  Helptext: [ "(bot), check me - get the bot to check you out" ]
CommandMatchers:
- Regex: (?i:ruby( me)?!?)
  Command: ruby
- Regex: (?i:ruby-thread)
  Command: thread
- Regex: (?i:ruby-ask-thread)
  Command: askthread
- Regex: (?i:listen( to me)?!?)
  Command: listen
- Regex: '(?i:remember(?: (slowly))? ([-\w .,!?:\/]+))'
  Command: remember
  Contexts: [ "", "item" ]
- Regex: (?i:recall ?([\d]+)?)
  Command: recall
- Regex: (?i:forget ([\d]{1,2}))
  Command: forget
- Regex: (?i:check me)
  Command: check
Config:
  Replies:
  - "Consider yourself rubied"
  - "Waaaaaait a second... what do you mean by that?"
  - "I'll ruby you, but not right now - I'll wait 'til you're least expecting it..."
  - "Crap, sorry - all out of rubies"
DEFCONFIG

command = ARGV.shift()

case command
when "configure"
  puts defaultConfig
  exit
when "ruby"
  bot.Say("Sure, #{bot.GetSenderAttribute("firstName")}!")
  sleep 1.5
  bot.Say(bot.RandomString(bot.GetTaskConfig()["Replies"]))
when "thread"
  bot.ReplyThread("Ok, let's chat here")
  bot.SayThread("... you still have to use my name, though")
when "askthread"
  rep = bot.PromptThreadForReply("SimpleString", "Tell me something - anything!")
  if rep.ret == Robot::Ok
    bot.SayThread("I hear what you're saying - '#{rep}'")
  else
    bot.SayThread("I'm sorry, I'm not sure what you're trying to tell me - did you put funny characters in your reply?")
  end
when "listen"
  dbot = bot.Direct()
  rep = dbot.PromptForReply("SimpleString", "Ok, what do you want to tell me?")
  if rep.ret == Robot::Ok
    dbot.Say("I hear what you're saying - '#{rep}'")
  else
    bot.Say("I'm sorry, I'm not sure what you're trying to tell me - did you put funny characters in your reply?")
  end
when "remember"
  speed = ARGV[0]
  thing = ARGV[1]
  memory = bot.CheckoutDatum("memory", true)
  remembered = false
  if memory.exists
    if memory.datum.include?(thing)
      bot.Say("That's already one of my fondest memories")
      bot.CheckinDatum(memory)
    else
      remembered =true
      memory.datum.push(thing)
    end
  else
    remembered = true
    memory.datum = [ thing ]
  end
  if remembered
    if speed == "slowly"
      bot.Say("Ok, I'll remember \"#{thing}\" ... but sloooowly")
    else
      bot.Say("Ok, I'll remember \"#{thing}\"")
    end
    if speed == "slowly"
      bot.Pause(4)
    end
    ret = bot.UpdateDatum(memory)
    if speed != "slowly" && ret == Robot::Ok
      bot.Say("committed to memory")
    end
    if ret != Robot::Ok && speed != "slowly"
      bot.Say("Dang it, having problems with my memory")
    end
  end
when "recall"
  memory = bot.CheckoutDatum("memory", false)
  if memory.exists
    if ARGV[0].length > 0
      mnum = ARGV[0].to_i - 1
      if mnum < 0
        bot.Say("I can't make out what you want me to remember")
      elsif mnum >= memory.datum.length()
        bot.Say("I don't remember that many things!")
      else
        bot.CheckinDatum(memory)
        bot.Say(memory.datum[mnum])
      end
    else
      reply = "Here's what I remember:\n"
      memory.datum.each_index { |i|
        index = i + 1
        reply += index.to_s + ": " + memory.datum[i] + "\n"
      }
      bot.CheckinDatum(memory)
      bot.Say(reply)
    end
  else
    bot.Say("Sorry - I don't remember anything!")
  end
when "forget"
  i = ARGV[0].to_i - 1
  memory = bot.CheckoutDatum("memory", true)
  memories = memory.datum
  if i >= 0 && memories.class == Array && memories[i]
    bot.Say("Ok, I'll forget \"#{memories[i]}\"")
    memories.delete_at(i)
    bot.UpdateDatum(memory)
  else
    bot.CheckinDatum(memory)
    bot.Say("Gosh, I guess I never remembered that in the first place!")
  end
when "check"
  isAdmin = bot.CheckAdmin()
  if isAdmin
    bot.Say("Ok, it looks like you're an administrator")
  else
    bot.Say("Well, you're not an administrator")
  end
  bot.Pause(1)
  bot.Say("Now I'll request elevation...")
  success = bot.Elevate(true)
  if success
    bot.Say("Everything looks good, mac!")
  else
    bot.Say("You failed to elevate, homie, I'm calling the cops!")
  end
  bot.Log("info", "Checked out #{bot.user}, admin: #{isAdmin.to_s}, elavate check: #{success.to_s}")
end
</file_content file: gopherbot-main/plugins/samples/rubydemo.rb>
<preamble file: gopherbot-main/plugins/samples/test.sh>

</preamble>
<file_content file: gopherbot-main/plugins/samples/test.sh>
#!/bin/bash

# test.sh - the code here is more of use for the test suite than as a good
# source of copy-n-paste code. ymmv. Note the lack of helptext.

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat <<"EOF"
---
CommandMatchers:
- Command: "waitask"
  Regex: '(?i:waitask)'
- Command: "asknow"
  Regex: '(?i:asknow)'
EOF
}

case "$command" in
# NOTE: only "configure" should print anything to stdout
	"configure")
		configure
		;;
	"waitask")
		(sleep 3; Say "ok - answer puppies") &
		sleep 2
		# The 'bot will have to wait to hear back about kittens
		REPLY=$(PromptForReply YesNo "Do you like kittens?")
		# Make sure this isn't said at the same time as the next question
		Say "I like kittens too!"
		;;
	"asknow")
		REPLY=$(PromptForReply YesNo "Do you like puppies?")
		sleep 1
		Say "I like puppies too!"		
esac
</file_content file: gopherbot-main/plugins/samples/test.sh>
<preamble file: gopherbot-main/plugins/samples/whoami.sh>

</preamble>
<file_content file: gopherbot-main/plugins/samples/whoami.sh>
#!/bin/bash -e

# whoami.sh - shell plugin example that retrieves user attributes
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift

configure(){
	cat <<"EOF"
Help:
- Keywords: [ "whoami" ]
  Helptext: [ "(bot), whoami - get the bot to tell you a little about yourself" ]
CommandMatchers:
- Command: "whoami"
  Regex: '(?i:whoami)'
EOF
}

case $command in
	"configure")
		configure
		;;
	"whoami")
		USERFULLNAME=$(GetSenderAttribute fullName)
		USEREMAIL=$(GetSenderAttribute email)
		Reply "You're $USERFULLNAME, $USEREMAIL"
		;;
esac
</file_content file: gopherbot-main/plugins/samples/whoami.sh>
<preamble file: gopherbot-main/plugins/ssh-admin.sh>

</preamble>
<file_content file: gopherbot-main/plugins/ssh-admin.sh>
#!/bin/bash -e

# ssh-admin.sh - shell plugin for managing the robot's ssh keypair
# see tasks/ssh-init.sh

command=$1
shift

configure(){
	cat <<"EOF"
Help:
- Keywords: [ "ssh", "keygen", "key", "replace", "keypair" ]
  Helptext: [ "(bot), generate|replace keypair - create an ssh keypair for the robot" ]
- Keywords: [ "ssh", "pubkey", "public", "key" ]
  Helptext: [ "(bot), (show) pubkey - show the robot's public key" ]
CommandMatchers:
- Command: keypair
  Regex: '(?i:(generate|replace) keypair)'
- Command: pubkey
  Regex: '(?i:(show[ -])?pubkey)'
EOF
}

if [ "$command" = "configure" ]
then
	configure
	exit 0
elif [ "$command" = "init" ]
then
	exit 0
fi

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
    # The script should usually exit on error
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH"
        exit 1
    fi
done

if [ -z "$BOT_SSH_PHRASE" ]
then
	Say "\$BOT_SSH_PHRASE not set; update Parameters for ssh-init"
	exit 0
fi

SSH_KEY=${KEYNAME:-robot_key}

SSH_DIR=$GOPHER_CONFIGDIR/ssh

case $command in
	"keypair")
		ACTION=$1
		if [ -e $SSH_DIR/$SSH_KEY ]
		then
			if [ "$ACTION" = "replace" ]
			then
				rm -f $SSH_DIR/$SSH_KEY $SSH_DIR/$SSH_KEY.pub
			else
				Say "I've already got an ssh keypair - use 'replace keypair' to replace it"
				exit 0
			fi
		else
			mkdir -p $SSH_DIR
			chmod 700 $SSH_DIR
		fi
		BOT=$(GetBotAttribute name)
		/usr/bin/ssh-keygen -q -b 4096 -N "$BOT_SSH_PHRASE" -C "$BOT" -f $SSH_DIR/$SSH_KEY
		Say "Created"
		;;
	"pubkey")
		if [ ! -e $SSH_DIR/$SSH_KEY.pub ]
		then
			Say "I don't seem to have an ssh public key - use 'generate keypair' to create one"
		else
			Say -f "$(cat $SSH_DIR/$SSH_KEY.pub)"
		fi
		;;
esac
</file_content file: gopherbot-main/plugins/ssh-admin.sh>
<preamble file: gopherbot-main/plugins/theia.sh>

</preamble>
<file_content file: gopherbot-main/plugins/theia.sh>
#!/bin/bash -e

# theia.sh - a bash plugin that triggers the theia job.

COMMAND=$1
shift

[ "$COMMAND" = "configure" ] && exit 0

trap_handler()
{
  ERRLINE="$1"
  ERRVAL="$2"
  echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
  # The script should usually exit on error
  exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

FailTask tail-log

for REQUIRED in git jq ssh
do
    if ! which $REQUIRED >/dev/null 2>&1
    then
        echo "Required '$REQUIRED' not found in \$PATH"
        exit 1
    fi
done

case "$COMMAND" in
  "theia")
    if [ ! -e "/usr/local/theia/src-gen/backend/main.js" ]
    then
      Say "Theia installation not found. Wrong container?"
      exit 0
    fi
    Say "Ok, I'll start the Theia Gopherbot IDE..."
    AddJob theia
    FailTask say "Starting theia failed! (are you using the gopherbot-theia image?)"
    AddTask say "... Theia finished"
    ;;
esac
</file_content file: gopherbot-main/plugins/theia.sh>
<preamble file: gopherbot-main/plugins/weather.rb>

</preamble>
<file_content file: gopherbot-main/plugins/weather.rb>
#!/usr/bin/ruby
require 'net/http'
require 'json'

# NOTE: A bot administrator should supply the API key with a DM:
# `store task parameter weather OWM_APIKEY=xxxx`. Defaults for
# DEFAULT_COUNTRY and TEMP_UNITS can be overridden in custom
# conf/plugins/weather.yaml

# load the Gopherbot ruby library and instantiate the bot
require 'gopherbot_v1'
bot = Robot.new()

defaultConfig = <<'DEFCONFIG'
Help:
- Keywords: [ "weather" ]
  Helptext: [ "(bot), weather in <city(,country) or zip code> - fetch the weather from OpenWeatherMap" ]
CommandMatchers:
- Command: weather
  Regex: '(?i:weather (?:in|for) (.+))'
DEFCONFIG

command = ARGV.shift()

case command
when "configure"
	puts defaultConfig
	exit
when "weather"
    location = ARGV.shift()
    location += ",#{ENV["DEFAULT_COUNTRY"]}" unless location.include?(',')
    uri = URI("http://api.openweathermap.org/data/2.5/weather?q=#{location}&units=#{ENV["TEMP_UNITS"]}&APPID=#{ENV["OWM_APIKEY"]}")
    d = JSON::parse(Net::HTTP.get(uri))
    if d["message"]
        bot.Say("Sorry: \"#{d["message"]}\", maybe try the zip code?")
    else
        w = d["weather"][0]
        t = d["main"]
        bot.Say("The weather in #{d["name"]} is currently \"#{w["description"]}\" and #{t["temp"]} degrees, with a forecast low of #{t["temp_min"]} and high of #{t["temp_max"]}")
    end
end
</file_content file: gopherbot-main/plugins/weather.rb>
<preamble file: gopherbot-main/plugins/welcome.sh>

</preamble>
<file_content file: gopherbot-main/plugins/welcome.sh>
#!/bin/bash

# welcome.sh - let the default robot greet the user

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

if [ "$command" == "configure" ]
then
    exit 0
fi

# Note that this plugin is only active when unconfigured and proto == terminal.
if [ "$command" == "init" ]
then
    Pause 1
    for REQUIRED in jq git ssh
    do
        if ! which $REQUIRED &>/dev/null
        then
            SendChannelMessage "general" "***ERROR***: Missing required '$REQUIRED' executable!"
            AddTask robot-quit
            exit 0
        fi
    done
    NAME=$(GetBotAttribute "name")
    SendChannelMessage "general" "*******"
    SendChannelMessage "general" "Welcome to the *Gopherbot* terminal connector. Since no \
configuration was detected, you're connected to '$NAME', the default robot."
    Pause 2
    ALIAS=$(GetBotAttribute "alias" | tr -d '\0')
    SendChannelMessage "general" "If you've started the robot by mistake, just hit ctrl-D \
to exit and try 'gopherbot --help'; otherwise feel free to play around with the default robot - \
you can start by typing 'help'. If you'd like to start configuring a new robot, \
type: '${ALIAS}setup slack'."
    exit 0
fi
</file_content file: gopherbot-main/plugins/welcome.sh>
<preamble file: gopherbot-main/resources/README.md>

</preamble>
<file_content file: gopherbot-main/resources/README.md>
## Gopherbot Resources

* `deploy-gopherbot.yaml` - for deploying to Kubernetes with `kubectl apply ...`; see comments in file
* `robot.service` - sample Gopherbot unit file for systemd
* `user-robot.service` - sample Gopherbot unit file for running as a user systemd service (as your user)
* `userdaemon.te` - update for SELinux to allow Gopherbot to run as a normal user; see comments in file (possibly outdated)
* `docker/` - Dockerfiles and Makefiles for creating Gopherbot Docker Images
   * `docker/Makefile` - Makefile with examples for starting dev and prod containers
   * `docker/*/` - Makefiles and Dockerfiles for container images
</file_content file: gopherbot-main/resources/README.md>
<preamble file: gopherbot-main/resources/answerfiles/slack.txt>

</preamble>
<file_content file: gopherbot-main/resources/answerfiles/slack.txt>
## Note on commenting conventions:
## - Double hash (##) lines are documentation that can be deleted if desired,
##   but shouldn't be un-commented
## - Single hash (#) lines are examples of valid values
## - Uncommented lines should be modified and populated with values specific
##   to your robot
##
## Note on generated strings:
## Several values will accept a lowercase 'g' to generate a random string of
## the required length. This algorithm merely reads a few random bytes from
## /dev/random and spits out the base64-encoded value.
##
## Note on the contents of this file:
## Take care not to commit this file to a git repository. If you want to save
## the contents it should be kept in a safe place, like on a USB key or
## Chromebook local storage.
##
## * SETUP PROTOCOL: leave this value as-is. It's used by the setup process
##   to interpret the rest of this file.
##
## leave this as-is, used by the setup process
  ANS_PROTOCOL=slack
##
## * ENCRYPTION KEY: A thirty-two character key to be kept outside of any
##   git repository. Your robot will use this key to unlock the
##   `binary-encrypted-key` in your robot's repository, which the robot uses
##   to decrypt other secrets. Use 'g' to generate a random one.
##
# ANS_ENCRYPTION_KEY=g
# ANS_ENCRYPTION_KEY=GretFilllLterbRounwn8-v]CarpeDie
  ANS_ENCRYPTION_KEY=
##
## * APP and BOT TOKEN: The authentication tokens your robot will need to
##   connect to your team chat. Refer to the manual for generating these:
##   https://lnxjedi.github.io/gopherbot/botsetup/slacksock.html
##
# ANS_SLACK_APP_TOKEN=xapp-1234568-abcdefghijklmnop-qrstuvwxyzABCDEFG1234567thistokenisprettydangedlongforsure
  ANS_SLACK_APP_TOKEN=
# ANS_SLACK_BOT_TOKEN=xoxb-1234568-abcdefghijklmnop-qrstuvwxyzABCDEFG1234567
  ANS_SLACK_BOT_TOKEN=
##
## * ROBOT NAME: The given name that your robot will recognize. To get your
##   robot's attention it should be sufficient to start a command with e.g. a
##   '@mention', but for maximum compatibility and portability to other chat
##   platforms, your robot will always look for messages addressed to them;
##   for example 'floyd, ping'.
##
# ANS_ROBOT_NAME=Floyd
  ANS_ROBOT_NAME=
##
## * ROBOT ALIAS: A one-character alias your robot will also recognize as 
##   it's name, chosen from this list: '!;-%~*+^\$?[]{}'. You'll probably
##   use this most often for sending messages to your robot, as it's the most
##   concise; e.g. ';ping'.
##
## NOTE NOTE NOTE: This value should be single-quoted.
##
# ANS_ROBOT_ALIAS=';'
  ANS_ROBOT_ALIAS=''
##
## * JOB CHANNEL: Your robot will likely run scheduled jobs periodically; for
##   instance to back up it's long-term memories, or rotate a log file. Any
##   output from these jobs will go to a default job channel for your robot.
##   If you don't expect your robot to run a lot of jobs, it's safe to use e.g.
##   'general'. If you create a new channel for this purpose, be sure and
##   invite your robot to the channel when it first connects. A common
##   convention for this is "<robotname>-jobs"
##
# ANS_JOB_CHANNEL=general
# ANS_JOB_CHANNEL=floyd-jobs
  ANS_JOB_CHANNEL=
##
## * ROBOT EMAIL: An email address for your robot to use; it'll be used in the
##   'from:' when it sends email (configured separately), and also for git
##   commits. If you don't have a machine user configured for your robot, or a
##   separate email account for your robot, you can use your own email address.
##
# ANS_ROBOT_EMAIL=clu@example.com
# ANS_ROBOT_EMAIL=joe@example.com
  ANS_ROBOT_EMAIL=
##
## * ROBOT SSH PHRASE: Your robot will make heavy use of 'ssh' for doing it's
##   work, and it's private keys will be encrypted. Supply a passphrase
##   your robot can use, at least 16 characters: [0-9A-Za-z_+/-]. Use 'g' to
##   generate a random one.
##
# ANS_SSH_PHRASE=g
# ANS_SSH_PHRASE=0123456789012345
  ANS_SSH_PHRASE=
##
## * KEY_TYPE: Set this value to generate ssh keypairs of the desired type.
##   The default 'rsa' is the most common, you can also use 'dsa', 'ecdsa',
##   or 'ed25519'
##
# ANS_KEY_TYPE=dsa
# ANS_KEY_TYPE=ecdsa
# ANS_KEY_TYPE=ed25519
  ANS_KEY_TYPE=
##
## * ROBOT REPOSITORY: The standard for Gopherbot robots is to store all
##   of a robot's configuration and scripts in a single git repository
##   that can be bootstrapped in to a generic Gopherbot container or VM
##   to deploy your robot. This value should be a clone URL for your
##   robot's repository using ssh credentials. This repository should be
##   created empty, without any README, LICENSE, or other files. The
##   'save' job performs a simple 'git push' without any fancy
##   pull/rebase logic.
##
# ANS_ROBOT_REPOSITORY=git@github.com:parsley42/clu-gopherbot.git
# ANS_ROBOT_REPOSITORY=ssh://git@git.linuxjedi.org/robots/hal-gopherbot.git
  ANS_ROBOT_REPOSITORY=
##
## * ROBOT ADMIN SECRET: When your new robot first connects to the team chat,
##   it won't recognize you as an administrator since your robot doesn't yet
##   have access to the unique internal ID that your team chat assigns. Supply
##   a shared secret so you can use the 'add admin xxxx' command in a DM to
##   your robot, which will then update the robot's configuration. This should
##   be at least 8 characters ([0-9A-Za-z_+/-]), or use 'g' to generate a
##   random one.
##
# ANS_ADMIN_SECRET=g
# ANS_ADMIN_SECRET=LoveMyNewRobot
  ANS_ADMIN_SECRET=
##
## Now that you've populated all the values, save this file and run
## 'gopherbot' from the directory where this file is saved. The setup
## process will read this file and generate your robot's custom configuration
## in a 'custom/' sub-directory, then provide instructions for adding
## yourself as a robot administrator, completing setup, and saving your
## robot's configuration to it's git repository.
</file_content file: gopherbot-main/resources/answerfiles/slack.txt>
<preamble file: gopherbot-main/resources/aws/sqs-webhook.yaml>

</preamble>
<file_content file: gopherbot-main/resources/aws/sqs-webhook.yaml>
---
# https://xxx.execute-api.us-east-1.amazonaws.com/prod/v1/enqueue
Description: API Gateway integration with SQS
Outputs:
  ApiEndpoint:
    Description: Webook URL
    Value: !Join
      - ''
      - - https://
        - !Ref 'APIGateway'
        - .execute-api.
        - !Ref 'AWS::Region'
        - .amazonaws.com/
        - queue/
        - !Ref 'endpointID'
  QueueArnSQS:
    Description: ARN of SQS Queue
    Value: !GetAtt 'DestQueue.Arn'
  AccessPolicy:
    Description: Name of policy for robot access to queue
    Value: !Join
    - ''
    - - !Ref 'AWS::Region'
      - '-'
      - !Ref 'queueName'
      - '-access'
Parameters:
  queueName:
    Description: The name of the SQS queue to create.
    Type: String
  endpointID:
    Description: A random identifier for the enpoint URL.
    Type: String
Resources:
  APIGateway:
    Properties:
      Description: Webhook for queueing git builds to sqs
      Name: APIGateway
    Type: AWS::ApiGateway::RestApi
  APIGatewayRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - apigateway.amazonaws.com
        Version: '2012-10-17'
      Path: /
      Policies:
        - PolicyDocument:
            Statement:
              - Action: sqs:SendMessage
                Effect: Allow
                Resource: !GetAtt 'DestQueue.Arn'
            Version: '2012-10-17'
          PolicyName: apig-sqs-send-msg-policy
      RoleName: apig-sqs-send-msg-role
    Type: AWS::IAM::Role
  DestQueue:
    Properties:
      DelaySeconds: 0
      MaximumMessageSize: 262144
      MessageRetentionPeriod: 604800 # 1 week
      QueueName: !Ref 'queueName'
      ReceiveMessageWaitTimeSeconds: 0
      VisibilityTimeout: 7200 # 2 hours
    Type: AWS::SQS::Queue
  RobotPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties: 
      Description: Policy allowing robot to access queue
      ManagedPolicyName: !Join
      - ''
      - - !Ref 'AWS::Region'
        - '-'
        - !Ref 'queueName'
        - '-access'
      PolicyDocument:
        Statement:
        - Action: SQS:*
          Effect: Allow
          Resource: !GetAtt 'DestQueue.Arn'
          Sid: Sid1517269801413
        Version: '2012-10-17'
  PostMethod:
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      Integration:
        Credentials: !GetAtt 'APIGatewayRole.Arn'
        IntegrationHttpMethod: POST
        IntegrationResponses:
          - StatusCode: '200'
        PassthroughBehavior: NEVER
        RequestParameters:
          integration.request.header.Content-Type: '''application/x-www-form-urlencoded'''
        RequestTemplates:
          application/json: Action=SendMessage&MessageBody=$input.body
        Type: AWS
        Uri: !Join
          - ''
          - - 'arn:aws:apigateway:'
            - !Ref 'AWS::Region'
            - :sqs:path/
            - !Ref 'AWS::AccountId'
            - /
            - !Ref 'queueName'
      MethodResponses:
        - ResponseModels:
            application/json: Empty
          StatusCode: '200'
      ResourceId: !Ref 'enqueueResource'
      RestApiId: !Ref 'APIGateway'
    Type: AWS::ApiGateway::Method
  enqueueResource:
    Properties:
      ParentId: !GetAtt 'APIGateway.RootResourceId'
      PathPart: !Ref 'endpointID'
      RestApiId: !Ref 'APIGateway'
    Type: AWS::ApiGateway::Resource
  prodDeployment:
    DependsOn: PostMethod
    Properties:
      RestApiId: !Ref 'APIGateway'
    Type: AWS::ApiGateway::Deployment
  prodStage:
    Properties:
      DeploymentId: !Ref 'prodDeployment'
      RestApiId: !Ref 'APIGateway'
      StageName: build
    Type: AWS::ApiGateway::Stage
</file_content file: gopherbot-main/resources/aws/sqs-webhook.yaml>
<preamble file: gopherbot-main/resources/containers/archive/build-all.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/build-all.sh>
#!/bin/bash

for IMAGE in minimal theia dev
do
    docker build -f $IMAGE/Containerfile -t quay.io/lnxjedi/gopherbot-$IMAGE:latest $IMAGE/
done

</file_content file: gopherbot-main/resources/containers/archive/build-all.sh>
<preamble file: gopherbot-main/resources/containers/archive/dev/Containerfile>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/dev/Containerfile>
FROM quay.io/lnxjedi/gopherbot-base-theia:latest

USER root

ADD gopherbot-linux-amd64.tar.gz /opt

RUN chown nobody /opt/gopherbot/gopherbot && \
  chmod u+s /opt/gopherbot/gopherbot

# Tiny little init
RUN cd / && \
  curl -s -L -o dinit \
    $(curl --silent https://api.github.com/repos/lnxjedi/dinit/releases/latest | jq -r .assets[0].browser_download_url) && \
  chmod 755 dinit

# Numeric for Kubernetes runAsNonRoot
USER ${ROBOT_UID}:${ROBOT_UID}

EXPOSE 3000
ENTRYPOINT [ "/dinit", "-r", "ssh-agent", "node", "/usr/local/theia/src-gen/backend/main.js", "/var/lib/robot", "--hostname=0.0.0.0" ]
</file_content file: gopherbot-main/resources/containers/archive/dev/Containerfile>
<preamble file: gopherbot-main/resources/containers/archive/dev/build.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/dev/build.sh>
#!/bin/bash

docker build -f Containerfile -t quay.io/lnxjedi/gopherbot-dev:latest ../../..
</file_content file: gopherbot-main/resources/containers/archive/dev/build.sh>
<preamble file: gopherbot-main/resources/containers/archive/dev/run-robot.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/dev/run-robot.sh>
#!/bin/bash

if [ ! "$1" ]
then
    echo "Missing required argument <path/to/env>"
    exit 1
fi

docker run --rm -p=127.0.0.1:3000:3000 --env-file=$1 --name gopherbot-dev quay.io/lnxjedi/gopherbot-dev:latest
</file_content file: gopherbot-main/resources/containers/archive/dev/run-robot.sh>
<preamble file: gopherbot-main/resources/containers/archive/dev/run.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/dev/run.sh>
#!/bin/bash

docker run --rm -p=127.0.0.1:3000:3000 --name gopherbot-dev quay.io/lnxjedi/gopherbot-dev:latest
</file_content file: gopherbot-main/resources/containers/archive/dev/run.sh>
<preamble file: gopherbot-main/resources/containers/archive/minimal/Containerfile>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/minimal/Containerfile>
FROM quay.io/lnxjedi/gopherbot-base:latest

USER root

ADD gopherbot-linux-amd64.tar.gz /opt

RUN chown nobody /opt/gopherbot/gopherbot && \
  chmod u+s /opt/gopherbot/gopherbot

# Numeric for Kubernetes runAsNonRoot
USER ${ROBOT_UID}:${ROBOT_UID}

ENTRYPOINT [ "/opt/gopherbot/gopherbot" , "-plainlog" ]
</file_content file: gopherbot-main/resources/containers/archive/minimal/Containerfile>
<preamble file: gopherbot-main/resources/containers/archive/minimal/build.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/minimal/build.sh>
#!/bin/bash

docker build -f Containerfile -t quay.io/lnxjedi/gopherbot:latest ../../..
</file_content file: gopherbot-main/resources/containers/archive/minimal/build.sh>
<preamble file: gopherbot-main/resources/containers/archive/minimal/run-robot.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/minimal/run-robot.sh>
#!/bin/bash

if [ ! "$1" ]
then
    echo "Missing required argument <path/to/env>"
    exit 1
fi

docker run -it --rm --env-file=$1 --name gopherbot-min quay.io/lnxjedi/gopherbot:latest
</file_content file: gopherbot-main/resources/containers/archive/minimal/run-robot.sh>
<preamble file: gopherbot-main/resources/containers/archive/minimal/run.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/minimal/run.sh>
#!/bin/bash

docker run -it --rm --name gopherbot-min quay.io/lnxjedi/gopherbot:latest
</file_content file: gopherbot-main/resources/containers/archive/minimal/run.sh>
<preamble file: gopherbot-main/resources/containers/archive/theia/Containerfile>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/theia/Containerfile>
FROM quay.io/lnxjedi/gopherbot-base-theia:latest

USER root

ADD gopherbot-linux-amd64.tar.gz /opt

RUN chown nobody /opt/gopherbot/gopherbot && \
  chmod u+s /opt/gopherbot/gopherbot

WORKDIR ${HOME}

# Numeric for Kubernetes runAsNonRoot
USER ${ROBOT_UID}:${ROBOT_UID}

EXPOSE 3000
# In the gopherbot-theia image, theia runs as a gopherbot job
ENTRYPOINT [ "/opt/gopherbot/gopherbot" , "-plainlog" ]
</file_content file: gopherbot-main/resources/containers/archive/theia/Containerfile>
<preamble file: gopherbot-main/resources/containers/archive/theia/build.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/theia/build.sh>
#!/bin/bash

docker build -f Containerfile -t quay.io/lnxjedi/gopherbot-theia:latest ../../..
</file_content file: gopherbot-main/resources/containers/archive/theia/build.sh>
<preamble file: gopherbot-main/resources/containers/archive/theia/run-robot.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/theia/run-robot.sh>
#!/bin/bash

if [ ! "$1" ]
then
    echo "Missing required argument <path/to/env>"
    exit 1
fi

docker run -it --rm -p=127.0.0.1:3000:3000 --env-file=$1 --name gopherbot-theia quay.io/lnxjedi/gopherbot-theia:latest
</file_content file: gopherbot-main/resources/containers/archive/theia/run-robot.sh>
<preamble file: gopherbot-main/resources/containers/archive/theia/run.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/archive/theia/run.sh>
#!/bin/bash

docker run -it --rm --name gopherbot-theia quay.io/lnxjedi/gopherbot-theia:latest
</file_content file: gopherbot-main/resources/containers/archive/theia/run.sh>
<preamble file: gopherbot-main/resources/containers/assets/dev-init>

</preamble>
<file_content file: gopherbot-main/resources/containers/assets/dev-init>
check-load-ssh(){
    [ ! -e $HOME/.ssh/id_ssh ] && return
    if ! ssh-add -l >/dev/null && [ -e $HOME/.ssh/id_ssh ]
    then
        echo "Loading ssh private key ..."
        ssh-add $HOME/.ssh/id_ssh
    fi
    if ssh-add -l >/dev/null && [ -e $HOME/.ssh/id_ssh ]
    then
        echo "Removing ssh private key ..."
        rm -f $HOME/.ssh/id_ssh
    fi
}
check-clone-robot(){
    if [ "$GOPHER_DEPLOY_KEY" -a "$GOPHER_CUSTOM_REPOSITORY" -a ! -e ~/custom ]
    then
        echo "Cloning $GOPHER_CUSTOM_REPOSITORY to ~/custom ..."
        echo $GOPHER_DEPLOY_KEY | tr ':_' '\n ' > /tmp/decoded_key.pem
        chmod 600 /tmp/decoded_key.pem
        GIT_SSH_COMMAND="ssh -i /tmp/decoded_key.pem -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" \
            git clone $GOPHER_CUSTOM_REPOSITORY ~/custom
        rm -f /tmp/decoded_key.pem
    fi
}
check-load-botkey(){
    ssh-add -l > /dev/null && return
    if [ "$SSH_AUTH_SOCK" == "/ssh-agent" ]
    then
        echo -e "\n***WARNING***: ssh forwarding set but no key loaded! Run 'ssh-add' on the host?"
        return
    fi
    ENCRYPTED_KEY=$(grep -A3 '"manage_key"' ~/custom/conf/robot.yaml | sed -n 's/.*decrypt "\(.*\)" }}.*/\1/p')
    echo "Loading robot's manage_key with encrypted passphrase ($ENCRYPTED_KEY) ..."
    NAMED_PIPE=$(mktemp -u)
    mkfifo $NAMED_PIPE
    SSH_ASKPASS_SCRIPT=$(mktemp)
    chmod +x $SSH_ASKPASS_SCRIPT
    echo "cat $NAMED_PIPE" > $SSH_ASKPASS_SCRIPT
    export SSH_ASKPASS=$SSH_ASKPASS_SCRIPT
    export DISPLAY=:0
    chmod 0600 ~/custom/ssh/manage_key
    ssh-add ~/custom/ssh/manage_key < /dev/null &
    SSH_ADD_PID=$!
    gopherbot decrypt "$ENCRYPTED_KEY" > $NAMED_PIPE
    wait $SSH_ADD_PID
    rm -f $NAMED_PIPE
    rm -f $SSH_ASKPASS_SCRIPT
}
# ssh-agent in shell sessions
if [ ! "$SSH_AUTH_SOCK" ]
then
    export SSH_AUTH_SOCK=$(echo /tmp/ssh-*/*)
    export SSH_AGENT_PID=$(pgrep ssh-agent)
fi
check-load-ssh
check-clone-robot
check-load-botkey
source $HOME/.git-completion.bash
source $HOME/.git-prompt.sh
PATH=${PATH}:/opt/gopherbot:${HOME}/go/bin:${HOME}/.local/bin
GIT_PS1_SHOWUPSTREAM="auto"
GIT_PS1_SHOWDIRTYSTATE="true"
GIT_PS1_SHOWSTASHSTATE="true"
GIT_PS1_SHOWUNTRACKEDFILES="true"
PS1='[\[\033[01;34m\]${GOPHER_IDE%-dev}:\[\033[01;32m\]\w\[\033[01;34m\]$(__git_ps1 "(%s)")\[\033[00m\]]\$ \[\]\[\]'
</file_content file: gopherbot-main/resources/containers/assets/dev-init>
<preamble file: gopherbot-main/resources/containers/assets/gitconfig>

</preamble>
<file_content file: gopherbot-main/resources/containers/assets/gitconfig>
[pull]
	ff = only
</file_content file: gopherbot-main/resources/containers/assets/gitconfig>
<preamble file: gopherbot-main/resources/containers/assets/gopherbot.code-workspace>

</preamble>
<file_content file: gopherbot-main/resources/containers/assets/gopherbot.code-workspace>
{
    "folders": [
        {
            "path": "/home/bot"
        },
        {
            "path": "/opt/gopherbot"
        },
        {
            "path": "/opt/gopherbot-doc"
        }
    ],
    "settings": {
        "search.exclude": {
            "/.cache": true,
            "/.openvscode*": true,
            "/go/pkg": true
        }
    }
}
</file_content file: gopherbot-main/resources/containers/assets/gopherbot.code-workspace>
<preamble file: gopherbot-main/resources/containers/build-base.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/build-base.sh>
#!/bin/bash

docker pull docker.io/amazonlinux:2023
docker build -f containerfile.base -t ghcr.io/lnxjedi/gopherbot-base:latest .
</file_content file: gopherbot-main/resources/containers/build-base.sh>
<preamble file: gopherbot-main/resources/containers/build-dev.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/build-dev.sh>
#!/bin/bash

if [ "$1" -o ! -d tmp ]
then
    rm -rf tmp
    mkdir tmp
    git clone git@github.com:lnxjedi/gopherbot.git tmp/gopherbot
    git clone git@github.com:lnxjedi/gopherbot-doc.git tmp/gopherbot-doc
fi

#docker pull ghcr.io/lnxjedi/gopherbot-base:latest
docker build -f containerfile.dev -t ghcr.io/lnxjedi/gopherbot-dev:latest .
</file_content file: gopherbot-main/resources/containers/build-dev.sh>
<preamble file: gopherbot-main/resources/containers/build-min.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/build-min.sh>
#!/bin/bash

## Normally run in sequence - base, dev, min
# docker pull ghcr.io/lnxjedi/gopherbot-dev:latest
# docker pull docker.io/amazonlinux:2023
docker build -f containerfile.min -t ghcr.io/lnxjedi/gopherbot:latest .
</file_content file: gopherbot-main/resources/containers/build-min.sh>
<preamble file: gopherbot-main/resources/containers/containerfile.base>

</preamble>
<file_content file: gopherbot-main/resources/containers/containerfile.base>
FROM docker.io/amazonlinux:2023

#######
#
# containerfile.base - base container build for Gopherbot development
# and running production Robots built from Gopherbot. Automatically built
# every week.
# See also: containerfile.dev
#
#######

ARG OVSC_ORG="gitpod-io"
ARG OPENVSCODE_SERVER_ROOT="/home/.openvscode-server"
ARG USERNAME=bot
ARG USER_UID=1001
ARG USER_GID=$USER_UID

# EPEL 7
RUN curl -o epel.rpm https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm && \
    rpm -i --nodeps epel.rpm && \
    rm -f epel.rpm

RUN dnf install -y \
        bash-completion \
        gcc \
        git-core \
        gzip \
        jq \
        less \
        libyaml-devel \
        make \
        openssh-clients \
        openssl \
        procps-ng \
        python3-pip \
        python3-devel \
        ruby \
        ruby-devel \
        tar \
        telnet \
        tini \
        which \
    && \
  	dnf clean all && \
  	rm -rf /var/cache/yum

# NOTE: My little bit of research indicated rpdb would probably be easiest
# to use for Python script debugging in Gopherbot. If you're a pythonista
# and want to make a case for, say, debugpy - I'd be happy to chat with you.
RUN gem install -N debug && \
    pip install setuptools wheel && \
    pip install rpdb

WORKDIR /home/

# Downloading the latest VSC Server release and extracting the release archive
# Rename `openvscode-server` cli tool to `code` for convenience
RUN OVSC_LATEST=$(curl --silent https://api.github.com/repos/${OVSC_ORG}/openvscode-server/releases/latest | jq -r .tag_name) && \
    arch=$(uname -m) && \
    if [ "${arch}" = "x86_64" ]; then \
        arch="x64"; \
    elif [ "${arch}" = "aarch64" ]; then \
        arch="arm64"; \
    elif [ "${arch}" = "armv7l" ]; then \
        arch="armhf"; \
    fi && \
    curl -s -L -o ${OVSC_LATEST}-linux-${arch}.tar.gz https://github.com/${OVSC_ORG}/openvscode-server/releases/download/${OVSC_LATEST}/${OVSC_LATEST}-linux-${arch}.tar.gz && \
    tar -xzf ${OVSC_LATEST}-linux-${arch}.tar.gz && \
    mv -f ${OVSC_LATEST}-linux-${arch} ${OPENVSCODE_SERVER_ROOT} && \
    cp ${OPENVSCODE_SERVER_ROOT}/bin/remote-cli/openvscode-server ${OPENVSCODE_SERVER_ROOT}/bin/remote-cli/code && \
    rm -f ${OVSC_LATEST}-linux-${arch}.tar.gz

RUN cd /usr/local && \
    GO_LATEST=$(curl --silent https://go.dev/VERSION?m=text | head -1) && \
    curl -s -L -o go.tar.gz https://dl.google.com/go/${GO_LATEST}.linux-amd64.tar.gz && \
    tar xzf go.tar.gz && \
    rm -f go.tar.gz

RUN MDBOOK_LATEST=$(curl --silent https://api.github.com/repos/rust-lang/mdBook/releases/latest | jq -r .tag_name) && \
    curl -s -L -o mdbook.tar.gz https://github.com/rust-lang/mdBook/releases/download/${MDBOOK_LATEST}/mdbook-${MDBOOK_LATEST}-x86_64-unknown-linux-gnu.tar.gz && \
    tar xzf mdbook.tar.gz && \
    install -m 0755 mdbook /usr/local/bin && \
    rm -f mdbook mdbook.tar.gz

# Creating the user and usergroup
RUN groupadd --gid $USER_GID $USERNAME \
    && useradd --uid $USER_UID --gid $USERNAME -m -s /bin/bash $USERNAME

RUN chmod g+rw /home && \
    chown -R $USERNAME:$USERNAME ${OPENVSCODE_SERVER_ROOT}

# For kubernetes
USER ${USER_UID}:${USER_GID}

# Install language extensions
RUN /home/.openvscode-server/bin/openvscode-server --install-extension golang.Go && \
    /home/.openvscode-server/bin/openvscode-server --install-extension rebornix.ruby && \
    /home/.openvscode-server/bin/openvscode-server --install-extension ms-python.python

WORKDIR /home/${USERNAME}

ENV LANG=C.UTF-8 \
    LC_ALL=C.UTF-8 \
    EDITOR=code \
    VISUAL=code \
    GIT_EDITOR="code --wait" \
    OPENVSCODE_SERVER_ROOT=${OPENVSCODE_SERVER_ROOT} \
    HOME=/home/${USERNAME} \
    PATH=/usr/local/go/bin:${PATH}:${HOME}/go/bin:${HOME}/.local/bin

RUN go install -v golang.org/x/tools/gopls@latest && \
    go install -v github.com/cweill/gotests/gotests@v1.6.0 && \
    go install -v github.com/fatih/gomodifytags@v1.16.0 && \
    go install -v github.com/josharian/impl@v1.1.0 && \
    go install -v github.com/haya14busa/goplay/cmd/goplay@v1.0.0 && \
    go install -v github.com/go-delve/delve/cmd/dlv@latest && \
    go install -v honnef.co/go/tools/cmd/staticcheck@latest && \
    go install -v golang.org/x/tools/gopls@latest

EXPOSE 7777

ENTRYPOINT [ "/usr/bin/tini", "--", "/bin/sh", "-c", "exec ${OPENVSCODE_SERVER_ROOT}/bin/openvscode-server --host 0.0.0.0 --port 7777 \"${@}\"", "--" ]
</file_content file: gopherbot-main/resources/containers/containerfile.base>
<preamble file: gopherbot-main/resources/containers/containerfile.dev>

</preamble>
<file_content file: gopherbot-main/resources/containers/containerfile.dev>
ARG base_org=lnxjedi

FROM ghcr.io/${base_org}/gopherbot-base:latest

#######
# containerfile.dev
# For daily builds of a gopherbot development container with up-to-date sources.
#######

ARG USERNAME=bot

WORKDIR /home/${USERNAME}
RUN curl -o .git-completion.bash https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash && \
    curl -o .git-prompt.sh https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh

COPY --chown=${USERNAME}:${USERNAME} tmp/gopherbot/ /opt/gopherbot/
COPY --chown=${USERNAME}:${USERNAME} tmp/gopherbot-doc/ /opt/gopherbot-doc/
COPY --chown=${USERNAME}:${USERNAME} assets/gopherbot.code-workspace /home/${USERNAME}/gopherbot.code-workspace
COPY --chown=${USERNAME}:${USERNAME} assets/dev-init /home/${USERNAME}/.dev-init
COPY --chown=${USERNAME}:${USERNAME} assets/gitconfig /home/${USERNAME}/.gitconfig

RUN echo "source /home/${USERNAME}/.dev-init" >> /home/${USERNAME}/.bashrc && \
    mkdir -p /home/${USERNAME}/.ssh && \
    chmod 0700 /home/${USERNAME}/.ssh && \
    cd /opt/gopherbot-doc && \
    sed -i -e '/\[http/,+1d' .git/config && \
    cd /opt/gopherbot && \
    sed -i -e '/\[http/,+1d' .git/config && \
    make

# Note: PATH for dev gets set in assets/dev-init
ENV RUBYLIB=/opt/gopherbot/lib:/home/${USERNAME}/custom/lib \
    GEM_HOME=/home/${USERNAME}/.local \
    PYTHONPATH=/opt/gopherbot/lib:/home/${USERNAME}/custom/lib \
    GOPHER_INSTALLDIR=/opt/gopherbot

ENTRYPOINT [ "/usr/bin/tini", "--", "/usr/bin/ssh-agent", "/bin/sh", "-c", "exec ${OPENVSCODE_SERVER_ROOT}/bin/openvscode-server --host 0.0.0.0 --port 7777 \"${@}\"", "--" ]
</file_content file: gopherbot-main/resources/containers/containerfile.dev>
<preamble file: gopherbot-main/resources/containers/containerfile.min>

</preamble>
<file_content file: gopherbot-main/resources/containers/containerfile.min>
FROM ghcr.io/lnxjedi/gopherbot-dev:latest as build

#######
#
# containerfile.min - minimal container for running a Gopherbot robot.
#
#######

RUN cd /opt/gopherbot && \
  git remote set-url origin $(git config --get remote.origin.url | sed 's/git@github\.com:/https:\/\/github.com\//') && \
  git pull && \
  git pull --tags && \
  GOPHER_LATEST=$(git describe --tags `git rev-list --tags='v*' --max-count=1`) && \
  git checkout ${GOPHER_LATEST} && \
  make clean && \
  make dist && \
  cd /tmp && \
  tar xzvf /opt/gopherbot/gopherbot-linux-amd64.tar.gz

FROM docker.io/amazonlinux:2023

# Enough stuff to run bash, python, and ruby extensions and install requirements
RUN dnf install -y \
        gcc \
        git-core \
        gzip \
        jq \
        make \
        openssh-clients \
        python3-pip \
        python3-devel \
        ruby \
        ruby-devel \
        tar \
        which \
    && \
  	dnf clean all && \
  	rm -rf /var/cache/yum

# These seem to be base requirements for a variety of other python modules
RUN pip install setuptools wheel

ENV ROBOT_UID=994
ENV SHELL=/bin/bash
ENV HOME=/home/bot
ENV PATH=$PATH:${HOME}/bin:${HOME}/.local/bin:/opt/gopherbot
ENV RUBYLIB=/opt/gopherbot/lib
ENV GEM_HOME=${HOME}/.local
ENV PYTHONPATH=/opt/gopherbot/lib

RUN useradd -d ${HOME} -r -c "Gopherbot Robot" -u ${ROBOT_UID} robot && \
  mkdir -p ${HOME} && \
  chown robot:robot ${HOME} && \
  chmod 0755 ${HOME}

COPY --from=build /tmp/gopherbot /opt/gopherbot

# USER root
# RUN cd /opt/gopherbot && \
#     ./setuid-nobody.sh

USER ${ROBOT_UID}:${ROBOT_UID}

WORKDIR ${HOME}

ENTRYPOINT [ "/opt/gopherbot/gopherbot" ]
</file_content file: gopherbot-main/resources/containers/containerfile.min>
<preamble file: gopherbot-main/resources/containers/remove.sh>

</preamble>
<file_content file: gopherbot-main/resources/containers/remove.sh>
#!/bin/bash -e

# remove.sh - shortcut for docker stop, docker remove

if [ $# -ne 1 ]
then
    echo "Usage: ./remove.sh <name>"
    exit 1
fi

docker stop $1 >/dev/null && docker rm $1 >/dev/null
echo "Removed"
</file_content file: gopherbot-main/resources/containers/remove.sh>
<preamble file: gopherbot-main/resources/deploy-gopherbot.yaml>

</preamble>
<file_content file: gopherbot-main/resources/deploy-gopherbot.yaml>
---
# deploy-gopherbot.yaml - For deploying a Gopherbot Robot to your Kubernetes
# cluster manually with `kubectl`. The "better" way is to use helm 3 with the
# chart in `helm-gopherbot`.
#
# Manual steps:
# 1) Verify GOPHER_ENCRYPTION_KEY, GOPHER_DEPLOY_KEY and GOPHER_PROTOCOL
#    are all defined (and uncommented) in your .env
# 2) Verify the image you want in "image: ..." below
# 3) kubectl create secret generic robot-secrets --from-env-file=.env
# 4) kubectl apply -f deploy-gopherbot.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: gopherbot
  name: gopherbot
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gopherbot
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: gopherbot
    spec:
      securityContext:
        runAsNonRoot: true
      containers:
      - image: quay.io/lnxjedi/gopherbot:latest
        name: gopherbot
        env:
          - name: GOPHER_ENCRYPTION_KEY
            valueFrom:
              secretKeyRef:
                name: robot-secrets
                key: GOPHER_ENCRYPTION_KEY
          - name: GOPHER_CUSTOM_REPOSITORY
            valueFrom:
              secretKeyRef:
                name: robot-secrets
                key: GOPHER_CUSTOM_REPOSITORY
          - name: GOPHER_DEPLOY_KEY
            valueFrom:
              secretKeyRef:
                name: robot-secrets
                key: GOPHER_DEPLOY_KEY
          - name: GOPHER_PROTOCOL
            valueFrom:
              secretKeyRef:
                name: robot-secrets
                key: GOPHER_PROTOCOL
</file_content file: gopherbot-main/resources/deploy-gopherbot.yaml>
<preamble file: gopherbot-main/resources/helm-gopherbot/.helmignore>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/.helmignore>
# Patterns to ignore when building packages.
# This supports shell glob matching, relative path matching, and
# negation (prefixed with !). Only one pattern per line.
.DS_Store
# Common VCS dirs
.git/
.gitignore
.bzr/
.bzrignore
.hg/
.hgignore
.svn/
# Common backup files
*.swp
*.bak
*.tmp
*.orig
*~
# Various IDEs
.project
.idea/
*.tmproj
.vscode/
</file_content file: gopherbot-main/resources/helm-gopherbot/.helmignore>
<preamble file: gopherbot-main/resources/helm-gopherbot/Chart.yaml>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/Chart.yaml>
apiVersion: v2
name: gopherbot
description: A Helm chart for installing a Gopherbot robot to your Kubernetes cluster
type: application

# This is the chart version. This version number should be incremented each time you make changes
# to the chart and its templates, including the app version.
# Versions are expected to follow Semantic Versioning (https://semver.org/)
version: 0.1.1
appVersion: "v2.0.0-beta3"
</file_content file: gopherbot-main/resources/helm-gopherbot/Chart.yaml>
<preamble file: gopherbot-main/resources/helm-gopherbot/LICENSE>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/LICENSE>
Copyright 2020 David L. Parsley, <parsley@linuxjedi.org>

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
</file_content file: gopherbot-main/resources/helm-gopherbot/LICENSE>
<preamble file: gopherbot-main/resources/helm-gopherbot/README.md>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/README.md>
# Gopherbot Helm Chart

This helm chart can be used to deploy your **Gopherbot** robot to your Kubernetes cluster. This README was written for helm3.

Before using this chart you should have already created a **Gopherbot** robot with an associated git repository, along with a `.env` file for bootstrapping your robot.

You can deploy your robot with this helm chart with two basic steps:
1. Store your robot's secrets in the target namespace using the `.env`
2. Deploy the robot with a helm values file

The values file should have no sensitive data, and could be stored in source control management.

## Generating and Storing Your Robot's Secrets

The first step is to store your robot's sensitive data in a secret in the robot's target namespace. You can use the included `generate-secret.sh` script, like so:
```
$ ./resources/helm-gopherbot/generate-secret.sh robot-secrets ~/robot/.env | kubectl -n robot apply -f -
secret/robot-secrets created
```

## Creating your Robot's Values File

The second step is configuring your robot. Make a copy of `resources/helm-gopherbot/values.yaml` and edit it. Most items can be removed, but you may wish to set a value for the `robotDataVolume` if you want your robot to have a persistent data volume. Since `gopherbot` runs non-root, you should probably also set `fsGroup` in the `podSecurityContext`, so the mount will be writeable.

For example:
```yaml
robotDataVolume:
  persistentVolumeClaim:
    claimName: robot-pvc

podSecurityContext:
  fsGroup: 1 # "daemon"
```

If you're going to have multiple robots in a single namespace, you should override the values for secrets and fullname; using `clu` as an example:
```yaml
robotDataVolume:
  persistentVolumeClaim:
    claimName: clu-pvc

robotSecrets: clu-secrets

fullnameOverride: clu-gopherbot
```

## Deploying Your Robot with Helm

Then, to deploy your robot to your cluster (using `clu` as an example):
```
$ helm install clu ./helm-gopherbot --values=clu-values.yaml
NAME: clu
LAST DEPLOYED: Tue Jun  2 14:27:55 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
[parse@joshu clu]$ k get deployments.apps 
NAME             READY   UP-TO-DATE   AVAILABLE   AGE
clu-gopherbot    0/1     1            0           10s
...
```
</file_content file: gopherbot-main/resources/helm-gopherbot/README.md>
<preamble file: gopherbot-main/resources/helm-gopherbot/generate-secret.sh>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/generate-secret.sh>
#!/bin/bash

# generate-secret.sh - generate the secrets for your robot from a .env

usage(){
    echo "Usage:"
    echo "$ ./generate-secret.sh <name> <env file>"
    exit 1
}

if [ $# -ne 2 ]
then
    usage
fi

SECNAME="$1"
EFILE="$2"

if [ ! -f $EFILE ]
then
    usage
fi

kubectl create secret generic $SECNAME --from-env-file $EFILE --dry-run=client -o yaml
</file_content file: gopherbot-main/resources/helm-gopherbot/generate-secret.sh>
<preamble file: gopherbot-main/resources/helm-gopherbot/templates/_helpers.tpl>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/templates/_helpers.tpl>
{{/* vim: set filetype=mustache: */}}
{{/*
Expand the name of the chart.
*/}}
{{- define "gopherbot.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
If release name contains chart name it will be used as a full name.
*/}}
{{- define "gopherbot.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "gopherbot.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "gopherbot.labels" -}}
helm.sh/chart: {{ include "gopherbot.chart" . }}
{{ include "gopherbot.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "gopherbot.selectorLabels" -}}
app.kubernetes.io/name: {{ include "gopherbot.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "gopherbot.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "gopherbot.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}
</file_content file: gopherbot-main/resources/helm-gopherbot/templates/_helpers.tpl>
<preamble file: gopherbot-main/resources/helm-gopherbot/templates/deployment.yaml>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/templates/deployment.yaml>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "gopherbot.fullname" . }}
  labels:
    {{- include "gopherbot.labels" . | nindent 4 }}
spec:
  replicas: 1
  selector:
    matchLabels:
      {{- include "gopherbot.selectorLabels" . | nindent 6 }}
  strategy:
    type: Recreate
  template:
    metadata:
    {{- with .Values.podAnnotations }}
      annotations:
        {{- toYaml . | nindent 8 }}
    {{- end }}
      labels:
        {{- include "gopherbot.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      volumes:
      - name: robot-home
        {{- toYaml .Values.robotDataVolume | nindent 8 }}
      initContainers:
      - name: {{ .Chart.Name }}-fsinit
        securityContext:
          runAsUser: 0
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default "latest" }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        command:
        - /bin/bash
        args:
        - "-c"
        - "chown robot:robot /home/robot && chmod 0755 /home/robot"
        volumeMounts:
        - mountPath: /home/robot
          name: robot-home
      containers:
      - name: {{ .Chart.Name }}
        securityContext:
          {{- toYaml .Values.securityContext | nindent 10 }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default "latest" }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        volumeMounts:
        - mountPath: /home/robot
          name: robot-home
        resources:
          {{- toYaml .Values.resources | nindent 10 }}
        env:
        - name: GOPHER_ENCRYPTION_KEY
          valueFrom:
            secretKeyRef:
              name: {{ .Values.robotSecrets }}
              key: GOPHER_ENCRYPTION_KEY
        - name: GOPHER_CUSTOM_REPOSITORY
          valueFrom:
            secretKeyRef:
              name: {{ .Values.robotSecrets }}
              key: GOPHER_CUSTOM_REPOSITORY
        - name: GOPHER_DEPLOY_KEY
          valueFrom:
            secretKeyRef:
              name: {{ .Values.robotSecrets }}
              key: GOPHER_DEPLOY_KEY
        - name: GOPHER_PROTOCOL
          valueFrom:
            secretKeyRef:
              name: {{ .Values.robotSecrets }}
              key: GOPHER_PROTOCOL
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
</file_content file: gopherbot-main/resources/helm-gopherbot/templates/deployment.yaml>
<preamble file: gopherbot-main/resources/helm-gopherbot/values.yaml>

</preamble>
<file_content file: gopherbot-main/resources/helm-gopherbot/values.yaml>
# Default values for gopherbot.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: quay.io/lnxjedi/gopherbot
  pullPolicy: Always
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # runAsNonRoot: true
  # fsGroup: 2000

robotDataVolume: {}
  # emptyDir: {}

robotSecrets: robot-secrets

# Applies to the main container
securityContext:
  runAsNonRoot: true
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsUser: 1000

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

nodeSelector: {}

tolerations: []

affinity: {}
</file_content file: gopherbot-main/resources/helm-gopherbot/values.yaml>
<preamble file: gopherbot-main/resources/heroku/Dockerfile>

</preamble>
<file_content file: gopherbot-main/resources/heroku/Dockerfile>
FROM quay.io/lnxjedi/gopherbot:latest
ENTRYPOINT [ "/opt/gopherbot/gopherbot" ]
CMD [ "-plainlog" ]
</file_content file: gopherbot-main/resources/heroku/Dockerfile>
<preamble file: gopherbot-main/resources/heroku/README.md>

</preamble>
<file_content file: gopherbot-main/resources/heroku/README.md>
# Deploying Gopherbot to Heroku

> NOTE: This is somewhat experimental. This README is mostly to just record the steps taken to deploy a **Gopherbot** robot. If it turns out to be a good solution, it will eventually become a chapter section in the online manual.

## Requirements

This document assumes you already have a [Heroku](https://heroku.com) account and the [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli) installed. Note that at the time of this writing, a personal unverified Heroku account gives you 550 dyno hours per month - not enough to run a full-time robot. Verifying the account by adding a credit card gives an additional 450 hours.

You should have already set up your robot, and have an environment file (e.g. `.env`) with all the `GOPHER_*` vars.

The steps assume you have the gopherbot dist archive unzipped in `/opt/gopherbot`; if not, grab the contents of `github.com/lnxjedi/gopherbot/resources/heroku` and stick it somewhere convenient.

## Steps

In this brief tutorial I'll be setting up my `clu` robot with a Heroku app name of `linux-jedi-clu`.

1. Create the app:
```
$ heroku apps:create linux-jedi-clu
Creating  linux-jedi-clu... done
https://linux-jedi-clu.herokuapp.com/ | https://git.heroku.com/linux-jedi-clu.git
```

2. Set config vars using `resources/heroku/heroku-app-vars.sh`:
```
$ /opt/gopherbot/resources/heroku/heroku-app-vars.sh linux-jedi-clu
Using '.env' for env vars ...
Setting GOPHER_ENCRYPTION_KEY and restarting  linux-jedi-clu... done, v3
GOPHER_ENCRYPTION_KEY: <redacted>
Setting GOPHER_CUSTOM_REPOSITORY and restarting  linux-jedi-clu... done, v4
GOPHER_CUSTOM_REPOSITORY: git@github.com:parsley42/clu-gopherbot.git
Setting GOPHER_PROTOCOL and restarting  linux-jedi-clu... done, v5
GOPHER_PROTOCOL: slack
Setting GOPHER_DEPLOY_KEY and restarting  linux-jedi-clu... done, v6
GOPHER_DEPLOY_KEY: -----BEGIN_OPENSSH_PRIVATE_KEY-----:<redacted ...>
```

3. Copy the trivial Heroku Dockerfile to your current directory and edit if desired (to e.g. add extra tools/libraries):
```
$ cp /opt/gopherbot/resources/heroku/Dockerfile .
```

4. Build and push your worker container to heroku:
```
$ heroku container:push worker -a linux-jedi-gopherbot
=== Building worker (/home/parse/clu/Dockerfile)
Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM quay.io/lnxjedi/gopherbot:latest
 ---> 59b05951b009
Step 2/3 : ENTRYPOINT [ "/opt/gopherbot/gopherbot" ]
 ---> Using cache
 ---> b8b13f6cb7c2
Step 3/3 : CMD [ "-plainlog" ]
 ---> Using cache
 ---> 85aa64b988cf
Successfully built 85aa64b988cf
Successfully tagged registry.heroku.com/linux-jedi-clu/worker:latest
=== Pushing worker (/home/parse/clu/Dockerfile)
The push refers to repository [registry.heroku.com/linux-jedi-clu/worker]
49b6043f8f8c: Layer already exists
173594a0ff26: Layer already exists
d20418061ae8: Layer already exists
ef9d19b874b3: Layer already exists
1c6efb4cbd71: Layer already exists
d4dfaa212623: Layer already exists
cba97cc5811c: Layer already exists
0c78fac124da: Layer already exists
latest: digest: sha256:7f4b81003365221653168c3c0217f29feabd997fe4b55e913e61fdc68b6fd69e size: 1995
Your image has been successfully pushed. You can now release it with the 'container:release' command.
```

5. When the command completes, release your worker container:
```
$ heroku container:release worker -a linux-jedi-clu
Releasing images worker to linux-jedi-clu... done
```

6. (Optional) To watch your robot starting up, you might want to open a new terminal and tail the logs for your app:
```
$ heroku logs -a linux-jedi-clu --tail
2021-03-31T19:34:20.122622+00:00 app[api]: Release v1 created by user parsley@linuxjedi.org
...
2021-03-31T20:04:22.777642+00:00 app[api]: Deployed worker (85aa64b988cf) by user parsley@linuxjedi.org
```

7. Scale your worker to 1:
```
$ heroku ps:scale worker=1 -a linux-jedi-clu
Scaling dynos... done, now running worker at 1:Free
```

With any luck, your robot will start up, clone it's repository, and connect to your team chat. Verified with my log tail:
```
2021-03-31T20:08:26.429427+00:00 app[api]: Scaled to worker@1:Free by user parsley@linuxjedi.org
2021-03-31T20:08:44.079472+00:00 heroku[worker.1]: Starting process with command `-plainlog`
2021-03-31T20:08:44.861112+00:00 heroku[worker.1]: State changed from starting to up
2021-03-31T20:08:46.777803+00:00 app[worker.1]: Initialized logging ...
...
2021-03-31T20:08:51.988977+00:00 app[worker.1]: Info: Initializing plugin: echo
2021-03-31T20:08:51.989011+00:00 app[worker.1]: Info: Robot is initialized and running
```
</file_content file: gopherbot-main/resources/heroku/README.md>
<preamble file: gopherbot-main/resources/heroku/heroku-app-vars.sh>

</preamble>
<file_content file: gopherbot-main/resources/heroku/heroku-app-vars.sh>
#!/bin/bash

# heroku-app-vars.sh - convenience script for configuring Gopherbot env vars.

usage(){
    echo "Usage: heroku-app-vars.sh <app-name> (path-to-env)"
    echo "  If '(path-to-env)' not specified, uses '.env'"
    exit 1
}

if [ "$#" -lt 1 ]
then
    echo "App name not given"
    usage
fi

export HEROKU_APP=$1

ENV_FILE=".env"
if [ "$2" ]
then
    ENV_FILE="$2"
fi

if [ ! -e "$ENV_FILE" ]
then
    echo "Environment file not found: $ENV_FILE"
    usage
fi

echo "Using '$ENV_FILE' for env vars ..."
source "$ENV_FILE"

for VAR in GOPHER_ENCRYPTION_KEY GOPHER_CUSTOM_REPOSITORY GOPHER_PROTOCOL GOPHER_DEPLOY_KEY
do
    heroku config:set $VAR="${!VAR}"
done
</file_content file: gopherbot-main/resources/heroku/heroku-app-vars.sh>
<preamble file: gopherbot-main/resources/robot.service>

</preamble>
<file_content file: gopherbot-main/resources/robot.service>
## Template for running your robot as a systemd service;
## remove these lines, edit for your robot, and copy to
## /etc/systemd/system/<robot-name>.service.
[Unit]
Description=<MyRobotName> - Gopherbot DevOps Chatbot
Documentation=https://lnxjedi.github.io/gopherbot
After=syslog.target
After=network.target

[Service]
Type=simple
## Update with the user/group for this robot
User=<robot>
Group=<robot>
## Place the robot's ".env" file in the WorkingDirectory,
## owned by the User, mode r-------- (0400).
WorkingDirectory=/home/robots/<my-robot-home>
ExecStart=/opt/gopherbot/gopherbot -plainlog 
Restart=on-failure
## Change "slack" if needed
Environment=GOPHER_PROTOCOL=slack HOSTNAME=%H

KillMode=process
## Give the robot plenty of time to finish plugins currently executing;
## no new plugins will start after SIGTERM is caught.
TimeoutStopSec=600

[Install]
WantedBy=default.target
</file_content file: gopherbot-main/resources/robot.service>
<preamble file: gopherbot-main/resources/slack/appmanifest.yaml>

</preamble>
<file_content file: gopherbot-main/resources/slack/appmanifest.yaml>
# See: https://api.slack.com/reference/manifests
_metadata:
  major_version: 1
  minor_version: 1
display_information:
  name: Clu Gopherbot
  description: Clu tries all the new, dangerous and/or breaking changes to Gopherbot.
features:
  app_home:
    home_tab_enabled: false
    messages_tab_enabled: true
    messages_tab_read_only_enabled: false
  bot_user:
    display_name: Clu Gopherbot
    always_online: false
  slash_commands:
    - command: /clu
      description: Provides access to Clu's hidden commands
      should_escape: false
oauth_config:
  scopes:
    # See: https://api.slack.com/scopes
    bot:
      - app_mentions:read
      - channels:history
      - channels:join
      - channels:read
      - chat:write
      - chat:write.public
      - commands
      - groups:history
      - groups:read
      - groups:write
      - im:history
      - im:read
      - im:write
      - links:read
      - mpim:history
      - mpim:read
      - mpim:write
      - users.profile:read
      - users:read
      - users:read.email
      - users:write
settings:
  event_subscriptions:
    bot_events:
      - message.channels
      - message.groups
      - message.im
      - message.mpim
  interactivity:
    is_enabled: false
  org_deploy_enabled: false
  socket_mode_enabled: true
  is_hosted: false
</file_content file: gopherbot-main/resources/slack/appmanifest.yaml>
<preamble file: gopherbot-main/resources/user-robot.service>

</preamble>
<file_content file: gopherbot-main/resources/user-robot.service>
## Template for running your robot as a systemd user service;
## remove these lines, edit for your robot, and copy to
## $HOME/.config/systemd/user/<robot-name>.service.
[Unit]
Description=<MyRobotName> - Gopherbot DevOps Chatbot
Documentation=https://lnxjedi.github.io/gopherbot
After=syslog.target
After=network.target

[Service]
Type=simple
## Place the robot's ".env" file in the WorkingDirectory,
## owned by your user, mode r-------- (0400).
WorkingDirectory=/home/<your-home>/<your-robot>
ExecStart=/opt/gopherbot/gopherbot -plainlog 
Restart=on-failure
## Change "slack" if needed
Environment=USER=<your-user> HOME=/home/<your-user>/<your-robot> GOPHER_PROTOCOL=slack HOSTNAME=%H

KillMode=process
## Give the robot plenty of time to finish plugins currently executing;
## no new plugins will start after SIGTERM is caught.
TimeoutStopSec=600

[Install]
WantedBy=default.target
</file_content file: gopherbot-main/resources/user-robot.service>
<preamble file: gopherbot-main/resources/userdaemon.te>

</preamble>
<file_content file: gopherbot-main/resources/userdaemon.te>
# Allow systemd to run a daemon as a user, for cases
# where gopherbot runs as a real/normal user
# To use:
# Compile to module with:
# $ checkmodule -M -m -o userdaemon.mod userdaemon.te
# Create the package with:
# $ semodule_package -o userdaemon.pp -m userdaemon.mod
# As root, load the package with:
# # semodule -i userdaemon.pp

module userdaemon 1.0;

require {
	type init_t;
	type user_home_t;
	type http_port_t;
	class tcp_socket { name_connect };
	class file { execute execute_no_trans open read };
}

#============= init_t ==============
allow init_t user_home_t:file execute_no_trans;
allow init_t user_home_t:file { execute open read };
allow init_t http_port_t:tcp_socket name_connect;
</file_content file: gopherbot-main/resources/userdaemon.te>
<preamble file: gopherbot-main/robot.skel/README.md>

</preamble>
<file_content file: gopherbot-main/robot.skel/README.md>
# Gopherbot New Robot Default Configuration

This directory holds the default **Gopherbot** configuration for new robots created with the autosetup plugin. It might be useful to periodically check for changes on [Github](https://github.com/lnxjedi/gopherbot/tree/main/robot.skel) for any updates to the base configuration.
</file_content file: gopherbot-main/robot.skel/README.md>
<preamble file: gopherbot-main/robot.skel/conf/jobs/logrotate.yaml>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/jobs/logrotate.yaml>
---
Quiet: true
</file_content file: gopherbot-main/robot.skel/conf/jobs/logrotate.yaml>
<preamble file: gopherbot-main/robot.skel/conf/jobs/updatecfg.yaml.sample>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/jobs/updatecfg.yaml.sample>
---
## Example trigger - when the robot see's its configuration has been
## udpated, it'll trigger this job to automatically update the repository
## and reload.
# Triggers:
# - User: github
#   Channel: ljdev
#   Regex: 'new commit.*parsley42/clu-gopherbot/tree/master'
</file_content file: gopherbot-main/robot.skel/conf/jobs/updatecfg.yaml.sample>
<preamble file: gopherbot-main/robot.skel/conf/plugins/builtin-totp.yaml>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/plugins/builtin-totp.yaml>
---
# Config:
  ## How long elevation lasts
  # TimeoutSeconds: 7200
  ## When 'idle', the timer resets on every elevated command
  # TimeoutType: idle # or absolute
  ## Encrypted user codes
  # Users:
  # - User: "david"
  #   Secret: "<encrypted secret>" (generate with 'gopherbot gentotp david')
</file_content file: gopherbot-main/robot.skel/conf/plugins/builtin-totp.yaml>
<preamble file: gopherbot-main/robot.skel/conf/plugins/citools.yaml.sample>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/plugins/citools.yaml.sample>
---
## Channels where a user can type `build <foo>`
# Channels:
# - clu-jobs
# - ljdev
</file_content file: gopherbot-main/robot.skel/conf/plugins/citools.yaml.sample>
<preamble file: gopherbot-main/robot.skel/conf/plugins/duo.yaml>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/plugins/duo.yaml>
---
## Configuration for Duo two-factor authentication. If your organization uses
## Duo, you can obtain an IKey, SKey and Host for use with the auth api.
# Disabled: false
# Config:
## How long elevation lasts
#   TimeoutSeconds: 7200
## When 'idle', the timer resets on every elevated command
#   TimeoutType: idle # or absolute
#   DuoIKey: replace with encrypted string
#   DuoSKey: replace with encrypted string
#   DuoHost: replace with your duo host
#   DuoUserString: email
</file_content file: gopherbot-main/robot.skel/conf/plugins/duo.yaml>
<preamble file: gopherbot-main/robot.skel/conf/plugins/example.yaml.sample>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/plugins/example.yaml.sample>
---
## Example plugin configuration file showing most configurable items.

## NOTE: If you're modifying the configuration of an existing Gopherbot
## plugin, configured items merge with the default config, and arrays are
## replaced. To add e.g. Help entries, copy the original help entries and
## then add your own.

## Compiled-in go plugins can be disabled
Disabled: false
## When true, this plugin can be activated by direct message. Normally
## plugins can only be used in a given channel for auditing/transparency.
AllowDirect: true
## On the other hand, some plugins may need sensitive information that should
## only be available in a direct message.
DirectOnly: false
## For robots with many plugins, it's useful to have some that are only
## available in certain channels. Maybe the bug search plugin is only available
## in the #bugfixing channel
Channels: [ "aws", "golang" ]
## Some plugins, like 'ping', are nice to have in all channels
AllChannels: false
## Most plugins that are limited to certain users will have an explicit list
## of allowed users, but a plugin can also be configured for Administrators
## only. Gopherbot may eventually get a more granular permissions system
## if needed, but for now none is planned.
RequireAdmin: false
## To limit access to a plugin to specific users, list there usernames
Users: [ "alice", "bob", "carol" ]
## You can require users to be members of a group
Authorizer: groups
## For groups, the AuthRequire is the name of the group
AuthRequire: monkeys
## When help <keyword> is requested, the robot will spit out the items in
## Helptext. By convention, commands that must be directed at the robot
## start with "(bot),"
Help:
- Keywords: [ "open", "pod" ]
  Helptext:
  - (bot), open the pod bay doors - Opens the doors to the pod bay, if you're in space
# - (bot), <some command> - <description of what the command does>
## Command matches can be matched when the user addresses the robot directly,
## either in a direct message, or by giving it's name or alias. The Regex
## is a Go regular expression, easily developed by using the tool at:
## https://regex-golang.appspot.com/assets/html/index.html
CommandMatchers:
- Regex: '(?i:(?:search|find)(?: metadata)? ([.\w-]+))'
  Command: search
- Regex: '(?i:open the pod bay doors)'
  Command: open
## If a plugin wants to specify custom matchers for the WaitForReply API
## call, they can be specified here. In this case, the "Command" is just
## a tag identifying the specific matcher in the call; it should be all
## lower-case to avoid conflict with built-in reply matchers
ReplyMatchers:
- Regex: '\(\d\d\d\)\d\d\d-\d\d\d\d'
  Command: phone
## Message matches should be used sparingly, and are mostly useful for
## joke plugins; e.g. responding with a Chuck Norris anecdote whenever
## you mention his name. These will match against every message the robot
## hears (subject to user, channel and other restrictions).
MessageMatchers:
- Regex: '(?i:.*Chuck Norris.*)'
  Command: chuck
## CatchAll plugins are called when someone speaks directly to the robot, but
## no command is matched. Mainly used by the builtin help plugin.
CatchAll: false
## For plugins that require custom configuration (such as credentials for the
## memes plugin), that information can be supplied here. The top-level
## structure should be a hash/map, similar to this file
Config:
  Username: foo
  Password: bar
  CatchPhrases:
  - "Hasta la vista, baby"
  - "Go ahead, make my day"
  - "I'll buy THAT for a dollar!"
</file_content file: gopherbot-main/robot.skel/conf/plugins/example.yaml.sample>
<preamble file: gopherbot-main/robot.skel/conf/repositories.yaml.sample>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/repositories.yaml.sample>
## repositories.yaml - Gopherbot's list of repositories that are valid for extending
## the namespace. Example:
# "github.com/lnxjedi/gopherbot":
#   Type: localbuild
#   CloneURL: https://github.com/lnxjedi/gopherbot.git
#   KeepLogs: 14
#   Parameters:
#   - Name: NOTIFY_USER
#     Value: parsley
</file_content file: gopherbot-main/robot.skel/conf/repositories.yaml.sample>
<preamble file: gopherbot-main/robot.skel/conf/robot.yaml>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/robot.yaml>
# AdminContact: "Joe Admin, <joe@my.org>"

## "BIG HAMMER" security - if IgnoreUnlistedUsers is set, your
## robot will drop all messages from users that don't appear in the
## UserRoster.
# IgnoreUnlistedUsers: true

## Configure the robot connection protocol; modifying this could
## break `gopherbot -t`
{{ $proto := env "GOPHER_PROTOCOL" | default "terminal" }}
Protocol: {{ $proto }}

## Include protocol-specific configuration
{{ printf "%s.yaml" $proto | .Include }}

{{ $botname := env "GOPHER_BOTNAME" | default "<botname>" }}
{{ $botemail := env "GOPHER_BOTMAIL" | default "<botemail>" }}
{{ $botfullname := env "GOPHER_BOTFULLNAME" | default "<botfullname>" }}
{{ $botalias := env "GOPHER_ALIAS" | default "<botalias>" }}

BotInfo:
  UserName: {{ $botname }}
  Email: {{ $botemail }}
  FullName: {{ $botfullname }}
  FirstName: {{ $botname }}
  LastName: Gopherbot

Alias: '{{ $botalias }}'

# Brain configuration; this can all be replaced with static configuration
# and encrypted secrets for most robots.
{{ $brain := env "GOPHER_BRAIN" | default "file" }}
{{ $statedir := env "GOPHER_STATEDIR" | default "state" }}
{{ $defbraindir := printf "%s/brain" $statedir }}
Brain: {{ $brain }}
#EncryptBrain: true # default
{{ if eq $brain "file" }}
BrainConfig:
  BrainDirectory: {{ env "GOPHER_BRAIN_DIRECTORY" | default $defbraindir }}
  Encode: true
{{ else if eq $brain "dynamo" }}
BrainConfig:
  TableName: "your table name here"
  Region: {{ env "GOPHER_BRAIN_REGION" | default "us-east-1" }}
  AccessKeyID: "replace with encrypted value"
  SecretAccessKey: "replace with encrypted value"
{{ end }}
# End brain config

# Defaults for history and workspace directories, relative to the
# process working directory.
{{ $histdir := env "GOPHER_HISTORYDIR" | default "history" }}
{{ $workdir := env "GOPHER_WORKSPACE" | default "workspace" }}
{{ if $workdir -}} WorkSpace: {{ $workdir }} {{- end }}

## Configure a history provider
{{ $history := env "GOPHER_HISTORY_PROVIDER" | default "file" }}
HistoryProvider: {{ $history }}

{{ if eq $history "file" }}
HistoryConfig:
  Directory: {{ $histdir }}
  ## LocalPort here is the full string passed in to ListenAndServe(...)
  #LocalPort: ':9000' # Start http fileserver
  #URLPrefix: 'http://localhost:9000'
{{ end }}
## End history config

## If the plugin doesn't specify an outgoing message format, what's the default?
## This will be 'Raw' (unmodified, subject to protocol-specific formatting) if
## not set. 'Variable' will escape special characters like #, @, _, `, etc. so
## those characters can appear in replies. 'Fixed' will send everything in a
## fixed-width font.
# DefaultMessageFormat: Variable # 'Raw' if not specified

ExternalJobs:
#   "hello":
#     Description: Trivial hello world job for testing
#     Path: jobs/hello.sh
#     Privileged: true
#     Parameters:
#     - Name: NONCE
#       Value: "No way, Jack!"

## Most often you don't want your robot to run scheduled jobs
## with the "terminal" connector, normally used for testing and
## development.
{{ if ne $proto "terminal" }}
## Jobs are scheduled with github.com/robfig/cron; includes seconds.
## Note that pause-notifies and backup are scheduled by default in
## a standard robot.
ScheduledJobs:
- Name: pause-notifies
  Schedule: "0 0 8 * * *"
{{ if eq $brain "file" }}
- Name: backup
  Schedule: "@every 1m"
{{ end }}
## If you have a Gemfile or requirements.txt, you can install library
## dependencies with this init job.
# - Name: install-libs
#   Schedule: "@init"
## If your robot is logging to a file, this job will rotate logs
# - Name: logrotate
#   Schedule: "5 0 0 * * *"
## Example with arguments
# - Name: hello
#   Schedule: "@every 30s"
#   Arguments: # an array of strings; up to the job to parse numbers & bools
#   - "Hello, World !!!"
{{ end }}

## After adding an initial administrator, you should disable the setup
## plugin by uncommenting the next three lines.
ExternalPlugins:
{{ if env "GOPHER_SETUP_TOKEN" }}
  "addadmin":
    Description: Setup plugin allowing an initial administrator to be added
    Path: plugins/addadmin.sh
    Privileged: true
    Homed: true
    Parameters:
    - Name: GOPHER_SETUP_TOKEN
      Value: {{ env "GOPHER_SETUP_TOKEN" }}
{{ end }}
#   "weather":
#     Description: A plugin that uses OpenWeatherMap to report the weather
#     Path: plugins/weather.rb
#     Parameters:
#     - Name: OWM_APIKEY
#       Value: replace with encrypted string
#     - Name: TEMP_UNITS
#       Value: {{ env "GOPHER_OWM_UNITS" | default "imperial" }} # or 'metric'
#     - Name: DEFAULT_COUNTRY
#       Value: {{ env "GOPHER_OWM_COUNTRY" | default "us" }} # or other ISO 3166 country code
#   "chuck":
#     Description: A plugin that pipes up whenever The Man's name is mentioned
#     Path: plugins/chuck.rb
#   "echo":
#     Description: Trivial bash plugin
#     Path: plugins/echo.sh
#   "pythondemo":
#     Description: Sample python plugin
#     Path: plugins/samples/pythondemo.py

## Note that modules for connectors, brains and history providers load automatically
# LoadableModules:
#   "knock":
#     Description: Knock knock jokes!
#     Path: goplugins/knock.so
#   "memes":
#     Description: Memes!
#     Path: goplugins/meme.so

NameSpaces:
  "ssh":
    Parameters:
    - Name: "KEYNAME"
      Value: "robot_key"
    - Name: BOT_SSH_PHRASE
      Value: {{ decrypt "<sshencrypted>" }}
  "manage":
    # The default standard config defines a bunch of pass-through env vars,
    # so here we use AppendParameters
    AppendParameters:
    - Name: "KEYNAME"
      Value: "manage_key"
    - Name: BOT_SSH_PHRASE
      Value: {{ decrypt "<sshencrypted>" }}

DefaultMessageFormat: Raw
# Users the bot should never listen to
#IgnoreUsers: [ "otherbot", "slackbot" ]

## Configuration for sending out email. For Authtype: none, User and Password
## can be left out. Note that sending email will fail if Email isn't set. Note
## for GMail users - for your robot to send email, you'll need to enable less
## secure apps for the sending account. See:
## https://support.google.com/accounts/answer/6010255

# MailConfig:
#   Mailhost: smtp.gmail.com:587
#   Authtype: plain
#   User: clu@linuxjedi.org
#   Password: replace with encrypted string

## Use Google Authenticator TOTP by default for elevated commands. To use:
## - Ask the robot to 'send launch codes', and it will send you (one time)
##   a string for configuring your Google Authencticator app, and store it's
##   own copy in the robot's brain. You can verify it works with the
##   'check launch code <code>' command.
## - To require a token to be provided before running a given plugin command,
##   add the elevated command(s) to the plugin's ElevatedCommands list, or to
##   ElevateImmediateCommands for commands that require elevation every time
##   regardless of timeout.
## - Configure the elevator by overriding the config for the plugin in
##   'conf/plugins/totp.yaml'

# DefaultElevator: builtin-totp
</file_content file: gopherbot-main/robot.skel/conf/robot.yaml>
<preamble file: gopherbot-main/robot.skel/conf/rocket.yaml>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/rocket.yaml>
## NOTE: Support for Rocket.Chat is new, feel free to create an issue
## if you try it out and have problems.

# UserRoster:
## Floyd is the production robot that builds gopherbot
# - UserName: floyd
#   UserID: U138KTVCL
#   BotUser: true
# - UserName: parsley
#   UserID: U0JLW8EMS

AdminUsers: [ "<GOPHER_ADMIN>" ]
ProtocolConfig:
  Server: "<GOPHER_ROCKET_SERVER>"
  Email: "<GOPHER_ROCKET_EMAIL>"
  Password: {{ decrypt "<GOPHER_ROCKET_PASSWORD>" }}
</file_content file: gopherbot-main/robot.skel/conf/rocket.yaml>
<preamble file: gopherbot-main/robot.skel/conf/slack.yaml>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/slack.yaml>
AdminUsers: [ "<adminusername>" ]
ProtocolConfig:
  MaxMessageSplit: {{ env "GOPHER_SLACK_MAX_MSGS" | default "2" }}
  AppToken: xapp-{{ decrypt "<slackappencrypted>" }}
  BotToken: xoxb-{{ decrypt "<slackbotencrypted>" }}
  HearSelf: false

DefaultChannels: [ "general", "random" ]

UserRoster:
  - UserName: <adminusername>
    UserID: <adminuserid>
  - UserName: <botname>
    UserID: <botid>
    BotUser: true
  # - UserName: floyd
  #   UserID: U138KTVCL
  #   BotUser: true
        
{{ $defaultjobchannel := "<jobchannel>" }}
DefaultJobChannel: {{ env "GOPHER_JOBCHANNEL" | default $defaultjobchannel }}
</file_content file: gopherbot-main/robot.skel/conf/slack.yaml>
<preamble file: gopherbot-main/robot.skel/conf/terminal.yaml>

</preamble>
<file_content file: gopherbot-main/robot.skel/conf/terminal.yaml>
## The terminal connector can mirror the actual team/users/channels for
## devel. See the installed `terminal.yaml`
## (normally in /opt/gopherbot/conf/terminal.yaml) for a full example.
ProtocolConfig:
  EOF: '<botalias>quit'
  Abort: '<botalias>abort'
  HearSelf: false # set true for the robot to hear it's own messages
  BotName: '<botname>'
AppendUserRoster:
- UserName: '<botname>'
  UserID: 'u0000'
  BotUser: true
</file_content file: gopherbot-main/robot.skel/conf/terminal.yaml>
<preamble file: gopherbot-main/robot.skel/git/config>

</preamble>
<file_content file: gopherbot-main/robot.skel/git/config>
# This is Git's per-user configuration file.
[user]
# Please adapt and uncomment the following lines:
	name = <botfullname>
	email = <botemail>
[push]
	default = simple
[pull]
	rebase = true
</file_content file: gopherbot-main/robot.skel/git/config>
<preamble file: gopherbot-main/robot.skel/jobs/hello.sh>

</preamble>
<file_content file: gopherbot-main/robot.skel/jobs/hello.sh>
#!/bin/bash -e

# jobs/hello.sh - the first Gopherbot scheduled job

# NOTE: this sample job uses the bot library, most jobs probably won't
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

PHRASE=$1

if Exclusive "world" "true"
then
    Say "Hooray! I get to run! $GOPHER_CALLER_ID"
else
    Say "Darn, I have to wait. $GOPHER_CALLER_ID"
    exit 0
fi
ls -Fla ..
head /etc/group >&2

FailTask dmnotify parsley "Your trivial hello world job failed"

Log "Info" "I said $PHRASE and $NONCE"

AddTask pause-brain
AddTask say "I've paused my brain !!"
AddTask exec sleep 3
AddTask resume-brain
AddTask say "$PHRASE / $NONCE - now I'll restart!"
AddTask restart-robot
</file_content file: gopherbot-main/robot.skel/jobs/hello.sh>
<preamble file: gopherbot-main/robot.skel/jobs/logrotate.sh>

</preamble>
<file_content file: gopherbot-main/robot.skel/jobs/logrotate.sh>
#!/bin/bash

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

OLD="log.$(date +%a)"
AddTask "rotate-log" "$OLD"
</file_content file: gopherbot-main/robot.skel/jobs/logrotate.sh>
<preamble file: gopherbot-main/robot.skel/plugins/echo.sh>

</preamble>
<file_content file: gopherbot-main/robot.skel/plugins/echo.sh>
#!/bin/bash -e

# echo.sh - trivial shell plugin example for Gopherbot

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat <<"EOF"
---
Help:
- Keywords: [ "repeat" ]
  Helptext: [ "(bot), repeat (me) - prompt for and trivially repeat a phrase" ]
- Keywords: [ "echo" ]
  Helptext: [ "(bot), echo <something> - tell the bot to say <something>" ]
CommandMatchers:
- Command: "repeat"
  Regex: '(?i:repeat( me)?)'
- Command: "echo"
  Regex: '(?i:echo (.*))'
EOF
}

case "$command" in
# NOTE: only "configure" should print anything to stdout
	"configure")
		configure
		;;
	"echo")
		Pause 1 # because the robot knows how to "type"
		Say "$1"
		;;
	"repeat")
		REPEAT=$(PromptForReply SimpleString "What do you want me to repeat?")
		RETVAL=$?
		if [ $RETVAL -ne $GBRET_Ok ]
		then
			Reply "Sorry, I had a problem getting your reply: $RETVAL"
		else
			Reply "$REPEAT"
		fi
		;;
esac
</file_content file: gopherbot-main/robot.skel/plugins/echo.sh>
<preamble file: gopherbot-main/robot.skel/ssh/config>

</preamble>
<file_content file: gopherbot-main/robot.skel/ssh/config>
# Put any custom ssh configuration for your robot here
</file_content file: gopherbot-main/robot.skel/ssh/config>
<preamble file: gopherbot-main/robot/LICENSE>

</preamble>
<file_content file: gopherbot-main/robot/LICENSE>
MIT License

Copyright (c) 2020 LinuxJedi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file_content file: gopherbot-main/robot/LICENSE>
<preamble file: gopherbot-main/robot/README.md>

</preamble>
<file_content file: gopherbot-main/robot/README.md>
Tiny library for writing *Gopherbot* Go extensions, see:
https://lnxjedi.github.io/gopherbot

Usage:
```go
import (
    "github.com/lnxjedi/gopherbot/robot"
)
...
```
</file_content file: gopherbot-main/robot/README.md>
<preamble file: gopherbot-main/robot/botdefs.go>

</preamble>
<file_content file: gopherbot-main/robot/botdefs.go>
// Package robot defines interfaces and constants for pluggable go modules
package robot

// RetVal is a integer type for returning error conditions from bot methods, or 0 for Ok
type RetVal int

//go:generate stringer -type=TaskRetVal botdefs.go

//go:generate stringer -type=RetVal botdefs.go

//go:generate stringer -type=Protocol botdefs.go

//go:generate stringer -type=MessageFormat botdefs.go

//go:generate stringer -type=LogLevel botdefs.go

// Generate String method with: go generate ./robot/

// LogLevel for determining when to output a log entry
type LogLevel int

// Definitions of log levels in order from most to least verbose
const (
	Trace LogLevel = iota
	Debug
	Info
	Audit // For plugins to emit auditable events
	Warn
	Error
	Fatal
)

// TaskRetVal is an integer type for return values from plugins, mainly for elevation & authorization
type TaskRetVal int

const (
	// Normal exit is for non-auth/non-elevating plugins; since this is the
	// default exit value, we don't use it to indicate successful authentication
	// or elevation.
	Normal TaskRetVal = iota
	// Fail indicates requested authorization or elevation failed
	Fail
	// MechanismFail indicates authorization or elevation couldn't be determined due to a technical issue that should be logged
	MechanismFail
	// ConfigurationError indicates authorization or elevation failed due to misconfiguration
	ConfigurationError
	// PipelineAborted - failed exclusive w/o queueTask
	PipelineAborted
	// RobotStopping - the robot is shutting down and can't start any new pipelines
	RobotStopping
	// NotFound - generic return value when the asked for item couldn't be returned
	NotFound
	// Success indicates successful authorization or elevation; using '7' (three bits set)
	// reduces the likelihood of an authorization plugin mistakenly exiting with a success
	// value
	Success = 7
)

const (
	// Ok indicates a successful result
	Ok RetVal = iota // success

	/* Connector issues */

	// UserNotFound - failed lookup
	UserNotFound
	// ChannelNotFound - failed lookup
	ChannelNotFound
	// AttributeNotFound - failed looking up user/robot attributes like email, name, etc.
	AttributeNotFound
	// FailedMessageSend - the bot was not able to send a message
	FailedMessageSend
	// FailedChannelJoin - the robot couldn't join a channel; e.g. slack doesn't allow bots to join
	FailedChannelJoin

	/* Brain Maladies */

	// DatumNotFound - key not found in the global hash when update called
	DatumNotFound
	// DatumLockExpired - A datum was checked out for too long, and the lock expired
	DatumLockExpired
	// DataFormatError - Problem unmarshalling JSON
	DataFormatError
	// BrainFailed - An error condition prevented the brain from storing/retrieving; redis down, file write failed, etc.
	BrainFailed
	// InvalidDatumKey - Key name didn't match the regex for valid key names
	InvalidDatumKey

	/* GetTaskConfig */

	// InvalidDblPtr - GetTaskConfig wasn't called with a double-pointer to a config struct
	InvalidDblPtr
	// InvalidCfgStruct - The struct type in GetTaskConfig doesn't match the struct registered for the plugin
	InvalidCfgStruct
	// NoConfigFound - The plugin/job doesn't have any config data
	NoConfigFound

	/* Prompt(User)ForReply */

	// RetryPrompt - There was already a prompt in progress for the user/channel
	RetryPrompt
	// ReplyNotMatched - The user reply didn't match the pattern waited for
	ReplyNotMatched
	// UseDefaultValue - The user replied with a single '=', meaning use a default value
	UseDefaultValue
	// TimeoutExpired - The user didn't reply within the given timeout
	TimeoutExpired
	// Interrupted - The user replied with '-' (cancel)
	Interrupted
	// MatcherNotFound - There was no matcher configured with the given string, or the regex didn't compile
	MatcherNotFound

	/* Email */

	// NoUserEmail - Couldn't look up the user's email address
	NoUserEmail
	// NoBotEmail - Couldn't look up the robot's email address
	NoBotEmail
	// MailError - There was an error sending email
	MailError

	/* Pipeline errors */

	// TaskNotFound - no task with the given name
	TaskNotFound
	// MissingArguments - AddTask requires a command and args for a plugin
	MissingArguments
	// InvalidStage - tasks can only be added when the robot is running primaryTasks
	InvalidStage
	// InvalidTaskType - mismatch of task/plugin/job method with provided name
	InvalidTaskType
	// CommandNotMatched - the command string didn't match a command for the plugin
	CommandNotMatched
	// TaskDisabled - a method call attempted to add a disabled task to a pipeline
	TaskDisabled
	// PrivilegeViolation - error adding a privileged job/command to an unprivileged pipeline
	PrivilegeViolation
)

// Protocol - connector protocols
type Protocol int

const (
	// Slack connector
	Slack Protocol = iota
	// Rocket for Rocket.Chat
	Rocket
	// Terminal connector
	Terminal
	// Test connector for automated test suites
	Test
	// Null connector for unconfigured robots
	Null
)

// MessageFormat indicates how the connector should display the content of
// the message. One of Variable, Fixed or Raw
type MessageFormat int

// Outgoing message format, Variable or Fixed
const (
	Raw MessageFormat = iota // protocol native, zero value -> default if not specified
	Fixed
	Variable
)
</file_content file: gopherbot-main/robot/botdefs.go>
<preamble file: gopherbot-main/robot/go.mod>

</preamble>
<file_content file: gopherbot-main/robot/go.mod>
module github.com/lnxjedi/gopherbot/robot

go 1.14
</file_content file: gopherbot-main/robot/go.mod>
<preamble file: gopherbot-main/robot/history.go>

</preamble>
<file_content file: gopherbot-main/robot/history.go>
package robot

import "io"

// HistoryLogger is provided by a HistoryProvider for each job / plugin run
// where it's requested
type HistoryLogger interface {
	// Log a line of output, normally timestamped; bot should prefix with OUT or ERR
	Log(line string)
	// Add a plain line to the log, without a timestamp
	Line(line string)
	// Close a log file against further writes, but keep
	Close()
	// Finalize called after pipeline finishes, log can be removed.
	Finalize()
}

// HistoryProvider is responsible for storing and retrieving job histories
type HistoryProvider interface {
	// NewLog provides a HistoryLogger for the given tag / index, and
	// cleans up logs older than maxHistories.
	NewLog(tag string, index, maxHistories int) (HistoryLogger, error)
	// GetLog gets an io.Reader() for a given history log
	GetLog(tag string, index int) (io.Reader, error)
	// GetLogURL provides a static URL for the history file if there is one
	GetLogURL(tag string, index int) (URL string, exists bool)
	// MakeLogURL publishes a log to a URL and returns the URL; this
	// URL need only be available for a short timespan, e.g. 42 seconds
	MakeLogURL(tag string, index int) (URL string, exists bool)
}
</file_content file: gopherbot-main/robot/history.go>
<preamble file: gopherbot-main/robot/interfaces.go>

</preamble>
<file_content file: gopherbot-main/robot/interfaces.go>
package robot

import "io"

// Logger is used by a Brain for logging errors
type Logger interface {
	Log(l LogLevel, m string, v ...interface{})
}

// SimpleBrain is the simple interface for a configured brain, where the robot
// handles all locking issues.
type SimpleBrain interface {
	// Store stores a blob of data with a string key, returns error
	// if there's a problem storing the datum.
	Store(key string, blob *[]byte) error
	// Retrieve returns a blob of data (probably JSON) given a string key,
	// and exists=true if the data blob was found, or error if the brain
	// malfunctions.
	Retrieve(key string) (blob *[]byte, exists bool, err error)
	// List returns a list of all memories - Gopherbot isn't a database,
	// so it _should_ be pretty short.
	List() (keys []string, err error)
	// Delete deletes a memory
	Delete(key string) error
}

// Handler is the interface that defines the API for the handler object passed
// to Connectors, history providers and brain providers.
type Handler interface {
	// IncomingMessage is called by the connector for all messages the bot
	// can hear. See the fields for ConnectorMessage for information about
	// this object.
	IncomingMessage(*ConnectorMessage)
	// GetProtocolConfig unmarshals the ProtocolConfig section of robot.yaml
	// into a connector-provided struct
	GetProtocolConfig(interface{}) error
	// GetBrainConfig unmarshals the BrainConfig section of robot.yaml
	// into a struct provided by the brain provider
	GetBrainConfig(interface{}) error
	// GetEventStrings for developing tests with the terminal connector
	GetEventStrings() *[]string
	// GetHistoryConfig unmarshals the HistoryConfig section of robot.yaml
	// into a struct provided by the brain provider
	GetHistoryConfig(interface{}) error
	// SetID allows the connector to set the robot's internal ID
	SetBotID(id string)
	// SetTerminalWriter allows the terminal connector to provide an io.Writer
	// to log to.
	SetTerminalWriter(io.Writer)
	// SetBotMention allows the connector to set the bot's @(mention) ID
	// (without the @) for protocols where it's a fixed value. This allows
	// the robot to recognize "@(protoMention) foo", needed for e.g. Rocket
	// where the robot username may not match the configured name.
	SetBotMention(mention string)
	// GetLogLevel allows the connector to check the robot's configured log level
	// to make it's own decision about how much it should log. For slack, this
	// determines whether the plugin does api logging.
	GetLogLevel() LogLevel
	// GetInstallPath returns the installation path of the gopherbot
	GetInstallPath() string
	// GetConfigPath returns the path to the config directory if set
	GetConfigPath() string
	// Log provides a standard logging interface with a level as defined in
	// bot/logging.go
	Log(l LogLevel, m string, v ...interface{})
	// GetDirectory lets infrastructure plugins create directories, for e.g.
	// file-based history and brain providers. When privilege separation is in
	// use, the directory is created with the privileged uid.
	GetDirectory(path string) error
	// ExtractID is a convenience function for connectors, keeps 'import "regexp"
	// out of robot.
	ExtractID(u string) (string, bool)
	// RaisePriv raises the privilege of the current thread, allowing
	// filesystem access in GOPHER_HOME. Reason is informational.
	RaisePriv(reason string)
}

// Connector is the interface defining methods that should be provided by
// the connector for use by bot
type Connector interface {
	// SetUserMap provides the connector with a map from usernames to userIDs,
	// the protocol-internal ID for a user. The connector can use this map
	// to replace @name mentions in messages, and/or build a map of userIDs
	// to configured usernames.
	SetUserMap(map[string]string)
	// GetProtocolUserAttribute retrieves a piece of information about a user
	// from the connector protocol, or "",!ok if the connector doesn't have the
	// information. Plugins should normally call GetUserAttribute, which
	// supplements protocol data with data from users.json.
	// The connector should expect "username" or "<userid>".
	// The current attributes are:
	// email, realName, firstName, lastName, phone, sms, connections
	GetProtocolUserAttribute(user, attr string) (value string, ret RetVal)
	// MessageHeard tells the connector that the user should be notified that
	// the message has been heard and is being responded to. The connector
	// can then e.g. send a typing notifier.
	MessageHeard(user, channel string)
	// FormatHelp takes a (bot)/(alias) (command) - (description) string, and
	// returns a protocol-specific string formatted for display in the protocol.
	FormatHelp(string) string
	// DefaultHelp allows a connector to override the default help lines when
	// there is no keyword.
	DefaultHelp() []string
	// JoinChannel joins a channel given it's human-readable name, e.g. "general"
	JoinChannel(c string) RetVal
	/* NOTE: Each of the Send* methods takes a pointer to a ConnectorMessage.
	   For plugins, this is the original ConnectorMessage that triggered a
	   command, and provides context back to the connector in sending replies.
	*/
	// SendProtocolChannelThreadMessage sends a message to a thread in a channel,
	// starting a thread if none exists. If thread is unset or unsupported by the
	// protocol, it just sends a message to the channel.
	SendProtocolChannelThreadMessage(channelname, threadid, msg string, format MessageFormat, msgObject *ConnectorMessage) RetVal
	// SendProtocolUserChannelThreadMessage directs a message to a user in a channel/thread.
	// This method also supplies what the bot engine believes to be the username.
	SendProtocolUserChannelThreadMessage(userid, username, channelname, threadid, msg string, format MessageFormat, msgObject *ConnectorMessage) RetVal
	// SendProtocolUserMessage sends a direct message to a user if supported.
	// The value of user will be either "<userid>", the connector internal
	// userID in brackets, or "username", a string name the connector associates
	// with the user.
	SendProtocolUserMessage(user, msg string, format MessageFormat, msgObject *ConnectorMessage) RetVal
	// The Run method starts the main loop and takes a channel for stopping it.
	Run(stopchannel <-chan struct{})
}
</file_content file: gopherbot-main/robot/interfaces.go>
<preamble file: gopherbot-main/robot/job_structs.go>

</preamble>
<file_content file: gopherbot-main/robot/job_structs.go>
package robot

// Repository represents a buildable git repository, for CI/CD
type Repository struct {
	Type         string // task extending the namespace needs to match for parameters
	CloneURL     string
	Dependencies []string // List of repositories this one depends on; changes to a dependency trigger a build
	// Logs to keep for this repo; pointer allows "undefined" to be detected,
	// in which case the value is inherited from the build type.
	KeepLogs   *int
	Parameters []Parameter // per-repository parameters
}

// Parameter items are provided to jobs and plugins as environment variables
type Parameter struct {
	Name, Value string
}
</file_content file: gopherbot-main/robot/job_structs.go>
<preamble file: gopherbot-main/robot/loglevel_string.go>

</preamble>
<file_content file: gopherbot-main/robot/loglevel_string.go>
// Code generated by "stringer -type=LogLevel botdefs.go"; DO NOT EDIT.

package robot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[Trace-0]
	_ = x[Debug-1]
	_ = x[Info-2]
	_ = x[Audit-3]
	_ = x[Warn-4]
	_ = x[Error-5]
	_ = x[Fatal-6]
}

const _LogLevel_name = "TraceDebugInfoAuditWarnErrorFatal"

var _LogLevel_index = [...]uint8{0, 5, 10, 14, 19, 23, 28, 33}

func (i LogLevel) String() string {
	if i < 0 || i >= LogLevel(len(_LogLevel_index)-1) {
		return "LogLevel(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _LogLevel_name[_LogLevel_index[i]:_LogLevel_index[i+1]]
}
</file_content file: gopherbot-main/robot/loglevel_string.go>
<preamble file: gopherbot-main/robot/messageformat_string.go>

</preamble>
<file_content file: gopherbot-main/robot/messageformat_string.go>
// Code generated by "stringer -type=MessageFormat botdefs.go"; DO NOT EDIT.

package robot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[Raw-0]
	_ = x[Fixed-1]
	_ = x[Variable-2]
}

const _MessageFormat_name = "RawFixedVariable"

var _MessageFormat_index = [...]uint8{0, 3, 8, 16}

func (i MessageFormat) String() string {
	if i < 0 || i >= MessageFormat(len(_MessageFormat_index)-1) {
		return "MessageFormat(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _MessageFormat_name[_MessageFormat_index[i]:_MessageFormat_index[i+1]]
}
</file_content file: gopherbot-main/robot/messageformat_string.go>
<preamble file: gopherbot-main/robot/protocol_string.go>

</preamble>
<file_content file: gopherbot-main/robot/protocol_string.go>
// Code generated by "stringer -type=Protocol botdefs.go"; DO NOT EDIT.

package robot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[Slack-0]
	_ = x[Rocket-1]
	_ = x[Terminal-2]
	_ = x[Test-3]
	_ = x[Null-4]
}

const _Protocol_name = "SlackRocketTerminalTestNull"

var _Protocol_index = [...]uint8{0, 5, 11, 19, 23, 27}

func (i Protocol) String() string {
	if i < 0 || i >= Protocol(len(_Protocol_index)-1) {
		return "Protocol(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Protocol_name[_Protocol_index[i]:_Protocol_index[i+1]]
}
</file_content file: gopherbot-main/robot/protocol_string.go>
<preamble file: gopherbot-main/robot/retval_string.go>

</preamble>
<file_content file: gopherbot-main/robot/retval_string.go>
// Code generated by "stringer -type=RetVal botdefs.go"; DO NOT EDIT.

package robot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[Ok-0]
	_ = x[UserNotFound-1]
	_ = x[ChannelNotFound-2]
	_ = x[AttributeNotFound-3]
	_ = x[FailedMessageSend-4]
	_ = x[FailedChannelJoin-5]
	_ = x[DatumNotFound-6]
	_ = x[DatumLockExpired-7]
	_ = x[DataFormatError-8]
	_ = x[BrainFailed-9]
	_ = x[InvalidDatumKey-10]
	_ = x[InvalidDblPtr-11]
	_ = x[InvalidCfgStruct-12]
	_ = x[NoConfigFound-13]
	_ = x[RetryPrompt-14]
	_ = x[ReplyNotMatched-15]
	_ = x[UseDefaultValue-16]
	_ = x[TimeoutExpired-17]
	_ = x[Interrupted-18]
	_ = x[MatcherNotFound-19]
	_ = x[NoUserEmail-20]
	_ = x[NoBotEmail-21]
	_ = x[MailError-22]
	_ = x[TaskNotFound-23]
	_ = x[MissingArguments-24]
	_ = x[InvalidStage-25]
	_ = x[InvalidTaskType-26]
	_ = x[CommandNotMatched-27]
	_ = x[TaskDisabled-28]
	_ = x[PrivilegeViolation-29]
}

const _RetVal_name = "OkUserNotFoundChannelNotFoundAttributeNotFoundFailedMessageSendFailedChannelJoinDatumNotFoundDatumLockExpiredDataFormatErrorBrainFailedInvalidDatumKeyInvalidDblPtrInvalidCfgStructNoConfigFoundRetryPromptReplyNotMatchedUseDefaultValueTimeoutExpiredInterruptedMatcherNotFoundNoUserEmailNoBotEmailMailErrorTaskNotFoundMissingArgumentsInvalidStageInvalidTaskTypeCommandNotMatchedTaskDisabledPrivilegeViolation"

var _RetVal_index = [...]uint16{0, 2, 14, 29, 46, 63, 80, 93, 109, 124, 135, 150, 163, 179, 192, 203, 218, 233, 247, 258, 273, 284, 294, 303, 315, 331, 343, 358, 375, 387, 405}

func (i RetVal) String() string {
	if i < 0 || i >= RetVal(len(_RetVal_index)-1) {
		return "RetVal(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _RetVal_name[_RetVal_index[i]:_RetVal_index[i+1]]
}
</file_content file: gopherbot-main/robot/retval_string.go>
<preamble file: gopherbot-main/robot/robot.go>

</preamble>
<file_content file: gopherbot-main/robot/robot.go>
package robot

import "bytes"

// Robot defines the methods exposed by gopherbot.bot Robot struct, for
// use by plugins/jobs/tasks. See bot/Robot for complete definitions.
type Robot interface {
	// Primarily plugin methods
	CheckAdmin() bool
	Elevate(bool) bool
	GetBotAttribute(a string) *AttrRet
	GetUserAttribute(u, a string) *AttrRet
	GetSenderAttribute(a string) *AttrRet
	GetTaskConfig(dptr interface{}) RetVal
	GetMessage() *Message
	GetParameter(name string) string
	Email(subject string, messageBody *bytes.Buffer, html ...bool) (ret RetVal)
	EmailUser(user, subject string, messageBody *bytes.Buffer, html ...bool) (ret RetVal)
	EmailAddress(address, subject string, messageBody *bytes.Buffer, html ...bool) (ret RetVal)
	Fixed() Robot
	MessageFormat(f MessageFormat) Robot
	Direct() Robot
	Threaded() Robot
	Log(l LogLevel, m string, v ...interface{}) bool
	SendChannelMessage(ch, msg string, v ...interface{}) RetVal
	SendChannelThreadMessage(ch, thr, msg string, v ...interface{}) RetVal
	SendUserChannelMessage(u, ch, msg string, v ...interface{}) RetVal
	SendUserChannelThreadMessage(u, ch, thr, msg string, v ...interface{}) RetVal
	SendUserMessage(u, msg string, v ...interface{}) RetVal
	Reply(msg string, v ...interface{}) RetVal
	ReplyThread(msg string, v ...interface{}) RetVal
	Say(msg string, v ...interface{}) RetVal
	SayThread(msg string, v ...interface{}) RetVal
	RandomInt(n int) int
	RandomString(s []string) string
	Pause(s float64)
	PromptForReply(regexID string, prompt string, v ...interface{}) (string, RetVal)
	PromptThreadForReply(regexID string, prompt string, v ...interface{}) (string, RetVal)
	PromptUserForReply(regexID string, user string, prompt string, v ...interface{}) (string, RetVal)
	PromptUserChannelForReply(regexID string, user, channel string, prompt string, v ...interface{}) (string, RetVal)
	PromptUserChannelThreadForReply(regexID string, user, channel, thread string, prompt string, v ...interface{}) (string, RetVal)
	CheckoutDatum(key string, datum interface{}, rw bool) (locktoken string, exists bool, ret RetVal)
	CheckinDatum(key, locktoken string)
	UpdateDatum(key, locktoken string, datum interface{}) (ret RetVal)
	Remember(key, value string, shared bool)
	RememberThread(key, value string, shared bool)
	RememberContext(context, value string)
	RememberContextThread(context, value string)
	Recall(key string, shared bool) string
	// Primarily job/pipeline methods
	GetRepoData() map[string]Repository
	ExtendNamespace(string, int) bool
	SpawnJob(string, ...string) RetVal
	AddTask(string, ...string) RetVal
	FinalTask(string, ...string) RetVal
	FailTask(string, ...string) RetVal
	AddJob(string, ...string) RetVal
	AddCommand(string, string) RetVal
	FinalCommand(string, string) RetVal
	FailCommand(string, string) RetVal
	// Go plugins only, for filesystem access to GOPHER_HOME
	RaisePriv(string)
	SetParameter(string, string) bool
	SetWorkingDirectory(string) bool
}
</file_content file: gopherbot-main/robot/robot.go>
<preamble file: gopherbot-main/robot/structs.go>

</preamble>
<file_content file: gopherbot-main/robot/structs.go>
package robot

import "log"

// AttrRet implements Stringer so it can be interpolated with fmt if
// the plugin author is ok with ignoring the RetVal.
type AttrRet struct {
	Attribute string
	RetVal
}

func (a AttrRet) String() string {
	return a.Attribute
}

// Message is passed to each task as it runs, initialized from the botContext.
// Tasks can copy and modify the Robot without affecting the botContext.
type Message struct {
	User            string            // The user who sent the message; this can be modified for replying to an arbitrary user
	ProtocolUser    string            // the protocol internal ID of the user
	Channel         string            // The channel where the message was received, or "" for a direct message. This can be modified to send a message to an arbitrary channel.
	ProtocolChannel string            // the protocol internal channel ID
	Protocol        Protocol          // slack, terminal, test, others; used for interpreting rawmsg or sending messages with Format = 'Raw'
	Incoming        *ConnectorMessage // raw IncomingMessage object
	Format          MessageFormat     // The outgoing message format, one of Raw, Fixed, or Variable
}

// ConnectorMessage is passed in to the robot for every incoming message seen.
// The *ID fields are required invariant internal representations that the
// protocol accepts in it's interface methods.
type ConnectorMessage struct {
	// Protocol - string name of connector, e.g. "Slack"
	Protocol string
	// optional UserName and required internal UserID
	UserName, UserID string
	// optional / required channel values
	ChannelName, ChannelID string
	// Opaque values
	ThreadID, MessageID string
	ThreadedMessage     bool
	// true when the incoming message originated from the robot itself
	SelfMessage bool
	// DirectMessage - whether the message should be considered private between user and robot
	DirectMessage bool
	// BotMessage - true when the connector is certain the message has been sent to the robot,
	// e.g. for slack slash commands
	BotMessage bool
	// HiddenMessage - true when the user sent a message to the robot that can't be seen by
	// other users, also true for slack slash commands
	HiddenMessage bool
	// MessageText - sanitized message text, with all protocol-added junk removed
	MessageText string
	// MessageObject, Client - interfaces for the raw objects; go extensions can use
	// these with type switches/assertions to access object internals
	MessageObject, Client interface{}
}

// PluginHandler is the struct a Go plugin registers for the Gopherbot plugin API.
type PluginHandler struct {
	DefaultConfig string /* A yaml-formatted multiline string defining the default Plugin configuration. It should be liberally commented for use in generating
	custom configuration for the plugin. If a Config: section is defined, it should match the structure of the optional Config interface{} */
	Handler func(r Robot, command string, args ...string) TaskRetVal // The callback function called by the robot whenever a Command is matched
	Config  interface{}                                              // An optional empty struct defining custom configuration for the plugin
}

// JobHandler is the struct registered for a Go job
type JobHandler struct {
	Handler func(r Robot, args ...string) TaskRetVal // The callback function called by the robot when the job is run
	Config  interface{}                              // An optional empty struct defining custom configuration for the job
}

// TaskHandler is the struct registered for a Go task
type TaskHandler struct {
	Handler func(r Robot, args ...string) TaskRetVal // The callback for this Go task
}

// PluginSpec used by loadable plugins that return a slice of PluginSpecs
type PluginSpec struct {
	Name    string
	Handler PluginHandler
}

// JobSpec used by loadable plugins that return a slice of JobSpecs
type JobSpec struct {
	Name    string
	Handler JobHandler
}

// TaskSpec used by loadable plugins that return a slice of TaskSpecs
type TaskSpec struct {
	Name              string
	RequiresPrivilege bool
	Handler           TaskHandler
}

// ConnectorSpec for specifying a connector
type ConnectorSpec struct {
	Name      string
	Connector func(Handler, *log.Logger) Connector
}

// BrainSpec for specifying a connector
type BrainSpec struct {
	Name  string
	Brain func(Handler) SimpleBrain
}

// HistorySpec for specifying a connector
type HistorySpec struct {
	Name     string
	Provider func(Handler) HistoryProvider
}

// Manifest lists all the handlers available from a given loadable module
type Manifest struct {
	Tasks     []TaskSpec
	Plugins   []PluginSpec
	Jobs      []JobSpec
	Connector ConnectorSpec
	Brain     BrainSpec
	History   HistorySpec
}
</file_content file: gopherbot-main/robot/structs.go>
<preamble file: gopherbot-main/robot/taskretval_string.go>

</preamble>
<file_content file: gopherbot-main/robot/taskretval_string.go>
// Code generated by "stringer -type=TaskRetVal botdefs.go"; DO NOT EDIT.

package robot

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[Normal-0]
	_ = x[Fail-1]
	_ = x[MechanismFail-2]
	_ = x[ConfigurationError-3]
	_ = x[PipelineAborted-4]
	_ = x[RobotStopping-5]
}

const _TaskRetVal_name = "NormalFailMechanismFailConfigurationErrorPipelineAbortedRobotStopping"

var _TaskRetVal_index = [...]uint8{0, 6, 10, 23, 41, 56, 69}

func (i TaskRetVal) String() string {
	if i < 0 || i >= TaskRetVal(len(_TaskRetVal_index)-1) {
		return "TaskRetVal(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TaskRetVal_name[_TaskRetVal_index[i]:_TaskRetVal_index[i+1]]
}
</file_content file: gopherbot-main/robot/taskretval_string.go>
<preamble file: gopherbot-main/setuid-nobody.sh>

</preamble>
<file_content file: gopherbot-main/setuid-nobody.sh>
#!/bin/bash

# setuid-nobody.sh - trivial convenience script for common permissions on
# gopherbot binary; prevents silly typos.

if [ $(id -u) -ne 0 ]
then
	echo "Must be run as root"
	exit 1
fi

INSTALLDIR=$(dirname $0)
cd $INSTALLDIR
chown nobody gopherbot
chmod u+s gopherbot
echo "Done."
</file_content file: gopherbot-main/setuid-nobody.sh>
<preamble file: gopherbot-main/tasks/ansible-playbook.sh>

</preamble>
<file_content file: gopherbot-main/tasks/ansible-playbook.sh>
#!/bin/bash

# ansible-playbook.sh - Gopherbot task for running an ansible playbook that uses
# a helper script for supplying a vault passphrase.

# Note that "VAULT_PASSWORD" needs to be stored as an encrypted parameter for either
# ansible-playbook or for a given repository in repositories.yaml.

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ -n "$VAULT_PASSWORD" ]
then
    export ANSIBLE_VAULT_PASSWORD_FILE=$GOPHER_INSTALLDIR/helpers/vault-password.sh
else
    Log "Warn" "No VAULT_PASSWORD secret found for job ${GOPHER_JOB_NAME:-(none)} / extended namespace ${GOPHER_REPOSITORY:-(none)}"
fi

exec ansible-playbook "$@"
</file_content file: gopherbot-main/tasks/ansible-playbook.sh>
<preamble file: gopherbot-main/tasks/cleanup.sh>

</preamble>
<file_content file: gopherbot-main/tasks/cleanup.sh>
#!/bin/bash

# cleanup.sh - task for cleaning a workdir at the start of a job.
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

WORKDIR="$1"

if [ ! "$WORKDIR" ]
then
    Log "Error" "Argument WORKDIR not given" >&2
    exit 1
fi
if [[ $WORKDIR = /* ]]
then
    Log "Error" "Not cleaning absolute WORKDIR: $WORKDIR"
    exit 1
fi
if [ ! -d "$WORKDIR" ]
then
    Log "Info" "WORKDIR: $WORKDIR not found, ignoring"
    exit 0
fi
rm -rf "$WORKDIR"
mkdir -p "$WORKDIR"
</file_content file: gopherbot-main/tasks/cleanup.sh>
<preamble file: gopherbot-main/tasks/dmnotify.sh>

</preamble>
<file_content file: gopherbot-main/tasks/dmnotify.sh>
#!/bin/bash -e

# tasks/dmnotify.sh - send DM to a user, generally used as a FailTask
# Requires two arguments: notify user and message

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ $# -ne 2 ]
then
    Log "Error" "dmnotify called with num args != 2"
    exit 0
fi

USER=$1
MESSAGE=$2
SendUserMessage "$USER" "$MESSAGE"
</file_content file: gopherbot-main/tasks/dmnotify.sh>
<preamble file: gopherbot-main/tasks/exec.sh>

</preamble>
<file_content file: gopherbot-main/tasks/exec.sh>
#!/bin/bash -e

# exec.sh - utility task for exec'ing scripts in a repository
# TODO: make this work in containers, remotely, remote containers, etc.

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

for ARG in "$@"
do
    if [[ $ARG = *=* ]]
    then
        VAR=${ARG%%=*}
        VALUE=${ARG#*=}
        export $VAR="$VALUE"
        shift
    else
        break
    fi
done

SCRIPT=$1
shift

if [[ $SCRIPT != /* && $SCRIPT == */* ]]
then
    if [ ! -e $SCRIPT ]
    then
        Log "Warn" "Script not found: $SCRIPT, ignoring"
        exit 0
    fi
fi

exec $SCRIPT "$@"
</file_content file: gopherbot-main/tasks/exec.sh>
<preamble file: gopherbot-main/tasks/fail.sh>

</preamble>
<file_content file: gopherbot-main/tasks/fail.sh>
#!/bin/bash -e

# tasks/fail.sh - used by gopherci to indicate a pipeline failing while
# allowing previous tasks to complete

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

MESSAGE=$1
Log "Error" "$MESSAGE"
exit 1
</file_content file: gopherbot-main/tasks/fail.sh>
<preamble file: gopherbot-main/tasks/finishbuild.sh>

</preamble>
<file_content file: gopherbot-main/tasks/finishbuild.sh>
#!/bin/bash -e

# finishbuild.sh - utility task to tell the user a build has finished

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ "$GOPHERCI_BRANCH" == "." ]
then
    TELL_BRANCH="(default branch)"
else
    TELL_BRANCH="$GOPHERCI_BRANCH"
fi

if [ "$GOPHER_FAIL_CODE" ]
then
  if [ "$GOPHER_FINAL_TYPE" == "plugin" ]
  then
    FAILED="plugin $GOPHER_FINAL_TASK, command \"$GOPHER_FINAL_COMMAND\""
  else
    FAILED="$GOPHER_FINAL_TYPE $GOPHER_FINAL_TASK"
  fi
  if [ "$GOPHER_FINAL_ARGS" ]
  then
    FAILED="$FAILED with args: $GOPHER_FINAL_ARGS"
  fi
  REF=";"
  if [ "$GOPHER_LOG_REF" ]
  then
    if [ "$GOPHER_LOG_LINK" ]
    then
      REF=" (log $GOPHER_LOG_REF: $GOPHER_LOG_LINK);"
    else
      REF=" (log $GOPHER_LOG_REF);"
    fi
  fi
  if [ "$GOPHERCI_CUSTOM_PIPELINE" ]
  then
    TELL="JOB FAILED for $GOPHER_REPOSITORY, branch '$TELL_BRANCH'$REF, running pipeline '$GOPHERCI_CUSTOM_PIPELINE': failure in $FAILED; exit code $GOPHER_FAIL_CODE ($GOPHER_FAIL_STRING)"
  else
    TELL="BUILD FAILED for $GOPHER_REPOSITORY, branch '$TELL_BRANCH'$REF: failure in $FAILED; exit code $GOPHER_FAIL_CODE ($GOPHER_FAIL_STRING)"
  fi
else
  if [ "$GOPHERCI_CUSTOM_PIPELINE" ]
  then
    TELL="Custom job for $GOPHER_REPOSITORY, branch '$TELL_BRANCH', running pipeline '$GOPHERCI_CUSTOM_PIPELINE' finished successfully"
  else
    TELL="Build of $GOPHER_REPOSITORY, branch '$TELL_BRANCH' finished successfully"
  fi
fi

Say "$TELL"
</file_content file: gopherbot-main/tasks/finishbuild.sh>
<preamble file: gopherbot-main/tasks/git-clone.sh>

</preamble>
<file_content file: gopherbot-main/tasks/git-clone.sh>
#!/bin/bash -e

# git-clone.sh - clone a git repository and optionally set the
# working directory

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ $# -lt 3 ]
then
    echo "Not enough arguments to git-clone; usage: git-clone <url> <branch> <dir> (true)" >&2
    exit 1
fi

REPO_URL=$1
BRANCH=$2
REPO_DIR=$3
SET_WD=$4

if [ -d "$REPO_DIR" -a "$(ls -A $REPO_DIR 2>/dev/null)" ]
then
    echo "Directory $REPO_DIR exists and is not empty" >&2
    exit 1
fi

trap_handler()
{
    ERRLINE="$1"
    ERRVAL="$2"
    echo "line ${ERRLINE} exit status: ${ERRVAL}" >&2
    # The script should usually exit on error
    exit $ERRVAL
}
trap 'trap_handler ${LINENO} $?' ERR

mkdir -p $REPO_DIR
cd $REPO_DIR

if [ -n "$SET_WD" ]
then
    SetWorkingDirectory "$REPO_DIR"
fi

if [ "$BRANCH" != "." ]
then
    CLONEREF="-b $BRANCH"
fi
git clone $CLONEREF $REPO_URL .
</file_content file: gopherbot-main/tasks/git-clone.sh>
<preamble file: gopherbot-main/tasks/git-init.py>

</preamble>
<file_content file: gopherbot-main/tasks/git-init.py>
#!/usr/bin/env python3

# git-init.py - task for setting up git credentials
# Currently this only adds ssh-init and ssh-scan <host> to
# the pipeline if needed, but may eventually handle http credentials
# with a git credential helper.

# Usage: AddTask git-init <clone_url>

import os
import re
import sys
from gopherbot_v2 import Robot

bot = Robot()

cfgdir = os.getenv("GOPHER_CONFIGDIR")
try:
    os.stat("%s/git/config" % cfgdir)
except FileNotFoundError:
    bot.Log("Warn", "%s/git/config not found, git push will fail" % cfgdir)

bot.SetParameter("XDG_CONFIG_HOME", cfgdir)

# Pop off the executable path
sys.argv.pop(0)

clone_url = sys.argv.pop(0)

if not clone_url.startswith("http"):
    match = re.match(r"ssh://(?:.*@)?([^:/]*)(?::([^/]*)/)?", clone_url)
    if match:
        scanhost = match.group(1)
        if match.group(2):
            scanhost = "%s:%s" % ( scanhost, match.group(2) )
    else:
        match = re.match(r"(?:.*@)?([^:/]*)", clone_url)
        if match:
            scanhost = match.group(1)
    bot.AddTask("ssh-init", [])
    bot.AddTask("ssh-scan", [ scanhost ])
</file_content file: gopherbot-main/tasks/git-init.py>
<preamble file: gopherbot-main/tasks/notify.sh>

</preamble>
<file_content file: gopherbot-main/tasks/notify.sh>
#!/bin/bash -e

# tasks/notify.sh - send notification to a user, generally used as a FailTask
# Requires two arguments: notify user and message

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

USER=$1
MESSAGE=$2

if [ -n "$GOPHER_CHANNEL" ]
then
    SendUserChannelMessage "$USER" "$GOPHER_CHANNEL" "$MESSAGE"
else
    SendUserMessage "$USER" "$MESSAGE"
fi
</file_content file: gopherbot-main/tasks/notify.sh>
<preamble file: gopherbot-main/tasks/remote-exec.sh>

</preamble>
<file_content file: gopherbot-main/tasks/remote-exec.sh>
#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

# remote-exec.sh - script for the `remote` task, for running simple commands
# on a remote system. To use the remote task:
# 1) Add the `ssh-init` task to start the robot's ssh agent
# 2) set the following environment vars for the pipeline with
#    `SetParameter <name> <value>`:
# - GOPHER_REMOTE_HOST - required if (-h <host>) not given
# - GOPHER_REMOTE_USER - optional, override with (-l <loginid>); defaults to $USER;
#   if this is always the same, you can also add as a Parameter for the "remote"
#   task
# - GOPHER_REMOTE_DIR - optional remote directory, override with (-d <dir>);
#   defaults to remote $HOME

# Usage: `AddTask remote (-A) (-l <login>) (-h <host>) (-f <file>|-S <scanhost(:port)>|-s|<remote command>)`
#   Executes a command on a remote host. Passing `-A` forwards the robot's ssh agent.
#
#   If `-f <file>` is given, <file> is executed remotely and any further arguments
#   are ignored. NOTE: When "-f <file>" is given, this script prepends "set -e" to the
#   remote script, which causes a non-zero exit on failed commands.
#
#   If `-S <scanhost(:port)` is given, ssh-keyscan is run from the remote
#   host to add a host to known_hosts on the remote system; this should be done ahead
#   of any commands that use ssh remotely. Further arguments are ignored when "-s" is
#   given.
#
#   If '-s' is given, the host keys for the remote host are added to $GOPHER_HOME/known_hosts
#   unless already present.
#
# A standard pipeline using the `remote` task might look like this:
#
    # # Parameters for remote deployment
    # SetParameter GOPHER_REMOTE_HOST my.remote.host
    # SetParameter GOPHER_REMOTE_DIR /var/www/my-application

    # AddTask ssh-init # already done by gopherci in many cases, but good form
    # # Make sure we have the remote system's hostkeys
    # AddTask remote -s
    # # Make sure git pull to git host doesn't fail; "remote -S <host>"
    # # does an ssh-keyscan on the remote host.
    # AddTask remote -S git.my.dom
    # AddTask remote -A git pull
    # AddTask remote ... # more remote commands

unset GR_FORWARD_AGENT GR_REMOTE_HOST GR_REMOTE_SCANHOST GR_REMOTE_SCRIPT GR_REMOTE_USER \
GR_REMOTE_DIR GR_LOCAL_SCAN

[ -n "$GOPHER_REMOTE_USER" ] && GR_REMOTE_USER="-l $GOPHER_REMOTE_USER"
[ -n "$GOPHER_REMOTE_HOST" ] && GR_REMOTE_HOST="$GOPHER_REMOTE_HOST"
[ -n "$GOPHER_REMOTE_DIR" ] && GR_REMOTE_DIR="$GOPHER_REMOTE_DIR"

while getopts ":Al:h:f:S:sd:" OPT
do
    case $OPT in
    A)
        GR_FORWARD_AGENT="-A"
        ;;
    l)
        GR_REMOTE_USER="-l $OPTARG"
        ;;
    h)
        GR_REMOTE_HOST="$OPTARG"
        ;;
    f)
        GR_REMOTE_SCRIPT="$OPTARG"
        ;;
    s)
        GR_LOCAL_SCAN="true"
        ;;
    S)
        GR_REMOTE_SCANHOST="$OPTARG"
        ;;
    d)
        GR_REMOTE_DIR="$OPTARG"
        ;;
    \?)
        echo "Invalid option: $OPTARG" >&2
        exit 1
        ;;
    : )
        echo "Invalid option: $OPTARG requires an argument" >&2
        exit 1
        ;;
    esac
done
shift $((OPTIND -1))

# spit out the remote script with "set -e" prepended
remote_script(){
    echo "set -e"
    if [ -n "$GR_REMOTE_DIR" ]
    then
        echo "cd $GR_REMOTE_DIR"
    fi
    cat "$GR_REMOTE_SCRIPT"
}

# spit out a remote script for ssh-keyscan on a remote host
remote_scan(){
    REMOTE_HOST=$GR_REMOTE_SCANHOST
    SCAN_HOST=$REMOTE_HOST
    local REMOTE_PORT
    if [[ $REMOTE_HOST = *:* ]]
    then
        REMOTE_PORT=${REMOTE_HOST##*:}
        REMOTE_HOST=${REMOTE_HOST%%:*}
        SKARGS="-p $REMOTE_PORT"
    fi
    cat <<EOF
ssh $SKARGS -o PasswordAuthentication=no -o PubkeyAuthentication=no \
-o StrictHostKeyChecking=no $REMOTE_HOST : 2>&1 || :
EOF
}

if [ -z "$GR_REMOTE_HOST" ]
then
    echo "No remote host given; set GOPHER_REMOTE_HOST or pass '-h <host>'" >&2
    exit 1
fi

if [ "$GR_LOCAL_SCAN" ]
then
    AddTask ssh-scan $GOPHER_REMOTE_HOST
    exit 0
fi

# Run a remote script
if [ -n "$GR_REMOTE_SCRIPT" ]
then
    if ! [ -e "$GR_REMOTE_SCRIPT" ]
    then
        echo "Remote script \"$GR_REMOTE_SCRIPT\" not found" >&2
        exit 1
    fi
    remote_script | ssh $SSH_OPTIONS $GR_FORWARD_AGENT $GR_REMOTE_USER $GR_REMOTE_HOST
    exit 0
fi

# ssh-keyscan a host remotely
if [ -n "$GR_REMOTE_SCANHOST" ]
then
    remote_scan | ssh $SSH_OPTIONS $GR_FORWARD_AGENT $GR_REMOTE_USER $GR_REMOTE_HOST
    exit 0
fi

REMOTE_COMMAND="$@"
if [ -z "$REMOTE_COMMAND" ]
then
    echo "No command given" >&2
    exit 1
fi

if [ -n "$GR_REMOTE_DIR" ]
then
    REMOTE_COMMAND="cd $GR_REMOTE_DIR; $REMOTE_COMMAND"
fi

ssh $SSH_OPTIONS $GR_FORWARD_AGENT $GR_REMOTE_USER $GR_REMOTE_HOST "$REMOTE_COMMAND"
</file_content file: gopherbot-main/tasks/remote-exec.sh>
<preamble file: gopherbot-main/tasks/reply.sh>

</preamble>
<file_content file: gopherbot-main/tasks/reply.sh>
#!/bin/bash -e

# tasks/reply.sh - trivial task that can be used to reply to the user
# in a pipeline.

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ "$GOPHER_USER" ]
then
    Reply "$*"
else
    Say "$*"
fi
</file_content file: gopherbot-main/tasks/reply.sh>
<preamble file: gopherbot-main/tasks/run-theia.sh>

</preamble>
<file_content file: gopherbot-main/tasks/run-theia.sh>
#!/bin/bash

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

umask 0002

SHELL=/bin/bash
THEIA_DEFAULT_PLUGINS=local-dir:/usr/local/theia/plugins
USE_LOCAL_GIT=true

export SHELL THEIA_DEFAULT_PLUGINS USE_LOCAL_GIT
unset BOT_SSH_PHRASE

cd /usr/local/theia
node /usr/local/theia/src-gen/backend/main.js /var/lib/robot --hostname 0.0.0.0 > /tmp/theia.log 2>/tmp/theia.errorlog &
THEIA_PID=$!

echo "$THEIA_PID" > /tmp/theia.pid
Say "Ok, I started the theia IDE, and you can connect to port 3000"
wait $THEIA_PID || :
</file_content file: gopherbot-main/tasks/run-theia.sh>
<preamble file: gopherbot-main/tasks/runpipeline.sh>

</preamble>
<file_content file: gopherbot-main/tasks/runpipeline.sh>
#!/bin/bash -e

# runpipeline.sh - utility task to detect and run the repository
# pipeline, or custom job pipeline

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

PIPELINE=${1:-pipeline}
[ $# -gt 0 ] && shift

for PTRY in $PIPELINE $PIPELINE.sh $PIPELINE.py $PIPELINE.rb
do
    if [ -x ".gopherci/$PTRY" ]
    then
        AddTask exec "./.gopherci/$PTRY $*"
        exit 0
    fi
done

Log "Warn" "Repository pipeline not found in job $GOPHER_JOB_NAME (wd: $(pwd), repo: ${GOPHER_REPOSITORY:-not set}), ignoring"
</file_content file: gopherbot-main/tasks/runpipeline.sh>
<preamble file: gopherbot-main/tasks/setworkdir.sh>

</preamble>
<file_content file: gopherbot-main/tasks/setworkdir.sh>
#!/bin/bash -e

# tasks/setworkdir.sh - update working directory during pipeline

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

SetWorkingDirectory $1
</file_content file: gopherbot-main/tasks/setworkdir.sh>
<preamble file: gopherbot-main/tasks/ssh-init.sh>

</preamble>
<file_content file: gopherbot-main/tasks/ssh-init.sh>
#!/bin/bash -e

# ssh-init.sh - pipeline task for setting up an ssh-agent for the robot.
# See jobs/ssh-job.sh for info on generic ssh jobs and tasks.

# NOTE:
# The use of a FIFO and cat <<EOF is to prevent the passphrase from ever
# being stored in a file or appearing in the process list; otherwise this
# script might be a bit shorter.

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ -z "$GOPHER_CONFIGDIR" ]
then
    MESSAGE="GOPHER_CONFIGDIR not set"
    Log "Error" "$MESSAGE"
    echo "$MESSAGE" >&2
    exit 1
fi

if [ "$SSH_AGENT_PID" ]
then
    Log "Debug" "ssh-init exiting; ssh-agent already running"
    exit 0 # already running
fi

if [ "$BOOTSTRAP" ]
then
    Log "Info" "ssh-init starting in bootstrap mode"
elif [ "$GOPHERBOT_IDE" ]
then
    Log "Info" "ssh-init starting in Gopherbot IDE mode (without loading a key)"
elif [ ! "$KEYNAME" ]
then
    MESSAGE="KEYNAME not set"
    Log "Error" "$MESSAGE"
    echo "$MESSAGE" >&2
    exit 1
else
    SSH_KEY_PATH="$GOPHER_CONFIGDIR/ssh/$KEYNAME"
    if [ ! -e $SSH_KEY_PATH ]
    then
        Log "Error" "ssh/$KEYNAME not found in ssh-init, exiting"
        exit 1
    fi

    if [ -z "$BOT_SSH_PHRASE" ]
    then
        Log "Error" "I don't know the passphrase for my ssh keypair, aborting"
        exit 1
    fi
    chmod 600 "$SSH_KEY_PATH"
fi

export SSH_ASKPASS=$GOPHER_INSTALLDIR/helpers/ssh-askpass.sh
export SSH_ASKPASS_REQUIRE=force
export DISPLAY=""

eval `ssh-agent`

# Add cleanup task
FinalTask exec ssh-agent -k

if [ "$BOOTSTRAP" ]
then
    if [ -z "$GOPHER_DEPLOY_KEY" ]
    then
        Log "Error" "Bootstrap given but GOPHER_DEPLOY_KEY unset"
        exit 1
    fi
    echo "$GOPHER_DEPLOY_KEY" | tr '_:' ' \n' | ssh-add -
elif [ ! "$GOPHERBOT_IDE" ]
then
    ssh-add $SSH_KEY_PATH < /dev/null
fi

# Make agent available to other tasks in the pipeline
SetParameter SSH_AUTH_SOCK $SSH_AUTH_SOCK
SetParameter SSH_AGENT_PID $SSH_AGENT_PID

SSH_OPTIONS="-o PasswordAuthentication=no"
if [ ! "$GOPHERBOT_IDE" -a "$GOPHER_HOME" ]
then
    if [ -e "$GOPHER_CONFIGDIR/ssh/config" ]
    then
        chmod 0600 "$GOPHER_CONFIGDIR/ssh/config"
        SSH_OPTIONS="$SSH_OPTIONS -F $GOPHER_CONFIGDIR/ssh/config"
    fi
    SSH_OPTIONS="$SSH_OPTIONS -o UserKnownHostsFile=$GOPHER_HOME/known_hosts"
fi

SetParameter SSH_OPTIONS "$SSH_OPTIONS"
SetParameter GIT_SSH_COMMAND "ssh $SSH_OPTIONS"

exit 0
</file_content file: gopherbot-main/tasks/ssh-init.sh>
<preamble file: gopherbot-main/tasks/ssh-scan.sh>

</preamble>
<file_content file: gopherbot-main/tasks/ssh-scan.sh>
#!/bin/bash -e
# Helper task for adding ssh host keys to known_hosts.
# Usage:
# - Add it to a pipeline: `AddTask ssh-scan some.host.name(:port)`

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

unset REMOTE_PORT

REMOTE_HOST="$1"
SCAN_HOST="$REMOTE_HOST"

if [[ $REMOTE_HOST = *:* ]]
then
	REMOTE_PORT=${REMOTE_HOST##*:}
	REMOTE_HOST=${REMOTE_HOST%%:*}
	SKARGS="-p $REMOTE_PORT"
fi

# Ignore ssh error value; github.com for instance will exit 1
SCAN=$(ssh $SKARGS $SSH_OPTIONS -o PasswordAuthentication=no -o PubkeyAuthentication=no \
-o StrictHostKeyChecking=no $REMOTE_HOST : 2>&1 || :)

if echo "$SCAN" | grep -q "WARNING"
then
	Log "Error" "ssh-scan failed, remote host changed"
	echo "$SCAN" > /dev/stderr
	exit 1
fi
</file_content file: gopherbot-main/tasks/ssh-scan.sh>
<preamble file: gopherbot-main/tasks/startbuild.sh>

</preamble>
<file_content file: gopherbot-main/tasks/startbuild.sh>
#!/bin/bash -e

# startbuild.sh - utility task to tell the user a build is starting

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

if [ "$GOPHERCI_BRANCH" == "." ]
then
    TELL_BRANCH="(default branch)"
else
    TELL_BRANCH="$GOPHERCI_BRANCH"
fi

TELL="Starting build of $GOPHER_REPOSITORY, branch '$TELL_BRANCH'"
if [ "$GOPHERCI_CUSTOM_PIPELINE" ]
then
  TELL="Starting custom job for $GOPHER_REPOSITORY, branch '$TELL_BRANCH', pipeline '$GOPHERCI_CUSTOM_PIPELINE'"
fi

if [ "$GOPHER_LOG_REF" ] || [ "$GOPHER_LOG_LINK" ]
then
  if [ "$GOPHER_LOG_REF" ] && [ "$GOPHER_LOG_LINK" ]
  then
    TELL="$TELL (log $GOPHER_LOG_REF; link $GOPHER_LOG_LINK)"
  elif [ "$GOPHER_LOG_REF" ]
  then
    TELL="$TELL (log $GOPHER_LOG_REF)"
  else
    TELL="$TELL (link $GOPHER_LOG_LINK)"
  fi
fi

Say "$TELL"
</file_content file: gopherbot-main/tasks/startbuild.sh>
<preamble file: gopherbot-main/tasks/status.sh>

</preamble>
<file_content file: gopherbot-main/tasks/status.sh>
#!/bin/bash -e

# tasks/status.sh - trivial task that can be used to send status updates
# in a pipeline.

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

Say "$*"
</file_content file: gopherbot-main/tasks/status.sh>
<preamble file: gopherbot-main/test/README.md>

</preamble>
<file_content file: gopherbot-main/test/README.md>
This directory is used for **Gopherbot** integration tests.

These configuration sub-directories are used with the `test` connector for automated testing. See `*_test.go`. To run the robot with one of these configurations using the terminal connector, run `gopherbot` inside a configuration directory. Best to use the special build using `make testbot`.
</file_content file: gopherbot-main/test/README.md>
<preamble file: gopherbot-main/test/bot_integration_test.go>

</preamble>
<file_content file: gopherbot-main/test/bot_integration_test.go>
//go:build integration
// +build integration

package bot_test

/*
bot_integration_test.go - setup and initialization of "black box" integration testing.

Run integration tests with:
$ go test -v --tags 'test integration' ./test

Run specific tests with e.g.:
$ go test -run MessageMatch -v --tags 'test integration' ./test

To run tests with static builds and modules from vendor:
$ CGO_ENABLED=0 go test -v --tags 'test integration netgo osusergo static_build' -mod vendor ./test

Generate coverage statistics report with:
$ go tool cover -html=coverage.out -o coverage.html

Check status of goroutines if tests get hung up
$ go tool pprof http://localhost:8889/debug/pprof/goroutine
...
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) list lnxjedi
Total: 11
ROUTINE ======================== github.com/lnxjedi/gopherbot/v2/bot...

(eventual) Setup for "clear box" testing of bot internals is in bot_test.go
*/

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
	"time"

	. "github.com/lnxjedi/gopherbot/v2/bot"
	testc "github.com/lnxjedi/gopherbot/v2/connectors/test"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/groups"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/help"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/links"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/lists"
	_ "github.com/lnxjedi/gopherbot/v2/goplugins/ping"
	_ "github.com/lnxjedi/gopherbot/v2/history/file"

	_ "net/http/pprof"
)

var testInstallPath string

// Environment setting(s) for expanding installed conf/robot.yaml
func init() {
	os.Setenv("GOPHER_PROTOCOL", "test")
	wd, _ := os.Getwd()
	testInstallPath = filepath.Dir(wd)
}

type testItem struct {
	user, channel, message string
	replies                []testc.TestMessage // note: TestMessage.Message -> regex
	events                 []Event
	pause                  int // time in milliseconds to pause after test item
}

// NOTE: integration tests are closely tied to the configuration in test/...

// Cast of Users
const alice = "alice"
const bob = "bob"
const carol = "carol"
const david = "david"
const erin = "erin"
const aliceID = "u0001"
const bobID = "u0002"
const carolID = "u0003"
const davidID = "u0004"
const erinID = "u0005"

// When the robot doesn't address the user specifically, or sends a DM
const null = ""

// ... and the Channels they play in
const general = "general"
const random = "random"
const bottest = "bottest"
const deadzone = "deadzone"

func setup(cfgdir, logfile string, t *testing.T) (<-chan bool, *testc.TestConnector) {
	os.Setenv("GOPHER_ENCRYPTION_KEY", "gopherbot-integration-tests-brain-key")
	testVer := VersionInfo{"test", "(unknown)"}

	testc.ExportTest.Lock()
	testc.ExportTest.Test = t
	testc.ExportTest.Unlock()

	done, tconn := StartTest(testVer, cfgdir, logfile, t)
	testConnector := tconn.(*testc.TestConnector)

	return done, testConnector
}

func teardown(t *testing.T, done <-chan bool, conn *testc.TestConnector) {
	// Alice is a bot admin who can order the bot to quit in #general
	conn.SendBotMessage(&testc.TestMessage{aliceID, null, "quit"})

	// Now we wait for the connection to finish
	<-done
	ws := filepath.Join(testInstallPath, "test", "workspace")
	if err := os.RemoveAll(ws); err != nil {
		fmt.Printf("Removing temporary workspace: %v\n", err)
	}

	evOk := true
	ev := GetEvents()
	want := []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}
	if len(*ev) != len(want) {
		evOk = false
	} else {
		for i, e := range *ev {
			if e != want[i] {
				evOk = false
			}
		}
	}
	if !evOk {
		gevs := make([]string, len(*ev))
		for i, e := range *ev {
			gevs[i] = e.String()
		}
		wevs := make([]string, len(want))
		for i, e := range want {
			wevs[i] = e.String()
		}
		t.Errorf("FAILED teardown events; want: \"%s\"; got: %s\n", strings.Join(wevs, ", "), strings.Join(gevs, ", "))
	}
}

func testcases(t *testing.T, conn *testc.TestConnector, tests []testItem) {
	for _, test := range tests {
		// Clear out start-up events
		GetEvents()
		conn.SendBotMessage(&testc.TestMessage{test.user, test.channel, test.message})
		for _, want := range test.replies {
			if re, err := regexp.Compile(want.Message); err != nil {
				t.Errorf("FAILED: regex \"%s\" didn't compile: %v", want.Message, err)
			} else {
				got, err := conn.GetBotMessage()
				if err != nil {
					t.Errorf("FAILED timeout waiting for reply from robot; want: \"%s\"", want.Message)
				} else {
					if !re.MatchString(got.Message) {
						t.Errorf("FAILED message regex match; want: \"%s\", got: \"%s\"", want.Message, got.Message)
					} else {
						if got.User != want.User || got.Channel != want.Channel {
							t.Errorf("FAILED user/channel match; want u:%s, c:%s; got u:%s,c:%s", want.User, want.Channel, got.User, got.Channel)
						}
					}
				}
			}
		}
		ev := GetEvents()
		evOk := true
		if len(*ev) != len(test.events) {
			evOk = false
		} else {
			for i, e := range *ev {
				if e != test.events[i] {
					evOk = false
				}
			}
		}
		if !evOk {
			wevs := make([]string, len(test.events))
			for i, e := range test.events {
				wevs[i] = e.String()
			}
			gevs := make([]string, len(*ev))
			for i, e := range *ev {
				gevs[i] = e.String()
			}
			t.Errorf("FAILED emitted events; want: \"%s\"; got: %s\n", strings.Join(wevs, ", "), strings.Join(gevs, ", "))
		}
		if test.pause > 0 {
			time.Sleep(time.Millisecond * time.Duration(test.pause))
		}
	}
}

func TestBotName(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, null, "ping, bender", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, ";ping", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "bender ping", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "ping", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping, bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "bender ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		// This was matching too often when a user was talking about (instead of to) the robot
		//{aliceID, general, "ping bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "bender, ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "@bender ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping, @bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping;", []testc.TestMessage{}, []Event{}, 0},
		{bobID, general, "bender: echo hello world", []testc.TestMessage{{null, general, "Sure thing: hello world"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		// When you forget to address the robot, you can say it's name
		{aliceID, general, "ping", []testc.TestMessage{}, []Event{}, 300},
		{aliceID, general, "bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping", []testc.TestMessage{}, []Event{}, 300},
		{aliceID, general, ";", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestBotNoName(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, null, ";ping", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "ping", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping;", []testc.TestMessage{}, []Event{}, 0},
		{bobID, general, "bender: echo hello world", []testc.TestMessage{{null, general, "hello world"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		// When you forget to address the robot, you can say it's name
		{aliceID, general, "ping", []testc.TestMessage{}, []Event{}, 500},
		{aliceID, general, ";", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping", []testc.TestMessage{}, []Event{}, 100},
		{aliceID, general, "hello robot", []testc.TestMessage{{null, general, "Hello, World!"}}, []Event{AmbientTaskRan, ExternalTaskRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestBotNoAlias(t *testing.T) {
	done, conn := setup("test/membrain-noalias", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, null, "ping, bender", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "bender ping", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "ping", []testc.TestMessage{{alice, null, "PONG"}}, []Event{BotDirectMessage, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping, bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "bender ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		// Support for bare names at end removed
		//{aliceID, general, "ping bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "bender, ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "@bender ping", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping, @bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{bobID, general, "bender: echo hello world", []testc.TestMessage{{null, general, "hello world"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		// When you forget to address the robot, you can say it's name
		{aliceID, general, "ping", []testc.TestMessage{}, []Event{}, 200},
		{aliceID, general, "bender", []testc.TestMessage{{alice, general, "PONG"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ping", []testc.TestMessage{}, []Event{}, 100},
		{aliceID, general, "hello robot", []testc.TestMessage{{null, general, "Hello, World!"}}, []Event{AmbientTaskRan, ExternalTaskRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestReload(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, general, "reload, bender", []testc.TestMessage{{alice, general, "Configuration reloaded successfully"}}, []Event{AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestMessageMatch(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, general, "hello robot", []testc.TestMessage{{null, general, "Hello, World!"}}, []Event{AmbientTaskRan, ExternalTaskRan}, 0},
		{aliceID, general, ";hello robot", []testc.TestMessage{{null, general, "Hello, World!"}}, []Event{AmbientTaskRan, ExternalTaskRan}, 0},
		{aliceID, null, "hello robot", []testc.TestMessage{{alice, null, "Hello, World!"}}, []Event{BotDirectMessage, AmbientTaskRan, ExternalTaskRan}, 0},
		{aliceID, null, "bender, hello robot", []testc.TestMessage{{alice, null, "Hello, World!"}}, []Event{BotDirectMessage, AmbientTaskRan, ExternalTaskRan}, 0},
		{aliceID, general, "ping", []testc.TestMessage{}, []Event{}, 100},
		{aliceID, general, ";hello robot", []testc.TestMessage{{null, general, "Hello, World!"}}, []Event{AmbientTaskRan, ExternalTaskRan}, 100},
		{aliceID, general, "bender", []testc.TestMessage{{null, general, `Yes\?`}}, []Event{}, 0},
		{aliceID, random, "hello robot", []testc.TestMessage{{null, random, "Hello, World!"}}, []Event{AmbientTaskRan, ExternalTaskRan}, 100},
		{aliceID, random, ";hello robot", []testc.TestMessage{{null, random, "I'm here"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestVisibility(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, general, "help ruby, bender", []testc.TestMessage{{null, general, `bender, ruby .*random\)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "ruby me, bender", []testc.TestMessage{{null, general, "No command matched in channel.*"}}, []Event{CatchAllsRan, CatchAllTaskRan, GoPluginRan}, 0},
		{bobID, general, ";ping", []testc.TestMessage{{null, general, "No command matched in channel.*"}}, []Event{CatchAllsRan, CatchAllTaskRan, GoPluginRan}, 0},
		{bobID, general, ";reload", []testc.TestMessage{{null, general, "No command matched in channel.*"}}, []Event{CatchAllsRan, CatchAllTaskRan, GoPluginRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestBuiltins(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest-builtins.log", t)

	tests := []testItem{
		{aliceID, general, ";help log", []testc.TestMessage{{null, general, "direct message only"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, ";set log lines to 0", []testc.TestMessage{{alice, null, "Lines per page of log output set to: 1"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, ";set log lines to 3", []testc.TestMessage{{alice, null, "Lines per page of log output set to: 3"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";help info", []testc.TestMessage{{null, general, `;.*admins.*`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, random, ";help ruby", []testc.TestMessage{{null, random, `prove that ruby plugins work \(channels: random\)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "help", []testc.TestMessage{{null, general, "Hi,.*"}}, []Event{AmbientTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";whoami", []testc.TestMessage{{null, general, "you are 'test' user 'alice/u0001', speaking in channel 'general/#general', email address: alice@example.com"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		// NOTE: Dumps are all format = Fixed, which for the test connector is ALL CAPS
		{aliceID, null, "dump robot", []testc.TestMessage{{alice, null, "HERE'S HOW I'VE BEEN CONFIGURED.*"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "dump plugin echo", []testc.TestMessage{{alice, null, "ALLCHANNELS.*"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "dump plugin default echo", []testc.TestMessage{{alice, null, "HERE'S.*"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "dump plugin rubydemo", []testc.TestMessage{{alice, null, "ALLCHANNELS.*"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "dump plugin default rubydemo", []testc.TestMessage{{alice, null, "HERE'S.*"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, "dump plugin junk", []testc.TestMessage{{alice, null, "Didn't find .* junk"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, ";show log", []testc.TestMessage{{alice, null, ".*"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
		{aliceID, null, ";show log page 1", []testc.TestMessage{{alice, null, ".*"}}, []Event{BotDirectMessage, AdminCheckPassed, CommandTaskRan, GoPluginRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestPrompting(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{carolID, general, "Bender, listen to me", []testc.TestMessage{{carol, null, "Ok, .*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{carolID, null, "You're pretty cool", []testc.TestMessage{{carol, null, "I hear .*cool\""}}, []Event{BotDirectMessage}, 0},
		{bobID, general, "hear me out, Bender", []testc.TestMessage{{bob, general, "Well ok then.*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{bobID, general, "I like kittens", []testc.TestMessage{{bob, general, "Ok, I hear you saying \"I like kittens\".*"}}, []Event{}, 0},
		// wait ask waits a second before prompting; in 2 seconds it'll message the test to answer the second question first
		{davidID, general, ";waitask", []testc.TestMessage{}, []Event{}, 200},
		// ask now asks a question right away, but we don't reply until the command above tells us to - by which time the first command has prompted, but now has to wait
		{davidID, general, ";asknow", []testc.TestMessage{{david, general, `Do you like puppies\?`}, {null, general, `ok - answer puppies`}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{davidID, general, "yes", []testc.TestMessage{{david, general, `Do you like kittens\?`}, {null, general, `I like puppies too!`}}, []Event{}, 0},
		{davidID, general, "yes", []testc.TestMessage{{null, general, `I like kittens too!`}}, []Event{}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestFormatting(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, general, ";format fixed", []testc.TestMessage{{null, general, "_ITALICS_ <ONE> \\*BOLD\\* `CODE` @PARSLEY"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{aliceID, general, ";format variable", []testc.TestMessage{{null, general, "_italics_ <one> \\*bold\\* `code` @parsley"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{aliceID, general, ";format raw", []testc.TestMessage{{null, general, "_Italics_ <One> \\*Bold\\* `Code` @parsley"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}

func TestHelp(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		// Took a while to get the regex right; should be # of help msgs * 2 - 1; e.g. 10 lines -> 19
		// NOTE: the default 'help' output is now too long for in-channel reply
		{aliceID, deadzone, ";help", []testc.TestMessage{{null, deadzone, `(?s:Command\(s\) available in this channel:\n;help <keyword> - get help for the provided <keyword>\n\n;help-all - help for all commands available in this channel, including global commands)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, deadzone, ";help-all", []testc.TestMessage{{null, deadzone, `(?s:^Command(?:[^\n]*\n){43}[^\n]*$)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, deadzone, ";help help", []testc.TestMessage{{null, deadzone, `(?s:^Command(?:[^\n]*\n){5}[^\n]*$)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}
</file_content file: gopherbot-main/test/bot_integration_test.go>
<preamble file: gopherbot-main/test/filebrain/brain/README.txt>

</preamble>
<file_content file: gopherbot-main/test/filebrain/brain/README.txt>
(See brain/README.txt)
</file_content file: gopherbot-main/test/filebrain/brain/README.txt>
<preamble file: gopherbot-main/test/filebrain/conf/plugins/pythondemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/filebrain/conf/plugins/pythondemo.yaml>
---
Channels:
- general
</file_content file: gopherbot-main/test/filebrain/conf/plugins/pythondemo.yaml>
<preamble file: gopherbot-main/test/filebrain/conf/plugins/rubydemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/filebrain/conf/plugins/rubydemo.yaml>
---
Channels:
- random
</file_content file: gopherbot-main/test/filebrain/conf/plugins/rubydemo.yaml>
<preamble file: gopherbot-main/test/filebrain/conf/robot.yaml>

</preamble>
<file_content file: gopherbot-main/test/filebrain/conf/robot.yaml>
AdminContact: "Joe User, <user@example.org>"
DefaultChannels: [ "general", "random" ]
DefaultJobChannel: general
JoinChannels: [ ]
AdminUsers: [ "alice" ]
Alias: ";"

{{ $botname := env "GOPHER_BOTNAME" | default "bender" }}
{{ $botfullname := env "GOPHER_BOTFULLNAME" | default "Bender Rodriguez" }}

BotInfo:
  UserName: {{ $botname }}
  FullName: {{ $botfullname }}

ProtocolConfig:
  StartChannel: general
  StartUser: alice
  BotName: {{ $botname }}
  BotFullName: {{ $botfullname }}
  Channels:
  - random
  - general
  - bottest
  - deadzone
  Users:
  - Name: "alice"
    Email: "alice@example.com"
    InternalID: "u0001"
    FullName: "Alice User"
    FirstName: "Alice"
    LastName: "User"
    Phone: "(555)765-0001"
  - Name: "bob"
    Email: "bob@example.com"
    InternalID: "u0002"
    FullName: "Bob User"
    FirstName: "Robert"
    LastName: "User"
    Phone: "(555)765-0002"
  - Name: "carol"
    Email: "@example.com"
    InternalID: "u0003"
    FullName: "Carol User"
    FirstName: "Carol"
    LastName: "User"
    Phone: "(555)765-0003"
  - Name: "david"
    Email: "david@example.com"
    InternalID: "u0004"
    FullName: "David User"
    FirstName: "David"
    LastName: "User"
    Phone: "(555)765-0004"
  - Name: "erin"
    Email: "erin@example.com"
    InternalID: "u0005"
    FullName: "Erin User"
    FirstName: "Erin"
    LastName: "User"
    Phone: "(555)765-0005"

UserRoster:
- UserName: "alice"
  UserID: "u0001"
- UserName: "bob"
  UserID: "u0002"
- UserName: "carol"
  UserID: "u0003"
- UserName: "david"
  UserID: "u0004"
- UserName: "erin"
  UserID: "u0005"

LocalPort: 0
ExternalPlugins:
  "bashdemo":
    Path: plugins/samples/bashdemo.sh
  "pythondemo":
    Path: plugins/samples/pythondemo.py
  "rubydemo":
    Path: plugins/samples/rubydemo.rb
  "echo":
    Path: plugins/samples/echo.sh

WorkSpace: workspace

Brain: file
BrainConfig:
  BrainDirectory: brain
DefaultElevator: builtin-totp
</file_content file: gopherbot-main/test/filebrain/conf/robot.yaml>
<preamble file: gopherbot-main/test/filebrain/private/environment>

</preamble>
<file_content file: gopherbot-main/test/filebrain/private/environment>
# This file is only used when gopherbot is run from this directory.
# The test suite doesn't read it, so it's mainly useful for developing
# and troubleshooting tests. Use "make testbot" to compile gopherbot
# with the terminal connector in test development mode.
GOPHER_PROTOCOL=terminal
GOPHER_LOGFILE=/tmp/term.log
GOPHER_ENCRYPTION_KEY=ThisIsTheTestingKeyNotUsedAnywhereElse
</file_content file: gopherbot-main/test/filebrain/private/environment>
<preamble file: gopherbot-main/test/groups_integration_test.go>

</preamble>
<file_content file: gopherbot-main/test/groups_integration_test.go>
//go:build integration
// +build integration

package bot_test

// lists_integration_test.go - verification of the 'lists' plugin functionality.

import (
	"testing"

	. "github.com/lnxjedi/gopherbot/v2/bot"
	testc "github.com/lnxjedi/gopherbot/v2/connectors/test"
)

func TestGroupAuth(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	tests := []testItem{
		{aliceID, general, ";list groups", []testc.TestMessage{{null, general, "Here are the groups.*"}}, []Event{CommandTaskRan, GoPluginRan, AdminCheckPassed}, 0},
		{aliceID, general, ";show the foo group", []testc.TestMessage{{null, general, "I don't have a .*"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";show the Helpdesk group", []testc.TestMessage{{null, general, "(?m:The Helpdesk group has the following members:\ncarol\nbob$)"}}, []Event{CommandTaskRan, GoPluginRan, AdminCheckPassed}, 0},
		{aliceID, general, ";remember The Alamo", []testc.TestMessage{{null, general, "Sorry, you're not authorized for .*"}}, []Event{GoPluginRan, AdminCheckPassed, AuthRanFail}, 0},
		{carolID, general, ";list groups", []testc.TestMessage{{null, general, "(?m:Here are the groups you're an administrator for:\n.*\n.*$)"}}, []Event{CommandTaskRan, GoPluginRan, AdminCheckFailed}, 0},
		{bobID, general, ";remember Lieutenant Dan", []testc.TestMessage{{null, general, "Ok, .*"}}, []Event{GoPluginRan, AdminCheckFailed, AuthRanSuccess, CommandTaskRan, ExternalTaskRan}, 0},
		{davidID, general, ";remember Forest Gump", []testc.TestMessage{{null, general, "Sorry, you're not authorized for .*"}}, []Event{GoPluginRan, AdminCheckFailed, AuthRanFail}, 0},
		{carolID, general, ";remember Forest Gump", []testc.TestMessage{{null, general, "Ok, I'll remember .*"}}, []Event{GoPluginRan, AdminCheckFailed, AuthRanSuccess, CommandTaskRan, ExternalTaskRan}, 0},
		{carolID, general, ";add david to the Helpdesk group", []testc.TestMessage{{null, general, "Ok, I added david to the Helpdesk group"}}, []Event{CommandTaskRan, GoPluginRan, AdminCheckFailed}, 0},
		{davidID, general, ";remember Jenny", []testc.TestMessage{{null, general, "Ok, I'll remember .*"}}, []Event{GoPluginRan, AdminCheckFailed, AuthRanSuccess, CommandTaskRan, ExternalTaskRan}, 0},
		{aliceID, general, ";remove bob from the Helpdesk group", []testc.TestMessage{{null, general, "bob isn't a dynamic member of the Helpdesk group"}}, []Event{CommandTaskRan, GoPluginRan, AdminCheckPassed}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}
</file_content file: gopherbot-main/test/groups_integration_test.go>
<preamble file: gopherbot-main/test/lists_integration_test.go>

</preamble>
<file_content file: gopherbot-main/test/lists_integration_test.go>
//go:build integration
// +build integration

package bot_test

// lists_integration_test.go - verification of the 'lists' plugin functionality.

import (
	"testing"

	. "github.com/lnxjedi/gopherbot/v2/bot"
	testc "github.com/lnxjedi/gopherbot/v2/connectors/test"
)

func TestLists(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	/* Note on ordering:

	Be careful with the plugins you're testing, and be sure that the robot
	completes all actions before replying. Consider for instance:

		Say "I'll remember \"$1\" is \"$2\" - but eventually I'll forget!"
		Remember "$1" "$2"

	This order of events means the test may well complete (because it got the
	reply) before actually remembering the fact. The next test, recalling the
	fact, could then fail because it tries to recall the fact before it's
	actually been stored in the previous test.

	I know this because it took me a couple of hours to figure out why my
	test was failing. */

	tests := []testItem{
		{aliceID, general, ";list lists", []testc.TestMessage{{null, general, "I don't have any lists"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";add burgers to the meals list", []testc.TestMessage{{alice, general, "I don't have a .*"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{bobID, random, ";add burgers to the meals list", []testc.TestMessage{{bob, random, "I don't have a .*"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{bobID, random, "yes", []testc.TestMessage{{null, random, "Ok, I created a new meals list and added burgers to it"}}, []Event{}, 0},
		{aliceID, general, "yes", []testc.TestMessage{{null, general, "Somebody already created the meals list and added burgers to it"}}, []Event{}, 0},
		{aliceID, general, ";add eggs to the Breakfast list", []testc.TestMessage{{alice, general, "I don't have .*"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{bobID, random, ";add bacon to the breakfast list", []testc.TestMessage{{bob, random, "I don't have a .*"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{bobID, random, "yes", []testc.TestMessage{{null, random, "Ok, I created a new breakfast list and added bacon to it"}}, []Event{}, 0},
		{aliceID, general, "yes", []testc.TestMessage{{null, general, "Ok, I added eggs to the new Breakfast list"}}, []Event{}, 0},
		{aliceID, general, ";show the meals list", []testc.TestMessage{{null, general, `(?m:Here's what I have.*\nburgers$)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{carolID, general, ";remove BURGERS from the meals list", []testc.TestMessage{{null, general, "Ok, I removed BURGERS from the meals list"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{carolID, general, ";show the list", []testc.TestMessage{{null, general, "The meals list is empty"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{carolID, general, ";delete the breakFAST list", []testc.TestMessage{{null, general, "Deleted"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";list lists", []testc.TestMessage{{null, general, `(?m:Here are the lists I know about:\nmeals)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";show the MEALS list", []testc.TestMessage{{null, general, "The MEALS list is empty"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}
</file_content file: gopherbot-main/test/lists_integration_test.go>
<preamble file: gopherbot-main/test/membrain-nameless/conf/plugins/groups.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/groups.yaml>
---
# Generally no real point in configuring both administrators and users;
# administrators can add and remove users dynamically. If a user is listed here
# or stored in memory, they get access.
Disabled: false
Config:
  Groups:
    Helpdesk:
      Administrators:
      - carol
      Users:
      - bob
    SysAdmins:
      Users:
      - david
    NetAdmins:
      Administrators:
      - erin
    Peons:
      Administrators:
      - carol
</file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/groups.yaml>
<preamble file: gopherbot-main/test/membrain-nameless/conf/plugins/ping.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/ping.yaml>
---
Users:
- alice
- carol
# but not bob
</file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/ping.yaml>
<preamble file: gopherbot-main/test/membrain-nameless/conf/plugins/pythondemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/pythondemo.yaml>
---
Channels:
- general
Authorizer: groups
AuthRequire: Helpdesk
AuthorizedCommands:
- remember
</file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/pythondemo.yaml>
<preamble file: gopherbot-main/test/membrain-nameless/conf/plugins/rubydemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/rubydemo.yaml>
---
Channels:
- random
</file_content file: gopherbot-main/test/membrain-nameless/conf/plugins/rubydemo.yaml>
<preamble file: gopherbot-main/test/membrain-nameless/conf/robot.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-nameless/conf/robot.yaml>
AdminContact: "David Parsley, <parsley@linuxjedi.org>"
DefaultChannels: [ "general", "random" ]
DefaultJobChannel: general
JoinChannels: [ ]
AdminUsers: [ "alice" ]
Alias: ";"
LogLevel: debug

{{ $botname := env "GOPHER_BOTNAME" | default "bender" }}
{{ $botfullname := env "GOPHER_BOTFULLNAME" | default "Bender Rodriguez" }}

BotInfo:
  UserName: {{ $botname }}
  FullName: {{ $botfullname }}

ProtocolConfig:
  StartChannel: general
  StartUser: alice
  #BotName: {{ $botname }}
  BotFullName: {{ $botfullname }}
  Channels:
  - random
  - general
  - bottest
  - deadzone
  Users:
  - Name: "alice"
    Email: "alice@example.com"
    InternalID: "u0001"
    FullName: "Alice User"
    FirstName: "Alice"
    LastName: "User"
    Phone: "(555)765-0001"
  - Name: "bob"
    Email: "bob@example.com"
    InternalID: "u0002"
    FullName: "Bob User"
    FirstName: "Robert"
    LastName: "User"
    Phone: "(555)765-0002"
  - Name: "carol"
    Email: "@example.com"
    InternalID: "u0003"
    FullName: "Carol User"
    FirstName: "Carol"
    LastName: "User"
    Phone: "(555)765-0003"
  - Name: "david"
    Email: "david@example.com"
    InternalID: "u0004"
    FullName: "David User"
    FirstName: "David"
    LastName: "User"
    Phone: "(555)765-0004"
  - Name: "erin"
    Email: "erin@example.com"
    InternalID: "u0005"
    FullName: "Erin User"
    FirstName: "Erin"
    LastName: "User"
    Phone: "(555)765-0005"

UserRoster:
- UserName: "alice"
  UserID: "u0001"
- UserName: "bob"
  UserID: "u0002"
- UserName: "carol"
  UserID: "u0003"
- UserName: "david"
  UserID: "u0004"
- UserName: "erin"
  UserID: "u0005"

LocalPort: 0
ExternalPlugins:
  "bashdemo":
    Path: plugins/samples/bashdemo.sh
  "pythondemo":
    Path: plugins/samples/pythondemo.py
  "rubydemo":
    Path: plugins/samples/rubydemo.rb
  "echo":
    Path: plugins/samples/echo.sh
  "test":
    Path: plugins/samples/test.sh
  "hello":
    Path: plugins/samples/hello.sh
  "hello2":
    Path: plugins/samples/hello2.sh

WorkSpace: workspace

Brain: mem
DefaultElevator: builtin-totp
</file_content file: gopherbot-main/test/membrain-nameless/conf/robot.yaml>
<preamble file: gopherbot-main/test/membrain-nameless/private/environment>

</preamble>
<file_content file: gopherbot-main/test/membrain-nameless/private/environment>
# This file is only used when gopherbot is run from this directory.
# The test suite doesn't read it, so it's mainly useful for developing
# and troubleshooting tests. Use "make testbot" to compile gopherbot
# with the terminal connector in test development mode.
GOPHER_PROTOCOL=terminal
GOPHER_LOGFILE=/tmp/term.log
GOPHER_ENCRYPTION_KEY=ThisIsTheTestingKeyNotUsedAnywhereElse
</file_content file: gopherbot-main/test/membrain-nameless/private/environment>
<preamble file: gopherbot-main/test/membrain-noalias/binary-encrypted-key.>

</preamble>
<file_content file: gopherbot-main/test/membrain-noalias/binary-encrypted-key.>
y8Wiy0GpxfR+c1kb/xX9bgLTWWn/S2LlPffr7LLNGVPJL1erjtrAVNDwR3ul7Cd6Tvf1g7cYpD62gjqm
</file_content file: gopherbot-main/test/membrain-noalias/binary-encrypted-key.>
<preamble file: gopherbot-main/test/membrain-noalias/conf/plugins/groups.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/groups.yaml>
---
# Generally no real point in configuring both administrators and users;
# administrators can add and remove users dynamically. If a user is listed here
# or stored in memory, they get access.
Disabled: false
Config:
  Groups:
    Helpdesk:
      Administrators:
      - carol
      Users:
      - bob
    SysAdmins:
      Users:
      - david
    NetAdmins:
      Administrators:
      - erin
    Peons:
      Administrators:
      - carol
</file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/groups.yaml>
<preamble file: gopherbot-main/test/membrain-noalias/conf/plugins/ping.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/ping.yaml>
---
Users:
- alice
- carol
# but not bob
</file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/ping.yaml>
<preamble file: gopherbot-main/test/membrain-noalias/conf/plugins/pythondemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/pythondemo.yaml>
---
Channels:
- general
Authorizer: groups
AuthRequire: Helpdesk
AuthorizedCommands:
- remember
</file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/pythondemo.yaml>
<preamble file: gopherbot-main/test/membrain-noalias/conf/plugins/rubydemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/rubydemo.yaml>
---
Channels:
- random
</file_content file: gopherbot-main/test/membrain-noalias/conf/plugins/rubydemo.yaml>
<preamble file: gopherbot-main/test/membrain-noalias/conf/robot.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain-noalias/conf/robot.yaml>
AdminContact: "David Parsley, <parsley@linuxjedi.org>"
DefaultChannels: [ "general", "random" ]
DefaultJobChannel: general
JoinChannels: [ ]
AdminUsers: [ "alice" ]
# Alias: ""
LogLevel: debug

{{ $botname := env "GOPHER_BOTNAME" | default "bender" }}
{{ $botfullname := env "GOPHER_BOTFULLNAME" | default "Bender Rodriguez" }}

BotInfo:
  UserName: {{ $botname }}
  FullName: {{ $botfullname }}

ProtocolConfig:
  StartChannel: general
  StartUser: alice
  BotName: {{ $botname }}
  BotFullName: {{ $botfullname }}
  Channels:
  - random
  - general
  - bottest
  - deadzone
  Users:
  - Name: "alice"
    Email: "alice@example.com"
    InternalID: "u0001"
    FullName: "Alice User"
    FirstName: "Alice"
    LastName: "User"
    Phone: "(555)765-0001"
  - Name: "bob"
    Email: "bob@example.com"
    InternalID: "u0002"
    FullName: "Bob User"
    FirstName: "Robert"
    LastName: "User"
    Phone: "(555)765-0002"
  - Name: "carol"
    Email: "@example.com"
    InternalID: "u0003"
    FullName: "Carol User"
    FirstName: "Carol"
    LastName: "User"
    Phone: "(555)765-0003"
  - Name: "david"
    Email: "david@example.com"
    InternalID: "u0004"
    FullName: "David User"
    FirstName: "David"
    LastName: "User"
    Phone: "(555)765-0004"
  - Name: "erin"
    Email: "erin@example.com"
    InternalID: "u0005"
    FullName: "Erin User"
    FirstName: "Erin"
    LastName: "User"
    Phone: "(555)765-0005"

UserRoster:
- UserName: "alice"
  UserID: "u0001"
- UserName: "bob"
  UserID: "u0002"
- UserName: "carol"
  UserID: "u0003"
- UserName: "david"
  UserID: "u0004"
- UserName: "erin"
  UserID: "u0005"

LocalPort: 0
ExternalPlugins:
  "bashdemo":
    Path: plugins/samples/bashdemo.sh
  "pythondemo":
    Path: plugins/samples/pythondemo.py
  "rubydemo":
    Path: plugins/samples/rubydemo.rb
  "echo":
    Path: plugins/samples/echo.sh
  "test":
    Path: plugins/samples/test.sh
  "hello":
    Path: plugins/samples/hello.sh
  "hello2":
    Path: plugins/samples/hello2.sh

WorkSpace: workspace

Brain: mem
DefaultElevator: builtin-totp
</file_content file: gopherbot-main/test/membrain-noalias/conf/robot.yaml>
<preamble file: gopherbot-main/test/membrain-noalias/private/environment>

</preamble>
<file_content file: gopherbot-main/test/membrain-noalias/private/environment>
# This file is only used when gopherbot is run from this directory.
# The test suite doesn't read it, so it's mainly useful for developing
# and troubleshooting tests. Use "make testbot" to compile gopherbot
# with the terminal connector in test development mode.
GOPHER_PROTOCOL=terminal
GOPHER_LOGFILE=/tmp/term.log
GOPHER_ENCRYPTION_KEY=ThisIsTheTestingKeyNotUsedAnywhereElse
</file_content file: gopherbot-main/test/membrain-noalias/private/environment>
<preamble file: gopherbot-main/test/membrain/binary-encrypted-key.>

</preamble>
<file_content file: gopherbot-main/test/membrain/binary-encrypted-key.>
WwfoKgL//PljruiHUOJsvBQHNBIR5SgLXxQklGL6n1WzFdQqz3qy1K8G6nn0u8+gJwY6mkWfGPyePCHh
</file_content file: gopherbot-main/test/membrain/binary-encrypted-key.>
<preamble file: gopherbot-main/test/membrain/conf/plugins/builtin-admin.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain/conf/plugins/builtin-admin.yaml>
---
AllChannels: false
</file_content file: gopherbot-main/test/membrain/conf/plugins/builtin-admin.yaml>
<preamble file: gopherbot-main/test/membrain/conf/plugins/groups.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain/conf/plugins/groups.yaml>
---
# Generally no real point in configuring both administrators and users;
# administrators can add and remove users dynamically. If a user is listed here
# or stored in memory, they get access.
Disabled: false
Config:
  Groups:
    Helpdesk:
      Administrators:
      - carol
      Users:
      - bob
    SysAdmins:
      Users:
      - david
    NetAdmins:
      Administrators:
      - erin
    Peons:
      Administrators:
      - carol
</file_content file: gopherbot-main/test/membrain/conf/plugins/groups.yaml>
<preamble file: gopherbot-main/test/membrain/conf/plugins/ping.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain/conf/plugins/ping.yaml>
---
Users:
- alice
- carol
# but not bob
</file_content file: gopherbot-main/test/membrain/conf/plugins/ping.yaml>
<preamble file: gopherbot-main/test/membrain/conf/plugins/pythondemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain/conf/plugins/pythondemo.yaml>
---
Channels:
- general
Authorizer: groups
AuthRequire: Helpdesk
AuthorizedCommands:
- remember
</file_content file: gopherbot-main/test/membrain/conf/plugins/pythondemo.yaml>
<preamble file: gopherbot-main/test/membrain/conf/plugins/rubydemo.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain/conf/plugins/rubydemo.yaml>
---
Channels:
- random
</file_content file: gopherbot-main/test/membrain/conf/plugins/rubydemo.yaml>
<preamble file: gopherbot-main/test/membrain/conf/robot.yaml>

</preamble>
<file_content file: gopherbot-main/test/membrain/conf/robot.yaml>
AdminContact: "David Parsley, <parsley@linuxjedi.org>"
DefaultChannels: [ "general", "random" ]
DefaultJobChannel: general
JoinChannels: [ ]
AdminUsers: [ "alice" ]
Alias: ";"
LogLevel: debug

{{ $botname := env "GOPHER_BOTNAME" | default "bender" }}
{{ $botfullname := env "GOPHER_BOTFULLNAME" | default "Bender Rodriguez" }}

BotInfo:
  UserName: {{ $botname }}
  FullName: {{ $botfullname }}

ProtocolConfig:
  StartChannel: general
  StartUser: alice
  BotName: {{ $botname }}
  BotFullName: {{ $botfullname }}
  Channels:
  - random
  - general
  - bottest
  - deadzone
  Users:
  - Name: "alice"
    Email: "alice@example.com"
    InternalID: "u0001"
    FullName: "Alice User"
    FirstName: "Alice"
    LastName: "User"
    Phone: "(555)765-0001"
  - Name: "bob"
    Email: "bob@example.com"
    InternalID: "u0002"
    FullName: "Bob User"
    FirstName: "Robert"
    LastName: "User"
    Phone: "(555)765-0002"
  - Name: "carol"
    Email: "@example.com"
    InternalID: "u0003"
    FullName: "Carol User"
    FirstName: "Carol"
    LastName: "User"
    Phone: "(555)765-0003"
  - Name: "david"
    Email: "david@example.com"
    InternalID: "u0004"
    FullName: "David User"
    FirstName: "David"
    LastName: "User"
    Phone: "(555)765-0004"
  - Name: "erin"
    Email: "erin@example.com"
    InternalID: "u0005"
    FullName: "Erin User"
    FirstName: "Erin"
    LastName: "User"
    Phone: "(555)765-0005"

UserRoster:
- UserName: "alice"
  UserID: "u0001"
- UserName: "bob"
  UserID: "u0002"
- UserName: "carol"
  UserID: "u0003"
- UserName: "david"
  UserID: "u0004"
- UserName: "erin"
  UserID: "u0005"

LocalPort: 0
ExternalPlugins:
  "bashdemo":
    Path: plugins/samples/bashdemo.sh
  "pythondemo":
    Path: plugins/samples/pythondemo.py
  "rubydemo":
    Path: plugins/samples/rubydemo.rb
  "echo":
    Path: plugins/samples/echo.sh
  "test":
    Path: plugins/samples/test.sh
  "hello":
    Path: plugins/samples/hello.sh
  "hello2":
    Path: plugins/samples/hello2.sh
  "format":
    Path: plugins/samples/format.sh

WorkSpace: workspace

Brain: mem
DefaultElevator: builtin-totp
</file_content file: gopherbot-main/test/membrain/conf/robot.yaml>
<preamble file: gopherbot-main/test/membrain/plugins/samples/echo.sh>

</preamble>
<file_content file: gopherbot-main/test/membrain/plugins/samples/echo.sh>
#!/bin/bash

# echo.sh - trivial shell plugin example for Gopherbot

# START Boilerplate
[ -z "$GOPHER_INSTALLDIR" ] && { echo "GOPHER_INSTALLDIR not set" >&2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat <<"EOF"
---
Help:
- Keywords: [ "repeat" ]
  Helptext: [ "(bot), repeat (me) - prompt for and trivially repeat a phrase" ]
- Keywords: [ "echo" ]
  Helptext: [ "(bot), echo <something> - tell the bot to say <something>" ]
CommandMatchers:
- Command: "repeat"
  Regex: '(?i:repeat( me)?)'
- Command: "echo"
  Regex: '(?i:echo (.*))'
EOF
}

case "$command" in
# NOTE: only "configure" should print anything to stdout
	"configure")
		configure
		;;
	"echo")
		Pause 1 # because the robot knows how to "type"
		Say "Sure thing: $1"
		;;
	"repeat")
		REPEAT=$(PromptForReply SimpleString "What do you want me to repeat?")
		RETVAL=$?
		if [ $RETVAL -ne $GBRET_Ok ]
		then
			Reply "Sorry, I had a problem getting your reply: $RETVAL"
		else
			Reply "$REPEAT"
		fi
		;;
esac
</file_content file: gopherbot-main/test/membrain/plugins/samples/echo.sh>
<preamble file: gopherbot-main/test/membrain/private/environment>

</preamble>
<file_content file: gopherbot-main/test/membrain/private/environment>
# This file is only used when gopherbot is run from this directory.
# The test suite doesn't read it, so it's mainly useful for developing
# and troubleshooting tests. Use "make testbot" to compile gopherbot
# with the terminal connector in test development mode.
GOPHER_PROTOCOL=terminal
GOPHER_LOGFILE=/tmp/term.log
GOPHER_ENCRYPTION_KEY=ThisIsTheTestingKeyNotUsedAnywhereElse
</file_content file: gopherbot-main/test/membrain/private/environment>
<preamble file: gopherbot-main/test/memory_integration_test.go>

</preamble>
<file_content file: gopherbot-main/test/memory_integration_test.go>
//go:build integration
// +build integration

package bot_test

// memory_integration_test.go - tests that stress the robot's memory functions.

import (
	"testing"

	. "github.com/lnxjedi/gopherbot/v2/bot"
	testc "github.com/lnxjedi/gopherbot/v2/connectors/test"
)

func TestMemory(t *testing.T) {
	done, conn := setup("test/membrain", "/tmp/bottest.log", t)

	/* Note on ordering:

	Be careful with the plugins you're testing, and be sure that the robot
	completes all actions before replying. Consider for instance:

		Say "I'll remember \"$1\" is \"$2\" - but eventually I'll forget!"
		Remember "$1" "$2"

	This order of events means the test may well complete (because it got the
	reply) before actually remembering the fact. The next test, recalling the
	fact, could then fail because it tries to recall the fact before it's
	actually been stored in the previous test.

	I know this because it took me a couple of hours to figure out why my
	test was failing. */

	tests := []testItem{
		{carolID, random, ";remember slowly The Alamo", []testc.TestMessage{{null, random, "Ok, .*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{aliceID, random, ";remember Ferris Bueller", []testc.TestMessage{{null, random, "Ok, .*"}, {null, random, "committed to memory"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{bobID, random, "recall 1, Bender", []testc.TestMessage{{null, random, "Ferris Bueller"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{carolID, random, ";remember Ferris Bueller", []testc.TestMessage{{null, random, "That's already one of my fondest memories"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{davidID, random, "forget 1, Bender", []testc.TestMessage{{null, random, "Ok, .*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		// Short-term memories are contextual to a user in a channel
		{davidID, general, "Bender, what is Ferris Bueller?", []testc.TestMessage{{david, general, "Gosh, I have no idea .*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{davidID, general, ";store Ferris Bueller is a Righteous Dude", []testc.TestMessage{{null, general, "I'll remember .*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{davidID, general, "Bender, what is Ferris Bueller?", []testc.TestMessage{{null, general, "Ferris Bueller is a Righteous Dude"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{carolID, general, "Bender, what is Ferris Bueller?", []testc.TestMessage{{carol, general, "Gosh, I have no idea .*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{davidID, random, "Bender, what is Ferris Bueller?", []testc.TestMessage{{david, random, "Gosh, I have no idea .*"}}, []Event{CommandTaskRan, ExternalTaskRan}, 0},
		{bobID, general, "Bender, link news for nerds to https://slashdot.org", []testc.TestMessage{{null, general, "Link added"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{bobID, general, ";save https://slashdot.org", []testc.TestMessage{{null, general, "I already have that link"}, {bob, general, "Do you want .*"}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{bobID, general, "yes", []testc.TestMessage{{null, general, "Ok, I'll replace the old one"}, {bob, general, "What keywords or phrase .*"}}, []Event{}, 0},
		{bobID, general, "News for Nerds, Stuff that Matters!", []testc.TestMessage{{null, general, "Link added"}}, []Event{}, 0},
		{carolID, general, "Bender, look up nerds", []testc.TestMessage{{null, general, `(?s:Here's what I have .*Nerds.*)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";link tuna casserole to https://www.allrecipes.com/recipe/17219/best-tuna-casserole/", []testc.TestMessage{{null, general, `Link added`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, ";add it to the dinner meals list", []testc.TestMessage{{alice, general, `I don't have a .*`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "yes", []testc.TestMessage{{null, general, `Ok, .*`}}, []Event{}, 0},
		{aliceID, general, "Bender, look it up", []testc.TestMessage{{null, general, `(?s:Here's what I have .*best.*)`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
		{aliceID, general, "add hamburgers to the list, bender", []testc.TestMessage{{null, general, `Ok, I added hamburgers to the dinner meals list`}}, []Event{CommandTaskRan, GoPluginRan}, 0},
	}
	testcases(t, conn, tests)

	teardown(t, done, conn)
}
</file_content file: gopherbot-main/test/memory_integration_test.go>
